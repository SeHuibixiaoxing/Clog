Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> compUnit
Rule 1     empty -> <empty>
Rule 2     compUnit_repeat -> empty
Rule 3     compUnit_repeat -> compUnit compUnit_repeat
Rule 4     compUnit -> decl compUnit_repeat
Rule 5     compUnit -> cir_function compUnit_repeat
Rule 6     compUnit -> function compUnit_repeat
Rule 7     compUnit -> module compUnit_repeat
Rule 8     compUnit -> bundle compUnit_repeat
Rule 9     decl -> constDecl
Rule 10    decl -> varDecl
Rule 11    decl -> cirDecl
Rule 12    decl -> modDecl
Rule 13    decl -> bundleDecl
Rule 14    constDecl_repeat -> empty
Rule 15    constDecl_repeat -> , constDef constDecl_repeat
Rule 16    constDecl -> CONST val_type constDef constDecl_repeat ;
Rule 17    cir_basic_type -> REG
Rule 18    cir_basic_type -> WIRE
Rule 19    cir_basic_type -> CLOCK
Rule 20    cir_basic_type -> ID
Rule 21    cir_type -> cir_basic_type
Rule 22    cir_type -> cir_basic_type [ exp ]
Rule 23    val_type -> INT
Rule 24    val_type -> FLOAT
Rule 25    type_def -> val_type
Rule 26    type_def -> cir_type
Rule 27    array -> empty
Rule 28    array -> [ constExp ] array
Rule 29    constDef -> ID array ASSIGN constInitVal
Rule 30    constInitVal_repeat -> empty
Rule 31    constInitVal_repeat -> , constInitVal constInitVal_repeat
Rule 32    constInitVal -> constExp
Rule 33    constInitVal -> { constInitVal constInitVal_repeat }
Rule 34    varDef_repeat -> empty
Rule 35    varDef_repeat -> , varDef varDef_repeat
Rule 36    varDecl -> val_type varDef varDef_repeat ;
Rule 37    varDef -> ID array
Rule 38    varDef -> ID array ASSIGN initVal
Rule 39    modDecl -> ID ( module_R_params ) ID array ;
Rule 40    R_port_def -> IN .
Rule 41    R_port_def -> OUT .
Rule 42    R_port_def -> INOUT .
Rule 43    p_module_R_params_item -> R_port_def ID ( ID )
Rule 44    module_R_params_repeat -> empty
Rule 45    module_R_params_repeat -> , p_module_R_params_item module_R_params_repeat
Rule 46    module_R_params -> p_module_R_params_item module_R_params_repeat
Rule 47    bundleDecl_repeat -> empty
Rule 48    bundleDecl_repeat -> , bundleDef bundleDecl_repeat
Rule 49    bundleDecl -> ID bundleDef bundleDecl_repeat
Rule 50    bundleDef -> ID array
Rule 51    initVal_repeat -> empty
Rule 52    initVal_repeat -> , initVal initVal_repeat
Rule 53    initVal -> exp
Rule 54    initVal -> { initVal initVal_repeat }
Rule 55    cirDecl_repeat -> empty
Rule 56    cirDecl_repeat -> , cirDef cirDecl_repeat
Rule 57    cirDecl -> cir_type cirDef cirDecl_repeat ;
Rule 58    cirDef -> ID array
Rule 59    cirDef -> ID array ASSIGN initVal
Rule 60    cir_function -> cir_type ID ( cir_funcFParams ) block
Rule 61    function -> val_type ID ( funcFParams ) block
Rule 62    cir_funcFParams_repeat -> empty
Rule 63    cir_funcFParams_repeat -> , cir_funcFParam cir_funcFParams_repeat
Rule 64    cir_funcFParams -> cir_funcFParam cir_funcFParams_repeat
Rule 65    funcFParams_repeat -> empty
Rule 66    funcFParams_repeat -> , funcFParam funcFParams_repeat
Rule 67    funcFParams -> funcFParam funcFParams_repeat
Rule 68    cir_funcFParam -> type_def ID array
Rule 69    funcFParam -> val_type ID array
Rule 70    module_para_para -> empty
Rule 71    module_para_para -> PARA val_type ID ,
Rule 72    module_para_para -> PARA val_type ID , module_para_para
Rule 73    p_module_para_port -> empty
Rule 74    p_module_para_port -> , port_def ID p_module_para_port
Rule 75    module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block
Rule 76    bundle_repeat -> empty
Rule 77    bundle_repeat -> , cir_type ID bundle_repeat
Rule 78    bundle -> BUNDLE ID ( cir_type ID bundle_repeat )
Rule 79    block_repeat -> empty
Rule 80    block_repeat -> blockItem block_repeat
Rule 81    block -> { block_repeat }
Rule 82    blockItem -> decl
Rule 83    blockItem -> stmt
Rule 84    stmt -> lVal ASSIGN exp ;
Rule 85    stmt -> lVal CONNECT exp ;
Rule 86    stmt -> ;
Rule 87    stmt -> exp
Rule 88    stmt -> block
Rule 89    stmt -> seqLogStmt
Rule 90    stmt -> ifStmt
Rule 91    stmt -> forStmt
Rule 92    stmt -> RETURN exp ;
Rule 93    seqLogStmt -> WHEN ( ID ) stmt
Rule 94    seqLogStmt -> WHEN ( ID . RISING ) stmt
Rule 95    seqLogStmt -> WHEN ( ID . FALLING ) stmt
Rule 96    elifStmt -> ELIF ( exp ) stmt elifStmt
Rule 97    elifStmt -> empty
Rule 98    elseStmt -> ELSE stmt
Rule 99    elseStmt -> empty
Rule 100   ifStmt -> IF ( exp ) stmt elifStmt elseStmt
Rule 101   forStmt -> FOR ( varDecl exp ; stmt ) stmt
Rule 102   forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
Rule 103   exp -> lOrExp
Rule 104   lVal -> ID array_exp_repeat1
Rule 105   lVal -> ID array_exp_repeat2
Rule 106   lVal -> { ID array_exp_repeat1 lVal_repeat }
Rule 107   lVal -> { ID array_exp_repeat2 lVal_repeat }
Rule 108   lVal -> MUX ( exp , exp , exp )
Rule 109   lVal -> lVal . ID
Rule 110   primaryExp -> ( exp )
Rule 111   primaryExp -> lVal
Rule 112   primaryExp -> number
Rule 113   lVal_repeat -> empty
Rule 114   lVal_repeat -> , lVal lVal_repeat
Rule 115   array_exp_repeat1 -> empty
Rule 116   array_exp_repeat1 -> [ exp ] array_exp_repeat1
Rule 117   array_exp_repeat2 -> empty
Rule 118   array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2
Rule 119   number -> INTEGER_CONST
Rule 120   number -> FLOAT_CONST
Rule 121   number -> circuit_const
Rule 122   circuit_const -> exp BIT_WIDTH_NUMBER
Rule 123   unaryExp -> primaryExp
Rule 124   unaryExp -> ID ( )
Rule 125   unaryExp -> ID ( funcRParams )
Rule 126   unaryExp -> SIGNAL ( unaryExp )
Rule 127   unaryExp -> unaryOp unaryExp
Rule 128   unaryOp -> ADD
Rule 129   unaryOp -> SUB
Rule 130   unaryOp -> NOT
Rule 131   unaryOp -> NOTL
Rule 132   exp_repeat -> empty
Rule 133   exp_repeat -> , exp exp_repeat
Rule 134   funcRParams -> exp
Rule 135   funcRParams -> exp exp_repeat
Rule 136   mulExp -> unaryExp
Rule 137   mulExp -> mulExp MUL unaryExp
Rule 138   mulExp -> mulExp DIV unaryExp
Rule 139   mulExp -> mulExp MOD unaryExp
Rule 140   mulExp -> mulExp POWER unaryExp
Rule 141   addExp -> mulExp
Rule 142   addExp -> addExp ADD mulExp
Rule 143   addExp -> addExp SUB mulExp
Rule 144   shiftExp -> addExp
Rule 145   shiftExp -> shiftExp SLL addExp
Rule 146   shiftExp -> shiftExp SRL addExp
Rule 147   shiftExp -> shiftExp SRA addExp
Rule 148   relExp -> shiftExp
Rule 149   relExp -> relExp LT addExp
Rule 150   relExp -> relExp GT addExp
Rule 151   relExp -> relExp GE addExp
Rule 152   relExp -> relExp LE addExp
Rule 153   eqExp -> relExp
Rule 154   eqExp -> eqExp EQUAL eqExp
Rule 155   eqExp -> eqExp NEQ eqExp
Rule 156   redExp -> eqExp
Rule 157   redExp -> redExp AND eqExp
Rule 158   redExp -> redExp OR eqExp
Rule 159   redExp -> redExp XOR eqExp
Rule 160   redExp -> redExp XNOR eqExp
Rule 161   lAndExp -> redExp
Rule 162   lAndExp -> lAndExp LAND redExp
Rule 163   lOrExp -> lAndExp
Rule 164   lOrExp -> lOrExp LOR lAndExp
Rule 165   port_def -> INPUT cir_type
Rule 166   port_def -> OUTPUT cir_type
Rule 167   port_def -> INOUT cir_type
Rule 168   constExp -> exp

Terminals, with rules where they appear

(                    : 39 43 60 61 75 78 93 94 95 96 100 101 102 108 110 124 125 126
)                    : 39 43 60 61 75 78 93 94 95 96 100 101 102 108 110 124 125 126
,                    : 15 31 35 45 48 52 56 63 66 71 72 74 77 108 108 114 133
.                    : 40 41 42 94 95 109
;                    : 16 36 39 57 84 85 86 92 101 102
ADD                  : 128 142
AND                  : 157
ASSIGN               : 29 38 59 84
BIT_WIDTH_NUMBER     : 122
BUNDLE               : 78
CLOCK                : 19
COLON                : 102 118
CONNECT              : 85
CONST                : 16
DIV                  : 138
ELIF                 : 96
ELSE                 : 98
EQUAL                : 154
FALLING              : 95
FLOAT                : 24
FLOAT_CONST          : 120
FOR                  : 101 102
GE                   : 151
GENERATE             : 102
GT                   : 150
ID                   : 20 29 37 38 39 39 43 43 49 50 58 59 60 61 68 69 71 72 74 75 75 77 78 78 93 94 95 102 104 105 106 107 109 124 125
IF                   : 100
IN                   : 40
INOUT                : 42 167
INPUT                : 165
INT                  : 23
INTEGER_CONST        : 119
LAND                 : 162
LE                   : 152
LOR                  : 164
LT                   : 149
MOD                  : 139
MODULE               : 75
MUL                  : 137
MUX                  : 108
NEQ                  : 155
NOT                  : 130
NOTL                 : 131
OR                   : 158
OUT                  : 41
OUTPUT               : 166
PARA                 : 71 72
POWER                : 140
REG                  : 17
RETURN               : 92
RISING               : 94
SIGNAL               : 126
SLL                  : 145
SRA                  : 147
SRL                  : 146
SUB                  : 129 143
WHEN                 : 93 94 95
WIRE                 : 18
XNOR                 : 160
XOR                  : 159
[                    : 22 28 116 118
]                    : 22 28 116 118
error                : 
{                    : 33 54 81 106 107
}                    : 33 54 81 106 107

Nonterminals, with rules where they appear

R_port_def           : 43
addExp               : 142 143 144 145 146 147 149 150 151 152
array                : 28 29 37 38 39 50 58 59 68 69
array_exp_repeat1    : 104 106 116
array_exp_repeat2    : 105 107 118
block                : 60 61 75 88
blockItem            : 80
block_repeat         : 80 81
bundle               : 8
bundleDecl           : 13
bundleDecl_repeat    : 48 49
bundleDef            : 48 49
bundle_repeat        : 77 78
cirDecl              : 11
cirDecl_repeat       : 56 57
cirDef               : 56 57
cir_basic_type       : 21 22
cir_funcFParam       : 63 64
cir_funcFParams      : 60
cir_funcFParams_repeat : 63 64
cir_function         : 5
cir_type             : 26 57 60 77 78 165 166 167
circuit_const        : 121
compUnit             : 3 0
compUnit_repeat      : 3 4 5 6 7 8
constDecl            : 9
constDecl_repeat     : 15 16
constDef             : 15 16
constExp             : 28 32
constInitVal         : 29 31 33
constInitVal_repeat  : 31 33
decl                 : 4 82
elifStmt             : 96 100
elseStmt             : 100
empty                : 2 14 27 30 34 44 47 51 55 62 65 70 73 76 79 97 99 113 115 117 132
eqExp                : 154 154 155 155 156 157 158 159 160
exp                  : 22 53 84 85 87 92 96 100 101 102 102 108 108 108 110 116 118 118 122 133 134 135 168
exp_repeat           : 133 135
forStmt              : 91
funcFParam           : 66 67
funcFParams          : 61
funcFParams_repeat   : 66 67
funcRParams          : 125
function             : 6
ifStmt               : 90
initVal              : 38 52 54 59
initVal_repeat       : 52 54
lAndExp              : 162 163 164
lOrExp               : 103 164
lVal                 : 84 85 109 111 114
lVal_repeat          : 106 107 114
modDecl              : 12
module               : 7
module_R_params      : 39
module_R_params_repeat : 45 46
module_para_para     : 72 75
mulExp               : 137 138 139 140 141 142 143
number               : 112
p_module_R_params_item : 45 46
p_module_para_port   : 74 75
port_def             : 74 75
primaryExp           : 123
redExp               : 157 158 159 160 161 162
relExp               : 149 150 151 152 153
seqLogStmt           : 89
shiftExp             : 145 146 147 148
stmt                 : 83 93 94 95 96 98 100 101 101 102
type_def             : 68
unaryExp             : 126 127 136 137 138 139 140
unaryOp              : 127
val_type             : 16 25 36 61 69 71 72
varDecl              : 10 101 102
varDef               : 35 36
varDef_repeat        : 35 36

Parsing method: LALR

state 0

    (0) S' -> . compUnit
    (4) compUnit -> . decl compUnit_repeat
    (5) compUnit -> . cir_function compUnit_repeat
    (6) compUnit -> . function compUnit_repeat
    (7) compUnit -> . module compUnit_repeat
    (8) compUnit -> . bundle compUnit_repeat
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (60) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (61) function -> . val_type ID ( funcFParams ) block
    (75) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port ) block
    (78) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

    MODULE          shift and go to state 15
    BUNDLE          shift and go to state 16
    CONST           shift and go to state 17
    ID              shift and go to state 13
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23

    compUnit                       shift and go to state 1
    decl                           shift and go to state 2
    cir_function                   shift and go to state 3
    function                       shift and go to state 4
    module                         shift and go to state 5
    bundle                         shift and go to state 6
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    cir_type                       shift and go to state 12
    val_type                       shift and go to state 14
    cir_basic_type                 shift and go to state 18

state 1

    (0) S' -> compUnit .



state 2

    (4) compUnit -> decl . compUnit_repeat
    (2) compUnit_repeat -> . empty
    (3) compUnit_repeat -> . compUnit compUnit_repeat
    (1) empty -> .
    (4) compUnit -> . decl compUnit_repeat
    (5) compUnit -> . cir_function compUnit_repeat
    (6) compUnit -> . function compUnit_repeat
    (7) compUnit -> . module compUnit_repeat
    (8) compUnit -> . bundle compUnit_repeat
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (60) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (61) function -> . val_type ID ( funcFParams ) block
    (75) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port ) block
    (78) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    $end            reduce using rule 1 (empty -> .)
    MODULE          shift and go to state 15
    BUNDLE          shift and go to state 16
    CONST           shift and go to state 17
    ID              shift and go to state 13
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23

  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]

    decl                           shift and go to state 2
    compUnit_repeat                shift and go to state 24
    empty                          shift and go to state 25
    compUnit                       shift and go to state 26
    cir_function                   shift and go to state 3
    function                       shift and go to state 4
    module                         shift and go to state 5
    bundle                         shift and go to state 6
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    cir_type                       shift and go to state 12
    val_type                       shift and go to state 14
    cir_basic_type                 shift and go to state 18

state 3

    (5) compUnit -> cir_function . compUnit_repeat
    (2) compUnit_repeat -> . empty
    (3) compUnit_repeat -> . compUnit compUnit_repeat
    (1) empty -> .
    (4) compUnit -> . decl compUnit_repeat
    (5) compUnit -> . cir_function compUnit_repeat
    (6) compUnit -> . function compUnit_repeat
    (7) compUnit -> . module compUnit_repeat
    (8) compUnit -> . bundle compUnit_repeat
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (60) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (61) function -> . val_type ID ( funcFParams ) block
    (75) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port ) block
    (78) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    $end            reduce using rule 1 (empty -> .)
    MODULE          shift and go to state 15
    BUNDLE          shift and go to state 16
    CONST           shift and go to state 17
    ID              shift and go to state 13
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23

  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]

    cir_function                   shift and go to state 3
    compUnit_repeat                shift and go to state 27
    empty                          shift and go to state 25
    compUnit                       shift and go to state 26
    decl                           shift and go to state 2
    function                       shift and go to state 4
    module                         shift and go to state 5
    bundle                         shift and go to state 6
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    cir_type                       shift and go to state 12
    val_type                       shift and go to state 14
    cir_basic_type                 shift and go to state 18

state 4

    (6) compUnit -> function . compUnit_repeat
    (2) compUnit_repeat -> . empty
    (3) compUnit_repeat -> . compUnit compUnit_repeat
    (1) empty -> .
    (4) compUnit -> . decl compUnit_repeat
    (5) compUnit -> . cir_function compUnit_repeat
    (6) compUnit -> . function compUnit_repeat
    (7) compUnit -> . module compUnit_repeat
    (8) compUnit -> . bundle compUnit_repeat
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (60) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (61) function -> . val_type ID ( funcFParams ) block
    (75) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port ) block
    (78) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    $end            reduce using rule 1 (empty -> .)
    MODULE          shift and go to state 15
    BUNDLE          shift and go to state 16
    CONST           shift and go to state 17
    ID              shift and go to state 13
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23

  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]

    function                       shift and go to state 4
    compUnit_repeat                shift and go to state 28
    empty                          shift and go to state 25
    compUnit                       shift and go to state 26
    decl                           shift and go to state 2
    cir_function                   shift and go to state 3
    module                         shift and go to state 5
    bundle                         shift and go to state 6
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    cir_type                       shift and go to state 12
    val_type                       shift and go to state 14
    cir_basic_type                 shift and go to state 18

state 5

    (7) compUnit -> module . compUnit_repeat
    (2) compUnit_repeat -> . empty
    (3) compUnit_repeat -> . compUnit compUnit_repeat
    (1) empty -> .
    (4) compUnit -> . decl compUnit_repeat
    (5) compUnit -> . cir_function compUnit_repeat
    (6) compUnit -> . function compUnit_repeat
    (7) compUnit -> . module compUnit_repeat
    (8) compUnit -> . bundle compUnit_repeat
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (60) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (61) function -> . val_type ID ( funcFParams ) block
    (75) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port ) block
    (78) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    $end            reduce using rule 1 (empty -> .)
    MODULE          shift and go to state 15
    BUNDLE          shift and go to state 16
    CONST           shift and go to state 17
    ID              shift and go to state 13
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23

  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]

    module                         shift and go to state 5
    compUnit_repeat                shift and go to state 29
    empty                          shift and go to state 25
    compUnit                       shift and go to state 26
    decl                           shift and go to state 2
    cir_function                   shift and go to state 3
    function                       shift and go to state 4
    bundle                         shift and go to state 6
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    cir_type                       shift and go to state 12
    val_type                       shift and go to state 14
    cir_basic_type                 shift and go to state 18

state 6

    (8) compUnit -> bundle . compUnit_repeat
    (2) compUnit_repeat -> . empty
    (3) compUnit_repeat -> . compUnit compUnit_repeat
    (1) empty -> .
    (4) compUnit -> . decl compUnit_repeat
    (5) compUnit -> . cir_function compUnit_repeat
    (6) compUnit -> . function compUnit_repeat
    (7) compUnit -> . module compUnit_repeat
    (8) compUnit -> . bundle compUnit_repeat
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (60) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (61) function -> . val_type ID ( funcFParams ) block
    (75) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port ) block
    (78) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    $end            reduce using rule 1 (empty -> .)
    MODULE          shift and go to state 15
    BUNDLE          shift and go to state 16
    CONST           shift and go to state 17
    ID              shift and go to state 13
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23

  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]

    bundle                         shift and go to state 6
    compUnit_repeat                shift and go to state 30
    empty                          shift and go to state 25
    compUnit                       shift and go to state 26
    decl                           shift and go to state 2
    cir_function                   shift and go to state 3
    function                       shift and go to state 4
    module                         shift and go to state 5
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    cir_type                       shift and go to state 12
    val_type                       shift and go to state 14
    cir_basic_type                 shift and go to state 18

state 7

    (9) decl -> constDecl .

    MODULE          reduce using rule 9 (decl -> constDecl .)
    BUNDLE          reduce using rule 9 (decl -> constDecl .)
    CONST           reduce using rule 9 (decl -> constDecl .)
    ID              reduce using rule 9 (decl -> constDecl .)
    INT             reduce using rule 9 (decl -> constDecl .)
    FLOAT           reduce using rule 9 (decl -> constDecl .)
    REG             reduce using rule 9 (decl -> constDecl .)
    WIRE            reduce using rule 9 (decl -> constDecl .)
    CLOCK           reduce using rule 9 (decl -> constDecl .)
    $end            reduce using rule 9 (decl -> constDecl .)
    ;               reduce using rule 9 (decl -> constDecl .)
    RETURN          reduce using rule 9 (decl -> constDecl .)
    {               reduce using rule 9 (decl -> constDecl .)
    MUX             reduce using rule 9 (decl -> constDecl .)
    WHEN            reduce using rule 9 (decl -> constDecl .)
    IF              reduce using rule 9 (decl -> constDecl .)
    FOR             reduce using rule 9 (decl -> constDecl .)
    GENERATE        reduce using rule 9 (decl -> constDecl .)
    SIGNAL          reduce using rule 9 (decl -> constDecl .)
    (               reduce using rule 9 (decl -> constDecl .)
    ADD             reduce using rule 9 (decl -> constDecl .)
    SUB             reduce using rule 9 (decl -> constDecl .)
    NOT             reduce using rule 9 (decl -> constDecl .)
    NOTL            reduce using rule 9 (decl -> constDecl .)
    INTEGER_CONST   reduce using rule 9 (decl -> constDecl .)
    FLOAT_CONST     reduce using rule 9 (decl -> constDecl .)
    }               reduce using rule 9 (decl -> constDecl .)


state 8

    (10) decl -> varDecl .

    MODULE          reduce using rule 10 (decl -> varDecl .)
    BUNDLE          reduce using rule 10 (decl -> varDecl .)
    CONST           reduce using rule 10 (decl -> varDecl .)
    ID              reduce using rule 10 (decl -> varDecl .)
    INT             reduce using rule 10 (decl -> varDecl .)
    FLOAT           reduce using rule 10 (decl -> varDecl .)
    REG             reduce using rule 10 (decl -> varDecl .)
    WIRE            reduce using rule 10 (decl -> varDecl .)
    CLOCK           reduce using rule 10 (decl -> varDecl .)
    $end            reduce using rule 10 (decl -> varDecl .)
    ;               reduce using rule 10 (decl -> varDecl .)
    RETURN          reduce using rule 10 (decl -> varDecl .)
    {               reduce using rule 10 (decl -> varDecl .)
    MUX             reduce using rule 10 (decl -> varDecl .)
    WHEN            reduce using rule 10 (decl -> varDecl .)
    IF              reduce using rule 10 (decl -> varDecl .)
    FOR             reduce using rule 10 (decl -> varDecl .)
    GENERATE        reduce using rule 10 (decl -> varDecl .)
    SIGNAL          reduce using rule 10 (decl -> varDecl .)
    (               reduce using rule 10 (decl -> varDecl .)
    ADD             reduce using rule 10 (decl -> varDecl .)
    SUB             reduce using rule 10 (decl -> varDecl .)
    NOT             reduce using rule 10 (decl -> varDecl .)
    NOTL            reduce using rule 10 (decl -> varDecl .)
    INTEGER_CONST   reduce using rule 10 (decl -> varDecl .)
    FLOAT_CONST     reduce using rule 10 (decl -> varDecl .)
    }               reduce using rule 10 (decl -> varDecl .)


state 9

    (11) decl -> cirDecl .

    MODULE          reduce using rule 11 (decl -> cirDecl .)
    BUNDLE          reduce using rule 11 (decl -> cirDecl .)
    CONST           reduce using rule 11 (decl -> cirDecl .)
    ID              reduce using rule 11 (decl -> cirDecl .)
    INT             reduce using rule 11 (decl -> cirDecl .)
    FLOAT           reduce using rule 11 (decl -> cirDecl .)
    REG             reduce using rule 11 (decl -> cirDecl .)
    WIRE            reduce using rule 11 (decl -> cirDecl .)
    CLOCK           reduce using rule 11 (decl -> cirDecl .)
    $end            reduce using rule 11 (decl -> cirDecl .)
    ;               reduce using rule 11 (decl -> cirDecl .)
    RETURN          reduce using rule 11 (decl -> cirDecl .)
    {               reduce using rule 11 (decl -> cirDecl .)
    MUX             reduce using rule 11 (decl -> cirDecl .)
    WHEN            reduce using rule 11 (decl -> cirDecl .)
    IF              reduce using rule 11 (decl -> cirDecl .)
    FOR             reduce using rule 11 (decl -> cirDecl .)
    GENERATE        reduce using rule 11 (decl -> cirDecl .)
    SIGNAL          reduce using rule 11 (decl -> cirDecl .)
    (               reduce using rule 11 (decl -> cirDecl .)
    ADD             reduce using rule 11 (decl -> cirDecl .)
    SUB             reduce using rule 11 (decl -> cirDecl .)
    NOT             reduce using rule 11 (decl -> cirDecl .)
    NOTL            reduce using rule 11 (decl -> cirDecl .)
    INTEGER_CONST   reduce using rule 11 (decl -> cirDecl .)
    FLOAT_CONST     reduce using rule 11 (decl -> cirDecl .)
    }               reduce using rule 11 (decl -> cirDecl .)


state 10

    (12) decl -> modDecl .

    MODULE          reduce using rule 12 (decl -> modDecl .)
    BUNDLE          reduce using rule 12 (decl -> modDecl .)
    CONST           reduce using rule 12 (decl -> modDecl .)
    ID              reduce using rule 12 (decl -> modDecl .)
    INT             reduce using rule 12 (decl -> modDecl .)
    FLOAT           reduce using rule 12 (decl -> modDecl .)
    REG             reduce using rule 12 (decl -> modDecl .)
    WIRE            reduce using rule 12 (decl -> modDecl .)
    CLOCK           reduce using rule 12 (decl -> modDecl .)
    $end            reduce using rule 12 (decl -> modDecl .)
    ;               reduce using rule 12 (decl -> modDecl .)
    RETURN          reduce using rule 12 (decl -> modDecl .)
    {               reduce using rule 12 (decl -> modDecl .)
    MUX             reduce using rule 12 (decl -> modDecl .)
    WHEN            reduce using rule 12 (decl -> modDecl .)
    IF              reduce using rule 12 (decl -> modDecl .)
    FOR             reduce using rule 12 (decl -> modDecl .)
    GENERATE        reduce using rule 12 (decl -> modDecl .)
    SIGNAL          reduce using rule 12 (decl -> modDecl .)
    (               reduce using rule 12 (decl -> modDecl .)
    ADD             reduce using rule 12 (decl -> modDecl .)
    SUB             reduce using rule 12 (decl -> modDecl .)
    NOT             reduce using rule 12 (decl -> modDecl .)
    NOTL            reduce using rule 12 (decl -> modDecl .)
    INTEGER_CONST   reduce using rule 12 (decl -> modDecl .)
    FLOAT_CONST     reduce using rule 12 (decl -> modDecl .)
    }               reduce using rule 12 (decl -> modDecl .)


state 11

    (13) decl -> bundleDecl .

    MODULE          reduce using rule 13 (decl -> bundleDecl .)
    BUNDLE          reduce using rule 13 (decl -> bundleDecl .)
    CONST           reduce using rule 13 (decl -> bundleDecl .)
    ID              reduce using rule 13 (decl -> bundleDecl .)
    INT             reduce using rule 13 (decl -> bundleDecl .)
    FLOAT           reduce using rule 13 (decl -> bundleDecl .)
    REG             reduce using rule 13 (decl -> bundleDecl .)
    WIRE            reduce using rule 13 (decl -> bundleDecl .)
    CLOCK           reduce using rule 13 (decl -> bundleDecl .)
    $end            reduce using rule 13 (decl -> bundleDecl .)
    ;               reduce using rule 13 (decl -> bundleDecl .)
    RETURN          reduce using rule 13 (decl -> bundleDecl .)
    {               reduce using rule 13 (decl -> bundleDecl .)
    MUX             reduce using rule 13 (decl -> bundleDecl .)
    WHEN            reduce using rule 13 (decl -> bundleDecl .)
    IF              reduce using rule 13 (decl -> bundleDecl .)
    FOR             reduce using rule 13 (decl -> bundleDecl .)
    GENERATE        reduce using rule 13 (decl -> bundleDecl .)
    SIGNAL          reduce using rule 13 (decl -> bundleDecl .)
    (               reduce using rule 13 (decl -> bundleDecl .)
    ADD             reduce using rule 13 (decl -> bundleDecl .)
    SUB             reduce using rule 13 (decl -> bundleDecl .)
    NOT             reduce using rule 13 (decl -> bundleDecl .)
    NOTL            reduce using rule 13 (decl -> bundleDecl .)
    INTEGER_CONST   reduce using rule 13 (decl -> bundleDecl .)
    FLOAT_CONST     reduce using rule 13 (decl -> bundleDecl .)
    }               reduce using rule 13 (decl -> bundleDecl .)


state 12

    (60) cir_function -> cir_type . ID ( cir_funcFParams ) block
    (57) cirDecl -> cir_type . cirDef cirDecl_repeat ;
    (58) cirDef -> . ID array
    (59) cirDef -> . ID array ASSIGN initVal

    ID              shift and go to state 31

    cirDef                         shift and go to state 32

state 13

    (39) modDecl -> ID . ( module_R_params ) ID array ;
    (49) bundleDecl -> ID . bundleDef bundleDecl_repeat
    (20) cir_basic_type -> ID .
    (50) bundleDef -> . ID array

  ! shift/reduce conflict for ID resolved as shift
    (               shift and go to state 34
    [               reduce using rule 20 (cir_basic_type -> ID .)
    ID              shift and go to state 33

  ! ID              [ reduce using rule 20 (cir_basic_type -> ID .) ]

    bundleDef                      shift and go to state 35

state 14

    (61) function -> val_type . ID ( funcFParams ) block
    (36) varDecl -> val_type . varDef varDef_repeat ;
    (37) varDef -> . ID array
    (38) varDef -> . ID array ASSIGN initVal

    ID              shift and go to state 36

    varDef                         shift and go to state 37

state 15

    (75) module -> MODULE . ID ( module_para_para port_def ID p_module_para_port ) block

    ID              shift and go to state 38


state 16

    (78) bundle -> BUNDLE . ID ( cir_type ID bundle_repeat )

    ID              shift and go to state 39


state 17

    (16) constDecl -> CONST . val_type constDef constDecl_repeat ;
    (23) val_type -> . INT
    (24) val_type -> . FLOAT

    INT             shift and go to state 19
    FLOAT           shift and go to state 20

    val_type                       shift and go to state 40

state 18

    (21) cir_type -> cir_basic_type .
    (22) cir_type -> cir_basic_type . [ exp ]

    ID              reduce using rule 21 (cir_type -> cir_basic_type .)
    [               shift and go to state 41


state 19

    (23) val_type -> INT .

    ID              reduce using rule 23 (val_type -> INT .)


state 20

    (24) val_type -> FLOAT .

    ID              reduce using rule 24 (val_type -> FLOAT .)


state 21

    (17) cir_basic_type -> REG .

    [               reduce using rule 17 (cir_basic_type -> REG .)
    ID              reduce using rule 17 (cir_basic_type -> REG .)


state 22

    (18) cir_basic_type -> WIRE .

    [               reduce using rule 18 (cir_basic_type -> WIRE .)
    ID              reduce using rule 18 (cir_basic_type -> WIRE .)


state 23

    (19) cir_basic_type -> CLOCK .

    [               reduce using rule 19 (cir_basic_type -> CLOCK .)
    ID              reduce using rule 19 (cir_basic_type -> CLOCK .)


state 24

    (4) compUnit -> decl compUnit_repeat .

    $end            reduce using rule 4 (compUnit -> decl compUnit_repeat .)
    MODULE          reduce using rule 4 (compUnit -> decl compUnit_repeat .)
    BUNDLE          reduce using rule 4 (compUnit -> decl compUnit_repeat .)
    CONST           reduce using rule 4 (compUnit -> decl compUnit_repeat .)
    ID              reduce using rule 4 (compUnit -> decl compUnit_repeat .)
    INT             reduce using rule 4 (compUnit -> decl compUnit_repeat .)
    FLOAT           reduce using rule 4 (compUnit -> decl compUnit_repeat .)
    REG             reduce using rule 4 (compUnit -> decl compUnit_repeat .)
    WIRE            reduce using rule 4 (compUnit -> decl compUnit_repeat .)
    CLOCK           reduce using rule 4 (compUnit -> decl compUnit_repeat .)


state 25

    (2) compUnit_repeat -> empty .

    $end            reduce using rule 2 (compUnit_repeat -> empty .)
    MODULE          reduce using rule 2 (compUnit_repeat -> empty .)
    BUNDLE          reduce using rule 2 (compUnit_repeat -> empty .)
    CONST           reduce using rule 2 (compUnit_repeat -> empty .)
    ID              reduce using rule 2 (compUnit_repeat -> empty .)
    INT             reduce using rule 2 (compUnit_repeat -> empty .)
    FLOAT           reduce using rule 2 (compUnit_repeat -> empty .)
    REG             reduce using rule 2 (compUnit_repeat -> empty .)
    WIRE            reduce using rule 2 (compUnit_repeat -> empty .)
    CLOCK           reduce using rule 2 (compUnit_repeat -> empty .)


state 26

    (3) compUnit_repeat -> compUnit . compUnit_repeat
    (2) compUnit_repeat -> . empty
    (3) compUnit_repeat -> . compUnit compUnit_repeat
    (1) empty -> .
    (4) compUnit -> . decl compUnit_repeat
    (5) compUnit -> . cir_function compUnit_repeat
    (6) compUnit -> . function compUnit_repeat
    (7) compUnit -> . module compUnit_repeat
    (8) compUnit -> . bundle compUnit_repeat
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (60) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (61) function -> . val_type ID ( funcFParams ) block
    (75) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port ) block
    (78) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    $end            reduce using rule 1 (empty -> .)
    MODULE          shift and go to state 15
    BUNDLE          shift and go to state 16
    CONST           shift and go to state 17
    ID              shift and go to state 13
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23

  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]

    compUnit                       shift and go to state 26
    compUnit_repeat                shift and go to state 42
    empty                          shift and go to state 25
    decl                           shift and go to state 2
    cir_function                   shift and go to state 3
    function                       shift and go to state 4
    module                         shift and go to state 5
    bundle                         shift and go to state 6
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    cir_type                       shift and go to state 12
    val_type                       shift and go to state 14
    cir_basic_type                 shift and go to state 18

state 27

    (5) compUnit -> cir_function compUnit_repeat .

    $end            reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)
    MODULE          reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)
    BUNDLE          reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)
    CONST           reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)
    ID              reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)
    INT             reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)
    FLOAT           reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)
    REG             reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)
    WIRE            reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)
    CLOCK           reduce using rule 5 (compUnit -> cir_function compUnit_repeat .)


state 28

    (6) compUnit -> function compUnit_repeat .

    $end            reduce using rule 6 (compUnit -> function compUnit_repeat .)
    MODULE          reduce using rule 6 (compUnit -> function compUnit_repeat .)
    BUNDLE          reduce using rule 6 (compUnit -> function compUnit_repeat .)
    CONST           reduce using rule 6 (compUnit -> function compUnit_repeat .)
    ID              reduce using rule 6 (compUnit -> function compUnit_repeat .)
    INT             reduce using rule 6 (compUnit -> function compUnit_repeat .)
    FLOAT           reduce using rule 6 (compUnit -> function compUnit_repeat .)
    REG             reduce using rule 6 (compUnit -> function compUnit_repeat .)
    WIRE            reduce using rule 6 (compUnit -> function compUnit_repeat .)
    CLOCK           reduce using rule 6 (compUnit -> function compUnit_repeat .)


state 29

    (7) compUnit -> module compUnit_repeat .

    $end            reduce using rule 7 (compUnit -> module compUnit_repeat .)
    MODULE          reduce using rule 7 (compUnit -> module compUnit_repeat .)
    BUNDLE          reduce using rule 7 (compUnit -> module compUnit_repeat .)
    CONST           reduce using rule 7 (compUnit -> module compUnit_repeat .)
    ID              reduce using rule 7 (compUnit -> module compUnit_repeat .)
    INT             reduce using rule 7 (compUnit -> module compUnit_repeat .)
    FLOAT           reduce using rule 7 (compUnit -> module compUnit_repeat .)
    REG             reduce using rule 7 (compUnit -> module compUnit_repeat .)
    WIRE            reduce using rule 7 (compUnit -> module compUnit_repeat .)
    CLOCK           reduce using rule 7 (compUnit -> module compUnit_repeat .)


state 30

    (8) compUnit -> bundle compUnit_repeat .

    $end            reduce using rule 8 (compUnit -> bundle compUnit_repeat .)
    MODULE          reduce using rule 8 (compUnit -> bundle compUnit_repeat .)
    BUNDLE          reduce using rule 8 (compUnit -> bundle compUnit_repeat .)
    CONST           reduce using rule 8 (compUnit -> bundle compUnit_repeat .)
    ID              reduce using rule 8 (compUnit -> bundle compUnit_repeat .)
    INT             reduce using rule 8 (compUnit -> bundle compUnit_repeat .)
    FLOAT           reduce using rule 8 (compUnit -> bundle compUnit_repeat .)
    REG             reduce using rule 8 (compUnit -> bundle compUnit_repeat .)
    WIRE            reduce using rule 8 (compUnit -> bundle compUnit_repeat .)
    CLOCK           reduce using rule 8 (compUnit -> bundle compUnit_repeat .)


state 31

    (60) cir_function -> cir_type ID . ( cir_funcFParams ) block
    (58) cirDef -> ID . array
    (59) cirDef -> ID . array ASSIGN initVal
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    (               shift and go to state 43
    [               shift and go to state 46
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)

    array                          shift and go to state 44
    empty                          shift and go to state 45

state 32

    (57) cirDecl -> cir_type cirDef . cirDecl_repeat ;
    (55) cirDecl_repeat -> . empty
    (56) cirDecl_repeat -> . , cirDef cirDecl_repeat
    (1) empty -> .

    ,               shift and go to state 49
    ;               reduce using rule 1 (empty -> .)

    cirDecl_repeat                 shift and go to state 47
    empty                          shift and go to state 48

state 33

    (50) bundleDef -> ID . array
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 46
    ,               reduce using rule 1 (empty -> .)
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    array                          shift and go to state 50
    empty                          shift and go to state 45

state 34

    (39) modDecl -> ID ( . module_R_params ) ID array ;
    (46) module_R_params -> . p_module_R_params_item module_R_params_repeat
    (43) p_module_R_params_item -> . R_port_def ID ( ID )
    (40) R_port_def -> . IN .
    (41) R_port_def -> . OUT .
    (42) R_port_def -> . INOUT .

    IN              shift and go to state 54
    OUT             shift and go to state 55
    INOUT           shift and go to state 56

    module_R_params                shift and go to state 51
    p_module_R_params_item         shift and go to state 52
    R_port_def                     shift and go to state 53

state 35

    (49) bundleDecl -> ID bundleDef . bundleDecl_repeat
    (47) bundleDecl_repeat -> . empty
    (48) bundleDecl_repeat -> . , bundleDef bundleDecl_repeat
    (1) empty -> .

    ,               shift and go to state 59
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    bundleDecl_repeat              shift and go to state 57
    empty                          shift and go to state 58

state 36

    (61) function -> val_type ID . ( funcFParams ) block
    (37) varDef -> ID . array
    (38) varDef -> ID . array ASSIGN initVal
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    (               shift and go to state 60
    [               shift and go to state 46
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)

    array                          shift and go to state 61
    empty                          shift and go to state 45

state 37

    (36) varDecl -> val_type varDef . varDef_repeat ;
    (34) varDef_repeat -> . empty
    (35) varDef_repeat -> . , varDef varDef_repeat
    (1) empty -> .

    ,               shift and go to state 64
    ;               reduce using rule 1 (empty -> .)

    varDef_repeat                  shift and go to state 62
    empty                          shift and go to state 63

state 38

    (75) module -> MODULE ID . ( module_para_para port_def ID p_module_para_port ) block

    (               shift and go to state 65


state 39

    (78) bundle -> BUNDLE ID . ( cir_type ID bundle_repeat )

    (               shift and go to state 66


state 40

    (16) constDecl -> CONST val_type . constDef constDecl_repeat ;
    (29) constDef -> . ID array ASSIGN constInitVal

    ID              shift and go to state 68

    constDef                       shift and go to state 67

state 41

    (22) cir_type -> cir_basic_type [ . exp ]
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 69
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 42

    (3) compUnit_repeat -> compUnit compUnit_repeat .

    $end            reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)
    MODULE          reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)
    BUNDLE          reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)
    CONST           reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)
    ID              reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)
    INT             reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)
    FLOAT           reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)
    REG             reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)
    WIRE            reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)
    CLOCK           reduce using rule 3 (compUnit_repeat -> compUnit compUnit_repeat .)


state 43

    (60) cir_function -> cir_type ID ( . cir_funcFParams ) block
    (64) cir_funcFParams -> . cir_funcFParam cir_funcFParams_repeat
    (68) cir_funcFParam -> . type_def ID array
    (25) type_def -> . val_type
    (26) type_def -> . cir_type
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    ID              shift and go to state 96

    cir_type                       shift and go to state 95
    cir_funcFParams                shift and go to state 97
    cir_funcFParam                 shift and go to state 98
    type_def                       shift and go to state 99
    val_type                       shift and go to state 100
    cir_basic_type                 shift and go to state 18

state 44

    (58) cirDef -> ID array .
    (59) cirDef -> ID array . ASSIGN initVal

    ,               reduce using rule 58 (cirDef -> ID array .)
    ;               reduce using rule 58 (cirDef -> ID array .)
    ASSIGN          shift and go to state 101


state 45

    (27) array -> empty .

    ASSIGN          reduce using rule 27 (array -> empty .)
    ,               reduce using rule 27 (array -> empty .)
    ;               reduce using rule 27 (array -> empty .)
    MODULE          reduce using rule 27 (array -> empty .)
    BUNDLE          reduce using rule 27 (array -> empty .)
    CONST           reduce using rule 27 (array -> empty .)
    ID              reduce using rule 27 (array -> empty .)
    INT             reduce using rule 27 (array -> empty .)
    FLOAT           reduce using rule 27 (array -> empty .)
    REG             reduce using rule 27 (array -> empty .)
    WIRE            reduce using rule 27 (array -> empty .)
    CLOCK           reduce using rule 27 (array -> empty .)
    $end            reduce using rule 27 (array -> empty .)
    RETURN          reduce using rule 27 (array -> empty .)
    {               reduce using rule 27 (array -> empty .)
    MUX             reduce using rule 27 (array -> empty .)
    WHEN            reduce using rule 27 (array -> empty .)
    IF              reduce using rule 27 (array -> empty .)
    FOR             reduce using rule 27 (array -> empty .)
    GENERATE        reduce using rule 27 (array -> empty .)
    SIGNAL          reduce using rule 27 (array -> empty .)
    (               reduce using rule 27 (array -> empty .)
    ADD             reduce using rule 27 (array -> empty .)
    SUB             reduce using rule 27 (array -> empty .)
    NOT             reduce using rule 27 (array -> empty .)
    NOTL            reduce using rule 27 (array -> empty .)
    INTEGER_CONST   reduce using rule 27 (array -> empty .)
    FLOAT_CONST     reduce using rule 27 (array -> empty .)
    }               reduce using rule 27 (array -> empty .)
    )               reduce using rule 27 (array -> empty .)


state 46

    (28) array -> [ . constExp ] array
    (168) constExp -> . exp
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    constExp                       shift and go to state 102
    exp                            shift and go to state 103
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 47

    (57) cirDecl -> cir_type cirDef cirDecl_repeat . ;

    ;               shift and go to state 104


state 48

    (55) cirDecl_repeat -> empty .

    ;               reduce using rule 55 (cirDecl_repeat -> empty .)


state 49

    (56) cirDecl_repeat -> , . cirDef cirDecl_repeat
    (58) cirDef -> . ID array
    (59) cirDef -> . ID array ASSIGN initVal

    ID              shift and go to state 106

    cirDef                         shift and go to state 105

state 50

    (50) bundleDef -> ID array .

    ,               reduce using rule 50 (bundleDef -> ID array .)
    MODULE          reduce using rule 50 (bundleDef -> ID array .)
    BUNDLE          reduce using rule 50 (bundleDef -> ID array .)
    CONST           reduce using rule 50 (bundleDef -> ID array .)
    ID              reduce using rule 50 (bundleDef -> ID array .)
    INT             reduce using rule 50 (bundleDef -> ID array .)
    FLOAT           reduce using rule 50 (bundleDef -> ID array .)
    REG             reduce using rule 50 (bundleDef -> ID array .)
    WIRE            reduce using rule 50 (bundleDef -> ID array .)
    CLOCK           reduce using rule 50 (bundleDef -> ID array .)
    $end            reduce using rule 50 (bundleDef -> ID array .)
    ;               reduce using rule 50 (bundleDef -> ID array .)
    RETURN          reduce using rule 50 (bundleDef -> ID array .)
    {               reduce using rule 50 (bundleDef -> ID array .)
    MUX             reduce using rule 50 (bundleDef -> ID array .)
    WHEN            reduce using rule 50 (bundleDef -> ID array .)
    IF              reduce using rule 50 (bundleDef -> ID array .)
    FOR             reduce using rule 50 (bundleDef -> ID array .)
    GENERATE        reduce using rule 50 (bundleDef -> ID array .)
    SIGNAL          reduce using rule 50 (bundleDef -> ID array .)
    (               reduce using rule 50 (bundleDef -> ID array .)
    ADD             reduce using rule 50 (bundleDef -> ID array .)
    SUB             reduce using rule 50 (bundleDef -> ID array .)
    NOT             reduce using rule 50 (bundleDef -> ID array .)
    NOTL            reduce using rule 50 (bundleDef -> ID array .)
    INTEGER_CONST   reduce using rule 50 (bundleDef -> ID array .)
    FLOAT_CONST     reduce using rule 50 (bundleDef -> ID array .)
    }               reduce using rule 50 (bundleDef -> ID array .)


state 51

    (39) modDecl -> ID ( module_R_params . ) ID array ;

    )               shift and go to state 107


state 52

    (46) module_R_params -> p_module_R_params_item . module_R_params_repeat
    (44) module_R_params_repeat -> . empty
    (45) module_R_params_repeat -> . , p_module_R_params_item module_R_params_repeat
    (1) empty -> .

    ,               shift and go to state 110
    )               reduce using rule 1 (empty -> .)

    module_R_params_repeat         shift and go to state 108
    empty                          shift and go to state 109

state 53

    (43) p_module_R_params_item -> R_port_def . ID ( ID )

    ID              shift and go to state 111


state 54

    (40) R_port_def -> IN . .

    .               shift and go to state 112


state 55

    (41) R_port_def -> OUT . .

    .               shift and go to state 113


state 56

    (42) R_port_def -> INOUT . .

    .               shift and go to state 114


state 57

    (49) bundleDecl -> ID bundleDef bundleDecl_repeat .

    MODULE          reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    BUNDLE          reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    CONST           reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    ID              reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    INT             reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    FLOAT           reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    REG             reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    WIRE            reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    CLOCK           reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    $end            reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    ;               reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    RETURN          reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    {               reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    MUX             reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    WHEN            reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    IF              reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    FOR             reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    GENERATE        reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    SIGNAL          reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    (               reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    ADD             reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    SUB             reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    NOT             reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    NOTL            reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    INTEGER_CONST   reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    FLOAT_CONST     reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    }               reduce using rule 49 (bundleDecl -> ID bundleDef bundleDecl_repeat .)


state 58

    (47) bundleDecl_repeat -> empty .

    MODULE          reduce using rule 47 (bundleDecl_repeat -> empty .)
    BUNDLE          reduce using rule 47 (bundleDecl_repeat -> empty .)
    CONST           reduce using rule 47 (bundleDecl_repeat -> empty .)
    ID              reduce using rule 47 (bundleDecl_repeat -> empty .)
    INT             reduce using rule 47 (bundleDecl_repeat -> empty .)
    FLOAT           reduce using rule 47 (bundleDecl_repeat -> empty .)
    REG             reduce using rule 47 (bundleDecl_repeat -> empty .)
    WIRE            reduce using rule 47 (bundleDecl_repeat -> empty .)
    CLOCK           reduce using rule 47 (bundleDecl_repeat -> empty .)
    $end            reduce using rule 47 (bundleDecl_repeat -> empty .)
    ;               reduce using rule 47 (bundleDecl_repeat -> empty .)
    RETURN          reduce using rule 47 (bundleDecl_repeat -> empty .)
    {               reduce using rule 47 (bundleDecl_repeat -> empty .)
    MUX             reduce using rule 47 (bundleDecl_repeat -> empty .)
    WHEN            reduce using rule 47 (bundleDecl_repeat -> empty .)
    IF              reduce using rule 47 (bundleDecl_repeat -> empty .)
    FOR             reduce using rule 47 (bundleDecl_repeat -> empty .)
    GENERATE        reduce using rule 47 (bundleDecl_repeat -> empty .)
    SIGNAL          reduce using rule 47 (bundleDecl_repeat -> empty .)
    (               reduce using rule 47 (bundleDecl_repeat -> empty .)
    ADD             reduce using rule 47 (bundleDecl_repeat -> empty .)
    SUB             reduce using rule 47 (bundleDecl_repeat -> empty .)
    NOT             reduce using rule 47 (bundleDecl_repeat -> empty .)
    NOTL            reduce using rule 47 (bundleDecl_repeat -> empty .)
    INTEGER_CONST   reduce using rule 47 (bundleDecl_repeat -> empty .)
    FLOAT_CONST     reduce using rule 47 (bundleDecl_repeat -> empty .)
    }               reduce using rule 47 (bundleDecl_repeat -> empty .)


state 59

    (48) bundleDecl_repeat -> , . bundleDef bundleDecl_repeat
    (50) bundleDef -> . ID array

    ID              shift and go to state 33

    bundleDef                      shift and go to state 115

state 60

    (61) function -> val_type ID ( . funcFParams ) block
    (67) funcFParams -> . funcFParam funcFParams_repeat
    (69) funcFParam -> . val_type ID array
    (23) val_type -> . INT
    (24) val_type -> . FLOAT

    INT             shift and go to state 19
    FLOAT           shift and go to state 20

    val_type                       shift and go to state 116
    funcFParams                    shift and go to state 117
    funcFParam                     shift and go to state 118

state 61

    (37) varDef -> ID array .
    (38) varDef -> ID array . ASSIGN initVal

    ,               reduce using rule 37 (varDef -> ID array .)
    ;               reduce using rule 37 (varDef -> ID array .)
    ASSIGN          shift and go to state 119


state 62

    (36) varDecl -> val_type varDef varDef_repeat . ;

    ;               shift and go to state 120


state 63

    (34) varDef_repeat -> empty .

    ;               reduce using rule 34 (varDef_repeat -> empty .)


state 64

    (35) varDef_repeat -> , . varDef varDef_repeat
    (37) varDef -> . ID array
    (38) varDef -> . ID array ASSIGN initVal

    ID              shift and go to state 122

    varDef                         shift and go to state 121

state 65

    (75) module -> MODULE ID ( . module_para_para port_def ID p_module_para_port ) block
    (70) module_para_para -> . empty
    (71) module_para_para -> . PARA val_type ID ,
    (72) module_para_para -> . PARA val_type ID , module_para_para
    (1) empty -> .

    PARA            shift and go to state 125
    INPUT           reduce using rule 1 (empty -> .)
    OUTPUT          reduce using rule 1 (empty -> .)
    INOUT           reduce using rule 1 (empty -> .)

    module_para_para               shift and go to state 123
    empty                          shift and go to state 124

state 66

    (78) bundle -> BUNDLE ID ( . cir_type ID bundle_repeat )
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    ID              shift and go to state 96

    cir_type                       shift and go to state 126
    cir_basic_type                 shift and go to state 18

state 67

    (16) constDecl -> CONST val_type constDef . constDecl_repeat ;
    (14) constDecl_repeat -> . empty
    (15) constDecl_repeat -> . , constDef constDecl_repeat
    (1) empty -> .

    ,               shift and go to state 129
    ;               reduce using rule 1 (empty -> .)

    constDecl_repeat               shift and go to state 127
    empty                          shift and go to state 128

state 68

    (29) constDef -> ID . array ASSIGN constInitVal
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 46
    ASSIGN          reduce using rule 1 (empty -> .)

    array                          shift and go to state 130
    empty                          shift and go to state 45

state 69

    (22) cir_type -> cir_basic_type [ exp . ]
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               shift and go to state 131
    BIT_WIDTH_NUMBER shift and go to state 132


state 70

    (103) exp -> lOrExp .
    (164) lOrExp -> lOrExp . LOR lAndExp

    ]               reduce using rule 103 (exp -> lOrExp .)
    BIT_WIDTH_NUMBER reduce using rule 103 (exp -> lOrExp .)
    )               reduce using rule 103 (exp -> lOrExp .)
    ,               reduce using rule 103 (exp -> lOrExp .)
    ;               reduce using rule 103 (exp -> lOrExp .)
    COLON           reduce using rule 103 (exp -> lOrExp .)
    }               reduce using rule 103 (exp -> lOrExp .)
    RETURN          reduce using rule 103 (exp -> lOrExp .)
    CONST           reduce using rule 103 (exp -> lOrExp .)
    ID              reduce using rule 103 (exp -> lOrExp .)
    {               reduce using rule 103 (exp -> lOrExp .)
    MUX             reduce using rule 103 (exp -> lOrExp .)
    WHEN            reduce using rule 103 (exp -> lOrExp .)
    IF              reduce using rule 103 (exp -> lOrExp .)
    FOR             reduce using rule 103 (exp -> lOrExp .)
    GENERATE        reduce using rule 103 (exp -> lOrExp .)
    INT             reduce using rule 103 (exp -> lOrExp .)
    FLOAT           reduce using rule 103 (exp -> lOrExp .)
    REG             reduce using rule 103 (exp -> lOrExp .)
    WIRE            reduce using rule 103 (exp -> lOrExp .)
    CLOCK           reduce using rule 103 (exp -> lOrExp .)
    SIGNAL          reduce using rule 103 (exp -> lOrExp .)
    (               reduce using rule 103 (exp -> lOrExp .)
    ADD             reduce using rule 103 (exp -> lOrExp .)
    SUB             reduce using rule 103 (exp -> lOrExp .)
    NOT             reduce using rule 103 (exp -> lOrExp .)
    NOTL            reduce using rule 103 (exp -> lOrExp .)
    INTEGER_CONST   reduce using rule 103 (exp -> lOrExp .)
    FLOAT_CONST     reduce using rule 103 (exp -> lOrExp .)
    ELIF            reduce using rule 103 (exp -> lOrExp .)
    ELSE            reduce using rule 103 (exp -> lOrExp .)
    LOR             shift and go to state 133


state 71

    (163) lOrExp -> lAndExp .
    (162) lAndExp -> lAndExp . LAND redExp

    LOR             reduce using rule 163 (lOrExp -> lAndExp .)
    ]               reduce using rule 163 (lOrExp -> lAndExp .)
    BIT_WIDTH_NUMBER reduce using rule 163 (lOrExp -> lAndExp .)
    )               reduce using rule 163 (lOrExp -> lAndExp .)
    ,               reduce using rule 163 (lOrExp -> lAndExp .)
    ;               reduce using rule 163 (lOrExp -> lAndExp .)
    COLON           reduce using rule 163 (lOrExp -> lAndExp .)
    }               reduce using rule 163 (lOrExp -> lAndExp .)
    RETURN          reduce using rule 163 (lOrExp -> lAndExp .)
    CONST           reduce using rule 163 (lOrExp -> lAndExp .)
    ID              reduce using rule 163 (lOrExp -> lAndExp .)
    {               reduce using rule 163 (lOrExp -> lAndExp .)
    MUX             reduce using rule 163 (lOrExp -> lAndExp .)
    WHEN            reduce using rule 163 (lOrExp -> lAndExp .)
    IF              reduce using rule 163 (lOrExp -> lAndExp .)
    FOR             reduce using rule 163 (lOrExp -> lAndExp .)
    GENERATE        reduce using rule 163 (lOrExp -> lAndExp .)
    INT             reduce using rule 163 (lOrExp -> lAndExp .)
    FLOAT           reduce using rule 163 (lOrExp -> lAndExp .)
    REG             reduce using rule 163 (lOrExp -> lAndExp .)
    WIRE            reduce using rule 163 (lOrExp -> lAndExp .)
    CLOCK           reduce using rule 163 (lOrExp -> lAndExp .)
    SIGNAL          reduce using rule 163 (lOrExp -> lAndExp .)
    (               reduce using rule 163 (lOrExp -> lAndExp .)
    ADD             reduce using rule 163 (lOrExp -> lAndExp .)
    SUB             reduce using rule 163 (lOrExp -> lAndExp .)
    NOT             reduce using rule 163 (lOrExp -> lAndExp .)
    NOTL            reduce using rule 163 (lOrExp -> lAndExp .)
    INTEGER_CONST   reduce using rule 163 (lOrExp -> lAndExp .)
    FLOAT_CONST     reduce using rule 163 (lOrExp -> lAndExp .)
    ELIF            reduce using rule 163 (lOrExp -> lAndExp .)
    ELSE            reduce using rule 163 (lOrExp -> lAndExp .)
    LAND            shift and go to state 134


state 72

    (161) lAndExp -> redExp .
    (157) redExp -> redExp . AND eqExp
    (158) redExp -> redExp . OR eqExp
    (159) redExp -> redExp . XOR eqExp
    (160) redExp -> redExp . XNOR eqExp

    LAND            reduce using rule 161 (lAndExp -> redExp .)
    LOR             reduce using rule 161 (lAndExp -> redExp .)
    ]               reduce using rule 161 (lAndExp -> redExp .)
    BIT_WIDTH_NUMBER reduce using rule 161 (lAndExp -> redExp .)
    )               reduce using rule 161 (lAndExp -> redExp .)
    ,               reduce using rule 161 (lAndExp -> redExp .)
    ;               reduce using rule 161 (lAndExp -> redExp .)
    COLON           reduce using rule 161 (lAndExp -> redExp .)
    }               reduce using rule 161 (lAndExp -> redExp .)
    RETURN          reduce using rule 161 (lAndExp -> redExp .)
    CONST           reduce using rule 161 (lAndExp -> redExp .)
    ID              reduce using rule 161 (lAndExp -> redExp .)
    {               reduce using rule 161 (lAndExp -> redExp .)
    MUX             reduce using rule 161 (lAndExp -> redExp .)
    WHEN            reduce using rule 161 (lAndExp -> redExp .)
    IF              reduce using rule 161 (lAndExp -> redExp .)
    FOR             reduce using rule 161 (lAndExp -> redExp .)
    GENERATE        reduce using rule 161 (lAndExp -> redExp .)
    INT             reduce using rule 161 (lAndExp -> redExp .)
    FLOAT           reduce using rule 161 (lAndExp -> redExp .)
    REG             reduce using rule 161 (lAndExp -> redExp .)
    WIRE            reduce using rule 161 (lAndExp -> redExp .)
    CLOCK           reduce using rule 161 (lAndExp -> redExp .)
    SIGNAL          reduce using rule 161 (lAndExp -> redExp .)
    (               reduce using rule 161 (lAndExp -> redExp .)
    ADD             reduce using rule 161 (lAndExp -> redExp .)
    SUB             reduce using rule 161 (lAndExp -> redExp .)
    NOT             reduce using rule 161 (lAndExp -> redExp .)
    NOTL            reduce using rule 161 (lAndExp -> redExp .)
    INTEGER_CONST   reduce using rule 161 (lAndExp -> redExp .)
    FLOAT_CONST     reduce using rule 161 (lAndExp -> redExp .)
    ELIF            reduce using rule 161 (lAndExp -> redExp .)
    ELSE            reduce using rule 161 (lAndExp -> redExp .)
    AND             shift and go to state 135
    OR              shift and go to state 136
    XOR             shift and go to state 137
    XNOR            shift and go to state 138


state 73

    (156) redExp -> eqExp .
    (154) eqExp -> eqExp . EQUAL eqExp
    (155) eqExp -> eqExp . NEQ eqExp

    AND             reduce using rule 156 (redExp -> eqExp .)
    OR              reduce using rule 156 (redExp -> eqExp .)
    XOR             reduce using rule 156 (redExp -> eqExp .)
    XNOR            reduce using rule 156 (redExp -> eqExp .)
    LAND            reduce using rule 156 (redExp -> eqExp .)
    LOR             reduce using rule 156 (redExp -> eqExp .)
    ]               reduce using rule 156 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 156 (redExp -> eqExp .)
    )               reduce using rule 156 (redExp -> eqExp .)
    ,               reduce using rule 156 (redExp -> eqExp .)
    ;               reduce using rule 156 (redExp -> eqExp .)
    COLON           reduce using rule 156 (redExp -> eqExp .)
    }               reduce using rule 156 (redExp -> eqExp .)
    RETURN          reduce using rule 156 (redExp -> eqExp .)
    CONST           reduce using rule 156 (redExp -> eqExp .)
    ID              reduce using rule 156 (redExp -> eqExp .)
    {               reduce using rule 156 (redExp -> eqExp .)
    MUX             reduce using rule 156 (redExp -> eqExp .)
    WHEN            reduce using rule 156 (redExp -> eqExp .)
    IF              reduce using rule 156 (redExp -> eqExp .)
    FOR             reduce using rule 156 (redExp -> eqExp .)
    GENERATE        reduce using rule 156 (redExp -> eqExp .)
    INT             reduce using rule 156 (redExp -> eqExp .)
    FLOAT           reduce using rule 156 (redExp -> eqExp .)
    REG             reduce using rule 156 (redExp -> eqExp .)
    WIRE            reduce using rule 156 (redExp -> eqExp .)
    CLOCK           reduce using rule 156 (redExp -> eqExp .)
    SIGNAL          reduce using rule 156 (redExp -> eqExp .)
    (               reduce using rule 156 (redExp -> eqExp .)
    ADD             reduce using rule 156 (redExp -> eqExp .)
    SUB             reduce using rule 156 (redExp -> eqExp .)
    NOT             reduce using rule 156 (redExp -> eqExp .)
    NOTL            reduce using rule 156 (redExp -> eqExp .)
    INTEGER_CONST   reduce using rule 156 (redExp -> eqExp .)
    FLOAT_CONST     reduce using rule 156 (redExp -> eqExp .)
    ELIF            reduce using rule 156 (redExp -> eqExp .)
    ELSE            reduce using rule 156 (redExp -> eqExp .)
    EQUAL           shift and go to state 139
    NEQ             shift and go to state 140


state 74

    (153) eqExp -> relExp .
    (149) relExp -> relExp . LT addExp
    (150) relExp -> relExp . GT addExp
    (151) relExp -> relExp . GE addExp
    (152) relExp -> relExp . LE addExp

    EQUAL           reduce using rule 153 (eqExp -> relExp .)
    NEQ             reduce using rule 153 (eqExp -> relExp .)
    AND             reduce using rule 153 (eqExp -> relExp .)
    OR              reduce using rule 153 (eqExp -> relExp .)
    XOR             reduce using rule 153 (eqExp -> relExp .)
    XNOR            reduce using rule 153 (eqExp -> relExp .)
    LAND            reduce using rule 153 (eqExp -> relExp .)
    LOR             reduce using rule 153 (eqExp -> relExp .)
    ]               reduce using rule 153 (eqExp -> relExp .)
    BIT_WIDTH_NUMBER reduce using rule 153 (eqExp -> relExp .)
    )               reduce using rule 153 (eqExp -> relExp .)
    ,               reduce using rule 153 (eqExp -> relExp .)
    ;               reduce using rule 153 (eqExp -> relExp .)
    COLON           reduce using rule 153 (eqExp -> relExp .)
    }               reduce using rule 153 (eqExp -> relExp .)
    RETURN          reduce using rule 153 (eqExp -> relExp .)
    CONST           reduce using rule 153 (eqExp -> relExp .)
    ID              reduce using rule 153 (eqExp -> relExp .)
    {               reduce using rule 153 (eqExp -> relExp .)
    MUX             reduce using rule 153 (eqExp -> relExp .)
    WHEN            reduce using rule 153 (eqExp -> relExp .)
    IF              reduce using rule 153 (eqExp -> relExp .)
    FOR             reduce using rule 153 (eqExp -> relExp .)
    GENERATE        reduce using rule 153 (eqExp -> relExp .)
    INT             reduce using rule 153 (eqExp -> relExp .)
    FLOAT           reduce using rule 153 (eqExp -> relExp .)
    REG             reduce using rule 153 (eqExp -> relExp .)
    WIRE            reduce using rule 153 (eqExp -> relExp .)
    CLOCK           reduce using rule 153 (eqExp -> relExp .)
    SIGNAL          reduce using rule 153 (eqExp -> relExp .)
    (               reduce using rule 153 (eqExp -> relExp .)
    ADD             reduce using rule 153 (eqExp -> relExp .)
    SUB             reduce using rule 153 (eqExp -> relExp .)
    NOT             reduce using rule 153 (eqExp -> relExp .)
    NOTL            reduce using rule 153 (eqExp -> relExp .)
    INTEGER_CONST   reduce using rule 153 (eqExp -> relExp .)
    FLOAT_CONST     reduce using rule 153 (eqExp -> relExp .)
    ELIF            reduce using rule 153 (eqExp -> relExp .)
    ELSE            reduce using rule 153 (eqExp -> relExp .)
    LT              shift and go to state 141
    GT              shift and go to state 142
    GE              shift and go to state 143
    LE              shift and go to state 144


state 75

    (148) relExp -> shiftExp .
    (145) shiftExp -> shiftExp . SLL addExp
    (146) shiftExp -> shiftExp . SRL addExp
    (147) shiftExp -> shiftExp . SRA addExp

    LT              reduce using rule 148 (relExp -> shiftExp .)
    GT              reduce using rule 148 (relExp -> shiftExp .)
    GE              reduce using rule 148 (relExp -> shiftExp .)
    LE              reduce using rule 148 (relExp -> shiftExp .)
    EQUAL           reduce using rule 148 (relExp -> shiftExp .)
    NEQ             reduce using rule 148 (relExp -> shiftExp .)
    AND             reduce using rule 148 (relExp -> shiftExp .)
    OR              reduce using rule 148 (relExp -> shiftExp .)
    XOR             reduce using rule 148 (relExp -> shiftExp .)
    XNOR            reduce using rule 148 (relExp -> shiftExp .)
    LAND            reduce using rule 148 (relExp -> shiftExp .)
    LOR             reduce using rule 148 (relExp -> shiftExp .)
    ]               reduce using rule 148 (relExp -> shiftExp .)
    BIT_WIDTH_NUMBER reduce using rule 148 (relExp -> shiftExp .)
    )               reduce using rule 148 (relExp -> shiftExp .)
    ,               reduce using rule 148 (relExp -> shiftExp .)
    ;               reduce using rule 148 (relExp -> shiftExp .)
    COLON           reduce using rule 148 (relExp -> shiftExp .)
    }               reduce using rule 148 (relExp -> shiftExp .)
    RETURN          reduce using rule 148 (relExp -> shiftExp .)
    CONST           reduce using rule 148 (relExp -> shiftExp .)
    ID              reduce using rule 148 (relExp -> shiftExp .)
    {               reduce using rule 148 (relExp -> shiftExp .)
    MUX             reduce using rule 148 (relExp -> shiftExp .)
    WHEN            reduce using rule 148 (relExp -> shiftExp .)
    IF              reduce using rule 148 (relExp -> shiftExp .)
    FOR             reduce using rule 148 (relExp -> shiftExp .)
    GENERATE        reduce using rule 148 (relExp -> shiftExp .)
    INT             reduce using rule 148 (relExp -> shiftExp .)
    FLOAT           reduce using rule 148 (relExp -> shiftExp .)
    REG             reduce using rule 148 (relExp -> shiftExp .)
    WIRE            reduce using rule 148 (relExp -> shiftExp .)
    CLOCK           reduce using rule 148 (relExp -> shiftExp .)
    SIGNAL          reduce using rule 148 (relExp -> shiftExp .)
    (               reduce using rule 148 (relExp -> shiftExp .)
    ADD             reduce using rule 148 (relExp -> shiftExp .)
    SUB             reduce using rule 148 (relExp -> shiftExp .)
    NOT             reduce using rule 148 (relExp -> shiftExp .)
    NOTL            reduce using rule 148 (relExp -> shiftExp .)
    INTEGER_CONST   reduce using rule 148 (relExp -> shiftExp .)
    FLOAT_CONST     reduce using rule 148 (relExp -> shiftExp .)
    ELIF            reduce using rule 148 (relExp -> shiftExp .)
    ELSE            reduce using rule 148 (relExp -> shiftExp .)
    SLL             shift and go to state 145
    SRL             shift and go to state 146
    SRA             shift and go to state 147


state 76

    (144) shiftExp -> addExp .
    (142) addExp -> addExp . ADD mulExp
    (143) addExp -> addExp . SUB mulExp

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
    SLL             reduce using rule 144 (shiftExp -> addExp .)
    SRL             reduce using rule 144 (shiftExp -> addExp .)
    SRA             reduce using rule 144 (shiftExp -> addExp .)
    LT              reduce using rule 144 (shiftExp -> addExp .)
    GT              reduce using rule 144 (shiftExp -> addExp .)
    GE              reduce using rule 144 (shiftExp -> addExp .)
    LE              reduce using rule 144 (shiftExp -> addExp .)
    EQUAL           reduce using rule 144 (shiftExp -> addExp .)
    NEQ             reduce using rule 144 (shiftExp -> addExp .)
    AND             reduce using rule 144 (shiftExp -> addExp .)
    OR              reduce using rule 144 (shiftExp -> addExp .)
    XOR             reduce using rule 144 (shiftExp -> addExp .)
    XNOR            reduce using rule 144 (shiftExp -> addExp .)
    LAND            reduce using rule 144 (shiftExp -> addExp .)
    LOR             reduce using rule 144 (shiftExp -> addExp .)
    ]               reduce using rule 144 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 144 (shiftExp -> addExp .)
    )               reduce using rule 144 (shiftExp -> addExp .)
    ,               reduce using rule 144 (shiftExp -> addExp .)
    ;               reduce using rule 144 (shiftExp -> addExp .)
    COLON           reduce using rule 144 (shiftExp -> addExp .)
    }               reduce using rule 144 (shiftExp -> addExp .)
    RETURN          reduce using rule 144 (shiftExp -> addExp .)
    CONST           reduce using rule 144 (shiftExp -> addExp .)
    ID              reduce using rule 144 (shiftExp -> addExp .)
    {               reduce using rule 144 (shiftExp -> addExp .)
    MUX             reduce using rule 144 (shiftExp -> addExp .)
    WHEN            reduce using rule 144 (shiftExp -> addExp .)
    IF              reduce using rule 144 (shiftExp -> addExp .)
    FOR             reduce using rule 144 (shiftExp -> addExp .)
    GENERATE        reduce using rule 144 (shiftExp -> addExp .)
    INT             reduce using rule 144 (shiftExp -> addExp .)
    FLOAT           reduce using rule 144 (shiftExp -> addExp .)
    REG             reduce using rule 144 (shiftExp -> addExp .)
    WIRE            reduce using rule 144 (shiftExp -> addExp .)
    CLOCK           reduce using rule 144 (shiftExp -> addExp .)
    SIGNAL          reduce using rule 144 (shiftExp -> addExp .)
    (               reduce using rule 144 (shiftExp -> addExp .)
    NOT             reduce using rule 144 (shiftExp -> addExp .)
    NOTL            reduce using rule 144 (shiftExp -> addExp .)
    INTEGER_CONST   reduce using rule 144 (shiftExp -> addExp .)
    FLOAT_CONST     reduce using rule 144 (shiftExp -> addExp .)
    ELIF            reduce using rule 144 (shiftExp -> addExp .)
    ELSE            reduce using rule 144 (shiftExp -> addExp .)
    ADD             shift and go to state 148
    SUB             shift and go to state 149

  ! ADD             [ reduce using rule 144 (shiftExp -> addExp .) ]
  ! SUB             [ reduce using rule 144 (shiftExp -> addExp .) ]


state 77

    (141) addExp -> mulExp .
    (137) mulExp -> mulExp . MUL unaryExp
    (138) mulExp -> mulExp . DIV unaryExp
    (139) mulExp -> mulExp . MOD unaryExp
    (140) mulExp -> mulExp . POWER unaryExp

    ADD             reduce using rule 141 (addExp -> mulExp .)
    SUB             reduce using rule 141 (addExp -> mulExp .)
    SLL             reduce using rule 141 (addExp -> mulExp .)
    SRL             reduce using rule 141 (addExp -> mulExp .)
    SRA             reduce using rule 141 (addExp -> mulExp .)
    LT              reduce using rule 141 (addExp -> mulExp .)
    GT              reduce using rule 141 (addExp -> mulExp .)
    GE              reduce using rule 141 (addExp -> mulExp .)
    LE              reduce using rule 141 (addExp -> mulExp .)
    EQUAL           reduce using rule 141 (addExp -> mulExp .)
    NEQ             reduce using rule 141 (addExp -> mulExp .)
    AND             reduce using rule 141 (addExp -> mulExp .)
    OR              reduce using rule 141 (addExp -> mulExp .)
    XOR             reduce using rule 141 (addExp -> mulExp .)
    XNOR            reduce using rule 141 (addExp -> mulExp .)
    LAND            reduce using rule 141 (addExp -> mulExp .)
    LOR             reduce using rule 141 (addExp -> mulExp .)
    ]               reduce using rule 141 (addExp -> mulExp .)
    BIT_WIDTH_NUMBER reduce using rule 141 (addExp -> mulExp .)
    )               reduce using rule 141 (addExp -> mulExp .)
    ,               reduce using rule 141 (addExp -> mulExp .)
    ;               reduce using rule 141 (addExp -> mulExp .)
    COLON           reduce using rule 141 (addExp -> mulExp .)
    }               reduce using rule 141 (addExp -> mulExp .)
    RETURN          reduce using rule 141 (addExp -> mulExp .)
    CONST           reduce using rule 141 (addExp -> mulExp .)
    ID              reduce using rule 141 (addExp -> mulExp .)
    {               reduce using rule 141 (addExp -> mulExp .)
    MUX             reduce using rule 141 (addExp -> mulExp .)
    WHEN            reduce using rule 141 (addExp -> mulExp .)
    IF              reduce using rule 141 (addExp -> mulExp .)
    FOR             reduce using rule 141 (addExp -> mulExp .)
    GENERATE        reduce using rule 141 (addExp -> mulExp .)
    INT             reduce using rule 141 (addExp -> mulExp .)
    FLOAT           reduce using rule 141 (addExp -> mulExp .)
    REG             reduce using rule 141 (addExp -> mulExp .)
    WIRE            reduce using rule 141 (addExp -> mulExp .)
    CLOCK           reduce using rule 141 (addExp -> mulExp .)
    SIGNAL          reduce using rule 141 (addExp -> mulExp .)
    (               reduce using rule 141 (addExp -> mulExp .)
    NOT             reduce using rule 141 (addExp -> mulExp .)
    NOTL            reduce using rule 141 (addExp -> mulExp .)
    INTEGER_CONST   reduce using rule 141 (addExp -> mulExp .)
    FLOAT_CONST     reduce using rule 141 (addExp -> mulExp .)
    ELIF            reduce using rule 141 (addExp -> mulExp .)
    ELSE            reduce using rule 141 (addExp -> mulExp .)
    MUL             shift and go to state 150
    DIV             shift and go to state 151
    MOD             shift and go to state 152
    POWER           shift and go to state 153


state 78

    (128) unaryOp -> ADD .

    ID              reduce using rule 128 (unaryOp -> ADD .)
    SIGNAL          reduce using rule 128 (unaryOp -> ADD .)
    (               reduce using rule 128 (unaryOp -> ADD .)
    ADD             reduce using rule 128 (unaryOp -> ADD .)
    SUB             reduce using rule 128 (unaryOp -> ADD .)
    NOT             reduce using rule 128 (unaryOp -> ADD .)
    NOTL            reduce using rule 128 (unaryOp -> ADD .)
    {               reduce using rule 128 (unaryOp -> ADD .)
    MUX             reduce using rule 128 (unaryOp -> ADD .)
    INTEGER_CONST   reduce using rule 128 (unaryOp -> ADD .)
    FLOAT_CONST     reduce using rule 128 (unaryOp -> ADD .)


state 79

    (129) unaryOp -> SUB .

    ID              reduce using rule 129 (unaryOp -> SUB .)
    SIGNAL          reduce using rule 129 (unaryOp -> SUB .)
    (               reduce using rule 129 (unaryOp -> SUB .)
    ADD             reduce using rule 129 (unaryOp -> SUB .)
    SUB             reduce using rule 129 (unaryOp -> SUB .)
    NOT             reduce using rule 129 (unaryOp -> SUB .)
    NOTL            reduce using rule 129 (unaryOp -> SUB .)
    {               reduce using rule 129 (unaryOp -> SUB .)
    MUX             reduce using rule 129 (unaryOp -> SUB .)
    INTEGER_CONST   reduce using rule 129 (unaryOp -> SUB .)
    FLOAT_CONST     reduce using rule 129 (unaryOp -> SUB .)


state 80

    (136) mulExp -> unaryExp .

    MUL             reduce using rule 136 (mulExp -> unaryExp .)
    DIV             reduce using rule 136 (mulExp -> unaryExp .)
    MOD             reduce using rule 136 (mulExp -> unaryExp .)
    POWER           reduce using rule 136 (mulExp -> unaryExp .)
    ADD             reduce using rule 136 (mulExp -> unaryExp .)
    SUB             reduce using rule 136 (mulExp -> unaryExp .)
    SLL             reduce using rule 136 (mulExp -> unaryExp .)
    SRL             reduce using rule 136 (mulExp -> unaryExp .)
    SRA             reduce using rule 136 (mulExp -> unaryExp .)
    LT              reduce using rule 136 (mulExp -> unaryExp .)
    GT              reduce using rule 136 (mulExp -> unaryExp .)
    GE              reduce using rule 136 (mulExp -> unaryExp .)
    LE              reduce using rule 136 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 136 (mulExp -> unaryExp .)
    NEQ             reduce using rule 136 (mulExp -> unaryExp .)
    AND             reduce using rule 136 (mulExp -> unaryExp .)
    OR              reduce using rule 136 (mulExp -> unaryExp .)
    XOR             reduce using rule 136 (mulExp -> unaryExp .)
    XNOR            reduce using rule 136 (mulExp -> unaryExp .)
    LAND            reduce using rule 136 (mulExp -> unaryExp .)
    LOR             reduce using rule 136 (mulExp -> unaryExp .)
    ]               reduce using rule 136 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 136 (mulExp -> unaryExp .)
    )               reduce using rule 136 (mulExp -> unaryExp .)
    ,               reduce using rule 136 (mulExp -> unaryExp .)
    ;               reduce using rule 136 (mulExp -> unaryExp .)
    COLON           reduce using rule 136 (mulExp -> unaryExp .)
    }               reduce using rule 136 (mulExp -> unaryExp .)
    RETURN          reduce using rule 136 (mulExp -> unaryExp .)
    CONST           reduce using rule 136 (mulExp -> unaryExp .)
    ID              reduce using rule 136 (mulExp -> unaryExp .)
    {               reduce using rule 136 (mulExp -> unaryExp .)
    MUX             reduce using rule 136 (mulExp -> unaryExp .)
    WHEN            reduce using rule 136 (mulExp -> unaryExp .)
    IF              reduce using rule 136 (mulExp -> unaryExp .)
    FOR             reduce using rule 136 (mulExp -> unaryExp .)
    GENERATE        reduce using rule 136 (mulExp -> unaryExp .)
    INT             reduce using rule 136 (mulExp -> unaryExp .)
    FLOAT           reduce using rule 136 (mulExp -> unaryExp .)
    REG             reduce using rule 136 (mulExp -> unaryExp .)
    WIRE            reduce using rule 136 (mulExp -> unaryExp .)
    CLOCK           reduce using rule 136 (mulExp -> unaryExp .)
    SIGNAL          reduce using rule 136 (mulExp -> unaryExp .)
    (               reduce using rule 136 (mulExp -> unaryExp .)
    NOT             reduce using rule 136 (mulExp -> unaryExp .)
    NOTL            reduce using rule 136 (mulExp -> unaryExp .)
    INTEGER_CONST   reduce using rule 136 (mulExp -> unaryExp .)
    FLOAT_CONST     reduce using rule 136 (mulExp -> unaryExp .)
    ELIF            reduce using rule 136 (mulExp -> unaryExp .)
    ELSE            reduce using rule 136 (mulExp -> unaryExp .)


state 81

    (123) unaryExp -> primaryExp .

    MUL             reduce using rule 123 (unaryExp -> primaryExp .)
    DIV             reduce using rule 123 (unaryExp -> primaryExp .)
    MOD             reduce using rule 123 (unaryExp -> primaryExp .)
    POWER           reduce using rule 123 (unaryExp -> primaryExp .)
    ADD             reduce using rule 123 (unaryExp -> primaryExp .)
    SUB             reduce using rule 123 (unaryExp -> primaryExp .)
    SLL             reduce using rule 123 (unaryExp -> primaryExp .)
    SRL             reduce using rule 123 (unaryExp -> primaryExp .)
    SRA             reduce using rule 123 (unaryExp -> primaryExp .)
    LT              reduce using rule 123 (unaryExp -> primaryExp .)
    GT              reduce using rule 123 (unaryExp -> primaryExp .)
    GE              reduce using rule 123 (unaryExp -> primaryExp .)
    LE              reduce using rule 123 (unaryExp -> primaryExp .)
    EQUAL           reduce using rule 123 (unaryExp -> primaryExp .)
    NEQ             reduce using rule 123 (unaryExp -> primaryExp .)
    AND             reduce using rule 123 (unaryExp -> primaryExp .)
    OR              reduce using rule 123 (unaryExp -> primaryExp .)
    XOR             reduce using rule 123 (unaryExp -> primaryExp .)
    XNOR            reduce using rule 123 (unaryExp -> primaryExp .)
    LAND            reduce using rule 123 (unaryExp -> primaryExp .)
    LOR             reduce using rule 123 (unaryExp -> primaryExp .)
    ]               reduce using rule 123 (unaryExp -> primaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 123 (unaryExp -> primaryExp .)
    )               reduce using rule 123 (unaryExp -> primaryExp .)
    ,               reduce using rule 123 (unaryExp -> primaryExp .)
    ;               reduce using rule 123 (unaryExp -> primaryExp .)
    COLON           reduce using rule 123 (unaryExp -> primaryExp .)
    }               reduce using rule 123 (unaryExp -> primaryExp .)
    RETURN          reduce using rule 123 (unaryExp -> primaryExp .)
    CONST           reduce using rule 123 (unaryExp -> primaryExp .)
    ID              reduce using rule 123 (unaryExp -> primaryExp .)
    {               reduce using rule 123 (unaryExp -> primaryExp .)
    MUX             reduce using rule 123 (unaryExp -> primaryExp .)
    WHEN            reduce using rule 123 (unaryExp -> primaryExp .)
    IF              reduce using rule 123 (unaryExp -> primaryExp .)
    FOR             reduce using rule 123 (unaryExp -> primaryExp .)
    GENERATE        reduce using rule 123 (unaryExp -> primaryExp .)
    INT             reduce using rule 123 (unaryExp -> primaryExp .)
    FLOAT           reduce using rule 123 (unaryExp -> primaryExp .)
    REG             reduce using rule 123 (unaryExp -> primaryExp .)
    WIRE            reduce using rule 123 (unaryExp -> primaryExp .)
    CLOCK           reduce using rule 123 (unaryExp -> primaryExp .)
    SIGNAL          reduce using rule 123 (unaryExp -> primaryExp .)
    (               reduce using rule 123 (unaryExp -> primaryExp .)
    NOT             reduce using rule 123 (unaryExp -> primaryExp .)
    NOTL            reduce using rule 123 (unaryExp -> primaryExp .)
    INTEGER_CONST   reduce using rule 123 (unaryExp -> primaryExp .)
    FLOAT_CONST     reduce using rule 123 (unaryExp -> primaryExp .)
    ELIF            reduce using rule 123 (unaryExp -> primaryExp .)
    ELSE            reduce using rule 123 (unaryExp -> primaryExp .)


state 82

    (124) unaryExp -> ID . ( )
    (125) unaryExp -> ID . ( funcRParams )
    (104) lVal -> ID . array_exp_repeat1
    (105) lVal -> ID . array_exp_repeat2
    (115) array_exp_repeat1 -> . empty
    (116) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (117) array_exp_repeat2 -> . empty
    (118) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 154
    [               shift and go to state 158
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    ]               reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    COLON           reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    ELIF            reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

  ! (               [ reduce using rule 1 (empty -> .) ]

    array_exp_repeat1              shift and go to state 155
    array_exp_repeat2              shift and go to state 156
    empty                          shift and go to state 157

state 83

    (110) primaryExp -> ( . exp )
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 159
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 84

    (126) unaryExp -> SIGNAL . ( unaryExp )

    (               shift and go to state 160


state 85

    (127) unaryExp -> unaryOp . unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    unaryOp                        shift and go to state 85
    unaryExp                       shift and go to state 161
    primaryExp                     shift and go to state 81
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77

state 86

    (111) primaryExp -> lVal .
    (109) lVal -> lVal . . ID

    MUL             reduce using rule 111 (primaryExp -> lVal .)
    DIV             reduce using rule 111 (primaryExp -> lVal .)
    MOD             reduce using rule 111 (primaryExp -> lVal .)
    POWER           reduce using rule 111 (primaryExp -> lVal .)
    ADD             reduce using rule 111 (primaryExp -> lVal .)
    SUB             reduce using rule 111 (primaryExp -> lVal .)
    SLL             reduce using rule 111 (primaryExp -> lVal .)
    SRL             reduce using rule 111 (primaryExp -> lVal .)
    SRA             reduce using rule 111 (primaryExp -> lVal .)
    LT              reduce using rule 111 (primaryExp -> lVal .)
    GT              reduce using rule 111 (primaryExp -> lVal .)
    GE              reduce using rule 111 (primaryExp -> lVal .)
    LE              reduce using rule 111 (primaryExp -> lVal .)
    EQUAL           reduce using rule 111 (primaryExp -> lVal .)
    NEQ             reduce using rule 111 (primaryExp -> lVal .)
    AND             reduce using rule 111 (primaryExp -> lVal .)
    OR              reduce using rule 111 (primaryExp -> lVal .)
    XOR             reduce using rule 111 (primaryExp -> lVal .)
    XNOR            reduce using rule 111 (primaryExp -> lVal .)
    LAND            reduce using rule 111 (primaryExp -> lVal .)
    LOR             reduce using rule 111 (primaryExp -> lVal .)
    ]               reduce using rule 111 (primaryExp -> lVal .)
    BIT_WIDTH_NUMBER reduce using rule 111 (primaryExp -> lVal .)
    )               reduce using rule 111 (primaryExp -> lVal .)
    ,               reduce using rule 111 (primaryExp -> lVal .)
    ;               reduce using rule 111 (primaryExp -> lVal .)
    COLON           reduce using rule 111 (primaryExp -> lVal .)
    }               reduce using rule 111 (primaryExp -> lVal .)
    RETURN          reduce using rule 111 (primaryExp -> lVal .)
    CONST           reduce using rule 111 (primaryExp -> lVal .)
    ID              reduce using rule 111 (primaryExp -> lVal .)
    {               reduce using rule 111 (primaryExp -> lVal .)
    MUX             reduce using rule 111 (primaryExp -> lVal .)
    WHEN            reduce using rule 111 (primaryExp -> lVal .)
    IF              reduce using rule 111 (primaryExp -> lVal .)
    FOR             reduce using rule 111 (primaryExp -> lVal .)
    GENERATE        reduce using rule 111 (primaryExp -> lVal .)
    INT             reduce using rule 111 (primaryExp -> lVal .)
    FLOAT           reduce using rule 111 (primaryExp -> lVal .)
    REG             reduce using rule 111 (primaryExp -> lVal .)
    WIRE            reduce using rule 111 (primaryExp -> lVal .)
    CLOCK           reduce using rule 111 (primaryExp -> lVal .)
    SIGNAL          reduce using rule 111 (primaryExp -> lVal .)
    (               reduce using rule 111 (primaryExp -> lVal .)
    NOT             reduce using rule 111 (primaryExp -> lVal .)
    NOTL            reduce using rule 111 (primaryExp -> lVal .)
    INTEGER_CONST   reduce using rule 111 (primaryExp -> lVal .)
    FLOAT_CONST     reduce using rule 111 (primaryExp -> lVal .)
    ELIF            reduce using rule 111 (primaryExp -> lVal .)
    ELSE            reduce using rule 111 (primaryExp -> lVal .)
    .               shift and go to state 163


state 87

    (112) primaryExp -> number .

    MUL             reduce using rule 112 (primaryExp -> number .)
    DIV             reduce using rule 112 (primaryExp -> number .)
    MOD             reduce using rule 112 (primaryExp -> number .)
    POWER           reduce using rule 112 (primaryExp -> number .)
    ADD             reduce using rule 112 (primaryExp -> number .)
    SUB             reduce using rule 112 (primaryExp -> number .)
    SLL             reduce using rule 112 (primaryExp -> number .)
    SRL             reduce using rule 112 (primaryExp -> number .)
    SRA             reduce using rule 112 (primaryExp -> number .)
    LT              reduce using rule 112 (primaryExp -> number .)
    GT              reduce using rule 112 (primaryExp -> number .)
    GE              reduce using rule 112 (primaryExp -> number .)
    LE              reduce using rule 112 (primaryExp -> number .)
    EQUAL           reduce using rule 112 (primaryExp -> number .)
    NEQ             reduce using rule 112 (primaryExp -> number .)
    AND             reduce using rule 112 (primaryExp -> number .)
    OR              reduce using rule 112 (primaryExp -> number .)
    XOR             reduce using rule 112 (primaryExp -> number .)
    XNOR            reduce using rule 112 (primaryExp -> number .)
    LAND            reduce using rule 112 (primaryExp -> number .)
    LOR             reduce using rule 112 (primaryExp -> number .)
    ]               reduce using rule 112 (primaryExp -> number .)
    BIT_WIDTH_NUMBER reduce using rule 112 (primaryExp -> number .)
    )               reduce using rule 112 (primaryExp -> number .)
    ,               reduce using rule 112 (primaryExp -> number .)
    ;               reduce using rule 112 (primaryExp -> number .)
    COLON           reduce using rule 112 (primaryExp -> number .)
    }               reduce using rule 112 (primaryExp -> number .)
    RETURN          reduce using rule 112 (primaryExp -> number .)
    CONST           reduce using rule 112 (primaryExp -> number .)
    ID              reduce using rule 112 (primaryExp -> number .)
    {               reduce using rule 112 (primaryExp -> number .)
    MUX             reduce using rule 112 (primaryExp -> number .)
    WHEN            reduce using rule 112 (primaryExp -> number .)
    IF              reduce using rule 112 (primaryExp -> number .)
    FOR             reduce using rule 112 (primaryExp -> number .)
    GENERATE        reduce using rule 112 (primaryExp -> number .)
    INT             reduce using rule 112 (primaryExp -> number .)
    FLOAT           reduce using rule 112 (primaryExp -> number .)
    REG             reduce using rule 112 (primaryExp -> number .)
    WIRE            reduce using rule 112 (primaryExp -> number .)
    CLOCK           reduce using rule 112 (primaryExp -> number .)
    SIGNAL          reduce using rule 112 (primaryExp -> number .)
    (               reduce using rule 112 (primaryExp -> number .)
    NOT             reduce using rule 112 (primaryExp -> number .)
    NOTL            reduce using rule 112 (primaryExp -> number .)
    INTEGER_CONST   reduce using rule 112 (primaryExp -> number .)
    FLOAT_CONST     reduce using rule 112 (primaryExp -> number .)
    ELIF            reduce using rule 112 (primaryExp -> number .)
    ELSE            reduce using rule 112 (primaryExp -> number .)


state 88

    (130) unaryOp -> NOT .

    ID              reduce using rule 130 (unaryOp -> NOT .)
    SIGNAL          reduce using rule 130 (unaryOp -> NOT .)
    (               reduce using rule 130 (unaryOp -> NOT .)
    ADD             reduce using rule 130 (unaryOp -> NOT .)
    SUB             reduce using rule 130 (unaryOp -> NOT .)
    NOT             reduce using rule 130 (unaryOp -> NOT .)
    NOTL            reduce using rule 130 (unaryOp -> NOT .)
    {               reduce using rule 130 (unaryOp -> NOT .)
    MUX             reduce using rule 130 (unaryOp -> NOT .)
    INTEGER_CONST   reduce using rule 130 (unaryOp -> NOT .)
    FLOAT_CONST     reduce using rule 130 (unaryOp -> NOT .)


state 89

    (131) unaryOp -> NOTL .

    ID              reduce using rule 131 (unaryOp -> NOTL .)
    SIGNAL          reduce using rule 131 (unaryOp -> NOTL .)
    (               reduce using rule 131 (unaryOp -> NOTL .)
    ADD             reduce using rule 131 (unaryOp -> NOTL .)
    SUB             reduce using rule 131 (unaryOp -> NOTL .)
    NOT             reduce using rule 131 (unaryOp -> NOTL .)
    NOTL            reduce using rule 131 (unaryOp -> NOTL .)
    {               reduce using rule 131 (unaryOp -> NOTL .)
    MUX             reduce using rule 131 (unaryOp -> NOTL .)
    INTEGER_CONST   reduce using rule 131 (unaryOp -> NOTL .)
    FLOAT_CONST     reduce using rule 131 (unaryOp -> NOTL .)


state 90

    (106) lVal -> { . ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> { . ID array_exp_repeat2 lVal_repeat }

    ID              shift and go to state 164


state 91

    (108) lVal -> MUX . ( exp , exp , exp )

    (               shift and go to state 165


state 92

    (119) number -> INTEGER_CONST .

    MUL             reduce using rule 119 (number -> INTEGER_CONST .)
    DIV             reduce using rule 119 (number -> INTEGER_CONST .)
    MOD             reduce using rule 119 (number -> INTEGER_CONST .)
    POWER           reduce using rule 119 (number -> INTEGER_CONST .)
    ADD             reduce using rule 119 (number -> INTEGER_CONST .)
    SUB             reduce using rule 119 (number -> INTEGER_CONST .)
    SLL             reduce using rule 119 (number -> INTEGER_CONST .)
    SRL             reduce using rule 119 (number -> INTEGER_CONST .)
    SRA             reduce using rule 119 (number -> INTEGER_CONST .)
    LT              reduce using rule 119 (number -> INTEGER_CONST .)
    GT              reduce using rule 119 (number -> INTEGER_CONST .)
    GE              reduce using rule 119 (number -> INTEGER_CONST .)
    LE              reduce using rule 119 (number -> INTEGER_CONST .)
    EQUAL           reduce using rule 119 (number -> INTEGER_CONST .)
    NEQ             reduce using rule 119 (number -> INTEGER_CONST .)
    AND             reduce using rule 119 (number -> INTEGER_CONST .)
    OR              reduce using rule 119 (number -> INTEGER_CONST .)
    XOR             reduce using rule 119 (number -> INTEGER_CONST .)
    XNOR            reduce using rule 119 (number -> INTEGER_CONST .)
    LAND            reduce using rule 119 (number -> INTEGER_CONST .)
    LOR             reduce using rule 119 (number -> INTEGER_CONST .)
    ]               reduce using rule 119 (number -> INTEGER_CONST .)
    BIT_WIDTH_NUMBER reduce using rule 119 (number -> INTEGER_CONST .)
    )               reduce using rule 119 (number -> INTEGER_CONST .)
    ,               reduce using rule 119 (number -> INTEGER_CONST .)
    ;               reduce using rule 119 (number -> INTEGER_CONST .)
    COLON           reduce using rule 119 (number -> INTEGER_CONST .)
    }               reduce using rule 119 (number -> INTEGER_CONST .)
    RETURN          reduce using rule 119 (number -> INTEGER_CONST .)
    CONST           reduce using rule 119 (number -> INTEGER_CONST .)
    ID              reduce using rule 119 (number -> INTEGER_CONST .)
    {               reduce using rule 119 (number -> INTEGER_CONST .)
    MUX             reduce using rule 119 (number -> INTEGER_CONST .)
    WHEN            reduce using rule 119 (number -> INTEGER_CONST .)
    IF              reduce using rule 119 (number -> INTEGER_CONST .)
    FOR             reduce using rule 119 (number -> INTEGER_CONST .)
    GENERATE        reduce using rule 119 (number -> INTEGER_CONST .)
    INT             reduce using rule 119 (number -> INTEGER_CONST .)
    FLOAT           reduce using rule 119 (number -> INTEGER_CONST .)
    REG             reduce using rule 119 (number -> INTEGER_CONST .)
    WIRE            reduce using rule 119 (number -> INTEGER_CONST .)
    CLOCK           reduce using rule 119 (number -> INTEGER_CONST .)
    SIGNAL          reduce using rule 119 (number -> INTEGER_CONST .)
    (               reduce using rule 119 (number -> INTEGER_CONST .)
    NOT             reduce using rule 119 (number -> INTEGER_CONST .)
    NOTL            reduce using rule 119 (number -> INTEGER_CONST .)
    INTEGER_CONST   reduce using rule 119 (number -> INTEGER_CONST .)
    FLOAT_CONST     reduce using rule 119 (number -> INTEGER_CONST .)
    ELIF            reduce using rule 119 (number -> INTEGER_CONST .)
    ELSE            reduce using rule 119 (number -> INTEGER_CONST .)


state 93

    (120) number -> FLOAT_CONST .

    MUL             reduce using rule 120 (number -> FLOAT_CONST .)
    DIV             reduce using rule 120 (number -> FLOAT_CONST .)
    MOD             reduce using rule 120 (number -> FLOAT_CONST .)
    POWER           reduce using rule 120 (number -> FLOAT_CONST .)
    ADD             reduce using rule 120 (number -> FLOAT_CONST .)
    SUB             reduce using rule 120 (number -> FLOAT_CONST .)
    SLL             reduce using rule 120 (number -> FLOAT_CONST .)
    SRL             reduce using rule 120 (number -> FLOAT_CONST .)
    SRA             reduce using rule 120 (number -> FLOAT_CONST .)
    LT              reduce using rule 120 (number -> FLOAT_CONST .)
    GT              reduce using rule 120 (number -> FLOAT_CONST .)
    GE              reduce using rule 120 (number -> FLOAT_CONST .)
    LE              reduce using rule 120 (number -> FLOAT_CONST .)
    EQUAL           reduce using rule 120 (number -> FLOAT_CONST .)
    NEQ             reduce using rule 120 (number -> FLOAT_CONST .)
    AND             reduce using rule 120 (number -> FLOAT_CONST .)
    OR              reduce using rule 120 (number -> FLOAT_CONST .)
    XOR             reduce using rule 120 (number -> FLOAT_CONST .)
    XNOR            reduce using rule 120 (number -> FLOAT_CONST .)
    LAND            reduce using rule 120 (number -> FLOAT_CONST .)
    LOR             reduce using rule 120 (number -> FLOAT_CONST .)
    ]               reduce using rule 120 (number -> FLOAT_CONST .)
    BIT_WIDTH_NUMBER reduce using rule 120 (number -> FLOAT_CONST .)
    )               reduce using rule 120 (number -> FLOAT_CONST .)
    ,               reduce using rule 120 (number -> FLOAT_CONST .)
    ;               reduce using rule 120 (number -> FLOAT_CONST .)
    COLON           reduce using rule 120 (number -> FLOAT_CONST .)
    }               reduce using rule 120 (number -> FLOAT_CONST .)
    RETURN          reduce using rule 120 (number -> FLOAT_CONST .)
    CONST           reduce using rule 120 (number -> FLOAT_CONST .)
    ID              reduce using rule 120 (number -> FLOAT_CONST .)
    {               reduce using rule 120 (number -> FLOAT_CONST .)
    MUX             reduce using rule 120 (number -> FLOAT_CONST .)
    WHEN            reduce using rule 120 (number -> FLOAT_CONST .)
    IF              reduce using rule 120 (number -> FLOAT_CONST .)
    FOR             reduce using rule 120 (number -> FLOAT_CONST .)
    GENERATE        reduce using rule 120 (number -> FLOAT_CONST .)
    INT             reduce using rule 120 (number -> FLOAT_CONST .)
    FLOAT           reduce using rule 120 (number -> FLOAT_CONST .)
    REG             reduce using rule 120 (number -> FLOAT_CONST .)
    WIRE            reduce using rule 120 (number -> FLOAT_CONST .)
    CLOCK           reduce using rule 120 (number -> FLOAT_CONST .)
    SIGNAL          reduce using rule 120 (number -> FLOAT_CONST .)
    (               reduce using rule 120 (number -> FLOAT_CONST .)
    NOT             reduce using rule 120 (number -> FLOAT_CONST .)
    NOTL            reduce using rule 120 (number -> FLOAT_CONST .)
    INTEGER_CONST   reduce using rule 120 (number -> FLOAT_CONST .)
    FLOAT_CONST     reduce using rule 120 (number -> FLOAT_CONST .)
    ELIF            reduce using rule 120 (number -> FLOAT_CONST .)
    ELSE            reduce using rule 120 (number -> FLOAT_CONST .)


state 94

    (121) number -> circuit_const .

    MUL             reduce using rule 121 (number -> circuit_const .)
    DIV             reduce using rule 121 (number -> circuit_const .)
    MOD             reduce using rule 121 (number -> circuit_const .)
    POWER           reduce using rule 121 (number -> circuit_const .)
    ADD             reduce using rule 121 (number -> circuit_const .)
    SUB             reduce using rule 121 (number -> circuit_const .)
    SLL             reduce using rule 121 (number -> circuit_const .)
    SRL             reduce using rule 121 (number -> circuit_const .)
    SRA             reduce using rule 121 (number -> circuit_const .)
    LT              reduce using rule 121 (number -> circuit_const .)
    GT              reduce using rule 121 (number -> circuit_const .)
    GE              reduce using rule 121 (number -> circuit_const .)
    LE              reduce using rule 121 (number -> circuit_const .)
    EQUAL           reduce using rule 121 (number -> circuit_const .)
    NEQ             reduce using rule 121 (number -> circuit_const .)
    AND             reduce using rule 121 (number -> circuit_const .)
    OR              reduce using rule 121 (number -> circuit_const .)
    XOR             reduce using rule 121 (number -> circuit_const .)
    XNOR            reduce using rule 121 (number -> circuit_const .)
    LAND            reduce using rule 121 (number -> circuit_const .)
    LOR             reduce using rule 121 (number -> circuit_const .)
    ]               reduce using rule 121 (number -> circuit_const .)
    BIT_WIDTH_NUMBER reduce using rule 121 (number -> circuit_const .)
    )               reduce using rule 121 (number -> circuit_const .)
    ,               reduce using rule 121 (number -> circuit_const .)
    ;               reduce using rule 121 (number -> circuit_const .)
    COLON           reduce using rule 121 (number -> circuit_const .)
    }               reduce using rule 121 (number -> circuit_const .)
    RETURN          reduce using rule 121 (number -> circuit_const .)
    CONST           reduce using rule 121 (number -> circuit_const .)
    ID              reduce using rule 121 (number -> circuit_const .)
    {               reduce using rule 121 (number -> circuit_const .)
    MUX             reduce using rule 121 (number -> circuit_const .)
    WHEN            reduce using rule 121 (number -> circuit_const .)
    IF              reduce using rule 121 (number -> circuit_const .)
    FOR             reduce using rule 121 (number -> circuit_const .)
    GENERATE        reduce using rule 121 (number -> circuit_const .)
    INT             reduce using rule 121 (number -> circuit_const .)
    FLOAT           reduce using rule 121 (number -> circuit_const .)
    REG             reduce using rule 121 (number -> circuit_const .)
    WIRE            reduce using rule 121 (number -> circuit_const .)
    CLOCK           reduce using rule 121 (number -> circuit_const .)
    SIGNAL          reduce using rule 121 (number -> circuit_const .)
    (               reduce using rule 121 (number -> circuit_const .)
    NOT             reduce using rule 121 (number -> circuit_const .)
    NOTL            reduce using rule 121 (number -> circuit_const .)
    INTEGER_CONST   reduce using rule 121 (number -> circuit_const .)
    FLOAT_CONST     reduce using rule 121 (number -> circuit_const .)
    ELIF            reduce using rule 121 (number -> circuit_const .)
    ELSE            reduce using rule 121 (number -> circuit_const .)


state 95

    (26) type_def -> cir_type .

    ID              reduce using rule 26 (type_def -> cir_type .)


state 96

    (20) cir_basic_type -> ID .

    [               reduce using rule 20 (cir_basic_type -> ID .)
    ID              reduce using rule 20 (cir_basic_type -> ID .)


state 97

    (60) cir_function -> cir_type ID ( cir_funcFParams . ) block

    )               shift and go to state 166


state 98

    (64) cir_funcFParams -> cir_funcFParam . cir_funcFParams_repeat
    (62) cir_funcFParams_repeat -> . empty
    (63) cir_funcFParams_repeat -> . , cir_funcFParam cir_funcFParams_repeat
    (1) empty -> .

    ,               shift and go to state 169
    )               reduce using rule 1 (empty -> .)

    cir_funcFParams_repeat         shift and go to state 167
    empty                          shift and go to state 168

state 99

    (68) cir_funcFParam -> type_def . ID array

    ID              shift and go to state 170


state 100

    (25) type_def -> val_type .

    ID              reduce using rule 25 (type_def -> val_type .)


state 101

    (59) cirDef -> ID array ASSIGN . initVal
    (53) initVal -> . exp
    (54) initVal -> . { initVal initVal_repeat }
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    {               shift and go to state 173
    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    initVal                        shift and go to state 171
    exp                            shift and go to state 172
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 102

    (28) array -> [ constExp . ] array

    ]               shift and go to state 174


state 103

    (168) constExp -> exp .
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               reduce using rule 168 (constExp -> exp .)
    ,               reduce using rule 168 (constExp -> exp .)
    ;               reduce using rule 168 (constExp -> exp .)
    }               reduce using rule 168 (constExp -> exp .)
    BIT_WIDTH_NUMBER shift and go to state 132


state 104

    (57) cirDecl -> cir_type cirDef cirDecl_repeat ; .

    MODULE          reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    BUNDLE          reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    CONST           reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    ID              reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    INT             reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    FLOAT           reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    REG             reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    WIRE            reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    CLOCK           reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    $end            reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    ;               reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    RETURN          reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    {               reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    MUX             reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    WHEN            reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    IF              reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    FOR             reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    GENERATE        reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    SIGNAL          reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    (               reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    ADD             reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    SUB             reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    NOT             reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    NOTL            reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    INTEGER_CONST   reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    FLOAT_CONST     reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    }               reduce using rule 57 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)


state 105

    (56) cirDecl_repeat -> , cirDef . cirDecl_repeat
    (55) cirDecl_repeat -> . empty
    (56) cirDecl_repeat -> . , cirDef cirDecl_repeat
    (1) empty -> .

    ,               shift and go to state 49
    ;               reduce using rule 1 (empty -> .)

    cirDecl_repeat                 shift and go to state 175
    empty                          shift and go to state 48

state 106

    (58) cirDef -> ID . array
    (59) cirDef -> ID . array ASSIGN initVal
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 46
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)

    array                          shift and go to state 44
    empty                          shift and go to state 45

state 107

    (39) modDecl -> ID ( module_R_params ) . ID array ;

    ID              shift and go to state 176


state 108

    (46) module_R_params -> p_module_R_params_item module_R_params_repeat .

    )               reduce using rule 46 (module_R_params -> p_module_R_params_item module_R_params_repeat .)


state 109

    (44) module_R_params_repeat -> empty .

    )               reduce using rule 44 (module_R_params_repeat -> empty .)


state 110

    (45) module_R_params_repeat -> , . p_module_R_params_item module_R_params_repeat
    (43) p_module_R_params_item -> . R_port_def ID ( ID )
    (40) R_port_def -> . IN .
    (41) R_port_def -> . OUT .
    (42) R_port_def -> . INOUT .

    IN              shift and go to state 54
    OUT             shift and go to state 55
    INOUT           shift and go to state 56

    p_module_R_params_item         shift and go to state 177
    R_port_def                     shift and go to state 53

state 111

    (43) p_module_R_params_item -> R_port_def ID . ( ID )

    (               shift and go to state 178


state 112

    (40) R_port_def -> IN . .

    ID              reduce using rule 40 (R_port_def -> IN . .)


state 113

    (41) R_port_def -> OUT . .

    ID              reduce using rule 41 (R_port_def -> OUT . .)


state 114

    (42) R_port_def -> INOUT . .

    ID              reduce using rule 42 (R_port_def -> INOUT . .)


state 115

    (48) bundleDecl_repeat -> , bundleDef . bundleDecl_repeat
    (47) bundleDecl_repeat -> . empty
    (48) bundleDecl_repeat -> . , bundleDef bundleDecl_repeat
    (1) empty -> .

    ,               shift and go to state 59
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    bundleDecl_repeat              shift and go to state 179
    empty                          shift and go to state 58

state 116

    (69) funcFParam -> val_type . ID array

    ID              shift and go to state 180


state 117

    (61) function -> val_type ID ( funcFParams . ) block

    )               shift and go to state 181


state 118

    (67) funcFParams -> funcFParam . funcFParams_repeat
    (65) funcFParams_repeat -> . empty
    (66) funcFParams_repeat -> . , funcFParam funcFParams_repeat
    (1) empty -> .

    ,               shift and go to state 184
    )               reduce using rule 1 (empty -> .)

    funcFParams_repeat             shift and go to state 182
    empty                          shift and go to state 183

state 119

    (38) varDef -> ID array ASSIGN . initVal
    (53) initVal -> . exp
    (54) initVal -> . { initVal initVal_repeat }
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    {               shift and go to state 173
    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    initVal                        shift and go to state 185
    exp                            shift and go to state 172
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 120

    (36) varDecl -> val_type varDef varDef_repeat ; .

    MODULE          reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    BUNDLE          reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    CONST           reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    ID              reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    INT             reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    FLOAT           reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    REG             reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    WIRE            reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    CLOCK           reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    $end            reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    ;               reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    RETURN          reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    {               reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    MUX             reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    WHEN            reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    IF              reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    FOR             reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    GENERATE        reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    SIGNAL          reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    (               reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    ADD             reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    SUB             reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    NOT             reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    NOTL            reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    INTEGER_CONST   reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    FLOAT_CONST     reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)
    }               reduce using rule 36 (varDecl -> val_type varDef varDef_repeat ; .)


state 121

    (35) varDef_repeat -> , varDef . varDef_repeat
    (34) varDef_repeat -> . empty
    (35) varDef_repeat -> . , varDef varDef_repeat
    (1) empty -> .

    ,               shift and go to state 64
    ;               reduce using rule 1 (empty -> .)

    varDef_repeat                  shift and go to state 186
    empty                          shift and go to state 63

state 122

    (37) varDef -> ID . array
    (38) varDef -> ID . array ASSIGN initVal
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 46
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)

    array                          shift and go to state 61
    empty                          shift and go to state 45

state 123

    (75) module -> MODULE ID ( module_para_para . port_def ID p_module_para_port ) block
    (165) port_def -> . INPUT cir_type
    (166) port_def -> . OUTPUT cir_type
    (167) port_def -> . INOUT cir_type

    INPUT           shift and go to state 188
    OUTPUT          shift and go to state 189
    INOUT           shift and go to state 190

    port_def                       shift and go to state 187

state 124

    (70) module_para_para -> empty .

    INPUT           reduce using rule 70 (module_para_para -> empty .)
    OUTPUT          reduce using rule 70 (module_para_para -> empty .)
    INOUT           reduce using rule 70 (module_para_para -> empty .)


state 125

    (71) module_para_para -> PARA . val_type ID ,
    (72) module_para_para -> PARA . val_type ID , module_para_para
    (23) val_type -> . INT
    (24) val_type -> . FLOAT

    INT             shift and go to state 19
    FLOAT           shift and go to state 20

    val_type                       shift and go to state 191

state 126

    (78) bundle -> BUNDLE ID ( cir_type . ID bundle_repeat )

    ID              shift and go to state 192


state 127

    (16) constDecl -> CONST val_type constDef constDecl_repeat . ;

    ;               shift and go to state 193


state 128

    (14) constDecl_repeat -> empty .

    ;               reduce using rule 14 (constDecl_repeat -> empty .)


state 129

    (15) constDecl_repeat -> , . constDef constDecl_repeat
    (29) constDef -> . ID array ASSIGN constInitVal

    ID              shift and go to state 68

    constDef                       shift and go to state 194

state 130

    (29) constDef -> ID array . ASSIGN constInitVal

    ASSIGN          shift and go to state 195


state 131

    (22) cir_type -> cir_basic_type [ exp ] .

    ID              reduce using rule 22 (cir_type -> cir_basic_type [ exp ] .)


state 132

    (122) circuit_const -> exp BIT_WIDTH_NUMBER .

    MUL             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    DIV             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    MOD             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    POWER           reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ADD             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SUB             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SLL             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SRL             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SRA             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    LT              reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    GT              reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    GE              reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    LE              reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    EQUAL           reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    NEQ             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    AND             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    OR              reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    XOR             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    XNOR            reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    LAND            reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    LOR             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ]               reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    BIT_WIDTH_NUMBER reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    )               reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ,               reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ;               reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    COLON           reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    }               reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    RETURN          reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    CONST           reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ID              reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    {               reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    MUX             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    WHEN            reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    IF              reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    FOR             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    GENERATE        reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    INT             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    FLOAT           reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    REG             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    WIRE            reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    CLOCK           reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SIGNAL          reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    (               reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    NOT             reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    NOTL            reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    INTEGER_CONST   reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    FLOAT_CONST     reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ELIF            reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ELSE            reduce using rule 122 (circuit_const -> exp BIT_WIDTH_NUMBER .)


state 133

    (164) lOrExp -> lOrExp LOR . lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 196
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 134

    (162) lAndExp -> lAndExp LAND . redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 197
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70

state 135

    (157) redExp -> redExp AND . eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    redExp                         shift and go to state 72
    eqExp                          shift and go to state 198
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71

state 136

    (158) redExp -> redExp OR . eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    redExp                         shift and go to state 72
    eqExp                          shift and go to state 199
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71

state 137

    (159) redExp -> redExp XOR . eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    redExp                         shift and go to state 72
    eqExp                          shift and go to state 200
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71

state 138

    (160) redExp -> redExp XNOR . eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    redExp                         shift and go to state 72
    eqExp                          shift and go to state 201
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71

state 139

    (154) eqExp -> eqExp EQUAL . eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    eqExp                          shift and go to state 202
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72

state 140

    (155) eqExp -> eqExp NEQ . eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    eqExp                          shift and go to state 203
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72

state 141

    (149) relExp -> relExp LT . addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    relExp                         shift and go to state 74
    addExp                         shift and go to state 204
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    shiftExp                       shift and go to state 75

state 142

    (150) relExp -> relExp GT . addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    relExp                         shift and go to state 74
    addExp                         shift and go to state 205
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    shiftExp                       shift and go to state 75

state 143

    (151) relExp -> relExp GE . addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    relExp                         shift and go to state 74
    addExp                         shift and go to state 206
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    shiftExp                       shift and go to state 75

state 144

    (152) relExp -> relExp LE . addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    relExp                         shift and go to state 74
    addExp                         shift and go to state 207
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    shiftExp                       shift and go to state 75

state 145

    (145) shiftExp -> shiftExp SLL . addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 208
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74

state 146

    (146) shiftExp -> shiftExp SRL . addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 209
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74

state 147

    (147) shiftExp -> shiftExp SRA . addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 210
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74

state 148

    (142) addExp -> addExp ADD . mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    addExp                         shift and go to state 76
    mulExp                         shift and go to state 211
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75

state 149

    (143) addExp -> addExp SUB . mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    addExp                         shift and go to state 76
    mulExp                         shift and go to state 212
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75

state 150

    (137) mulExp -> mulExp MUL . unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 213
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76

state 151

    (138) mulExp -> mulExp DIV . unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 214
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76

state 152

    (139) mulExp -> mulExp MOD . unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 215
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76

state 153

    (140) mulExp -> mulExp POWER . unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 216
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76

state 154

    (124) unaryExp -> ID ( . )
    (125) unaryExp -> ID ( . funcRParams )
    (134) funcRParams -> . exp
    (135) funcRParams -> . exp exp_repeat
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    )               shift and go to state 217
    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    funcRParams                    shift and go to state 218
    exp                            shift and go to state 219
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 155

    (104) lVal -> ID array_exp_repeat1 .

    .               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    MUL             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    DIV             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    MOD             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    POWER           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ADD             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SUB             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SLL             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SRL             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SRA             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    LT              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    GT              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    GE              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    LE              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    EQUAL           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    NEQ             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    AND             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    OR              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    XOR             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    XNOR            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    LAND            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    LOR             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ]               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    BIT_WIDTH_NUMBER reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    )               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ,               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ;               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    COLON           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    }               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    RETURN          reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    CONST           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ID              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    {               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    MUX             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    WHEN            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    IF              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    FOR             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    GENERATE        reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    INT             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    FLOAT           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    REG             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    WIRE            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    CLOCK           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SIGNAL          reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    (               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    NOT             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    NOTL            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    INTEGER_CONST   reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    FLOAT_CONST     reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ELIF            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ELSE            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ASSIGN          reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    CONNECT         reduce using rule 104 (lVal -> ID array_exp_repeat1 .)


state 156

    (105) lVal -> ID array_exp_repeat2 .

    .               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    MUL             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    DIV             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    MOD             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    POWER           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ADD             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SUB             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SLL             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SRL             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SRA             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    LT              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    GT              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    GE              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    LE              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    EQUAL           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    NEQ             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    AND             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    OR              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    XOR             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    XNOR            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    LAND            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    LOR             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ]               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    BIT_WIDTH_NUMBER reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    )               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ,               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ;               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    COLON           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    }               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    RETURN          reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    CONST           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ID              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    {               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    MUX             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    WHEN            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    IF              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    FOR             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    GENERATE        reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    INT             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    FLOAT           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    REG             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    WIRE            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    CLOCK           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SIGNAL          reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    (               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    NOT             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    NOTL            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    INTEGER_CONST   reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    FLOAT_CONST     reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ELIF            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ELSE            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ASSIGN          reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    CONNECT         reduce using rule 105 (lVal -> ID array_exp_repeat2 .)


state 157

    (115) array_exp_repeat1 -> empty .
    (117) array_exp_repeat2 -> empty .

  ! reduce/reduce conflict for . resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for MUL resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for DIV resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for MOD resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for POWER resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ADD resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SUB resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SLL resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SRL resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SRA resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for LT resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for GT resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for GE resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for LE resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for EQUAL resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for NEQ resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for AND resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for OR resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for XOR resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for XNOR resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for LAND resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for LOR resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ] resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ) resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for , resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ; resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for COLON resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for } resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for CONST resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for { resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for MUX resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for WHEN resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for GENERATE resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for REG resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for WIRE resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for CLOCK resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SIGNAL resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ( resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for NOTL resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for INTEGER_CONST resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for FLOAT_CONST resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ELIF resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ASSIGN resolved using rule 115 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for CONNECT resolved using rule 115 (array_exp_repeat1 -> empty .)
    .               reduce using rule 115 (array_exp_repeat1 -> empty .)
    MUL             reduce using rule 115 (array_exp_repeat1 -> empty .)
    DIV             reduce using rule 115 (array_exp_repeat1 -> empty .)
    MOD             reduce using rule 115 (array_exp_repeat1 -> empty .)
    POWER           reduce using rule 115 (array_exp_repeat1 -> empty .)
    ADD             reduce using rule 115 (array_exp_repeat1 -> empty .)
    SUB             reduce using rule 115 (array_exp_repeat1 -> empty .)
    SLL             reduce using rule 115 (array_exp_repeat1 -> empty .)
    SRL             reduce using rule 115 (array_exp_repeat1 -> empty .)
    SRA             reduce using rule 115 (array_exp_repeat1 -> empty .)
    LT              reduce using rule 115 (array_exp_repeat1 -> empty .)
    GT              reduce using rule 115 (array_exp_repeat1 -> empty .)
    GE              reduce using rule 115 (array_exp_repeat1 -> empty .)
    LE              reduce using rule 115 (array_exp_repeat1 -> empty .)
    EQUAL           reduce using rule 115 (array_exp_repeat1 -> empty .)
    NEQ             reduce using rule 115 (array_exp_repeat1 -> empty .)
    AND             reduce using rule 115 (array_exp_repeat1 -> empty .)
    OR              reduce using rule 115 (array_exp_repeat1 -> empty .)
    XOR             reduce using rule 115 (array_exp_repeat1 -> empty .)
    XNOR            reduce using rule 115 (array_exp_repeat1 -> empty .)
    LAND            reduce using rule 115 (array_exp_repeat1 -> empty .)
    LOR             reduce using rule 115 (array_exp_repeat1 -> empty .)
    ]               reduce using rule 115 (array_exp_repeat1 -> empty .)
    BIT_WIDTH_NUMBER reduce using rule 115 (array_exp_repeat1 -> empty .)
    )               reduce using rule 115 (array_exp_repeat1 -> empty .)
    ,               reduce using rule 115 (array_exp_repeat1 -> empty .)
    ;               reduce using rule 115 (array_exp_repeat1 -> empty .)
    COLON           reduce using rule 115 (array_exp_repeat1 -> empty .)
    }               reduce using rule 115 (array_exp_repeat1 -> empty .)
    RETURN          reduce using rule 115 (array_exp_repeat1 -> empty .)
    CONST           reduce using rule 115 (array_exp_repeat1 -> empty .)
    ID              reduce using rule 115 (array_exp_repeat1 -> empty .)
    {               reduce using rule 115 (array_exp_repeat1 -> empty .)
    MUX             reduce using rule 115 (array_exp_repeat1 -> empty .)
    WHEN            reduce using rule 115 (array_exp_repeat1 -> empty .)
    IF              reduce using rule 115 (array_exp_repeat1 -> empty .)
    FOR             reduce using rule 115 (array_exp_repeat1 -> empty .)
    GENERATE        reduce using rule 115 (array_exp_repeat1 -> empty .)
    INT             reduce using rule 115 (array_exp_repeat1 -> empty .)
    FLOAT           reduce using rule 115 (array_exp_repeat1 -> empty .)
    REG             reduce using rule 115 (array_exp_repeat1 -> empty .)
    WIRE            reduce using rule 115 (array_exp_repeat1 -> empty .)
    CLOCK           reduce using rule 115 (array_exp_repeat1 -> empty .)
    SIGNAL          reduce using rule 115 (array_exp_repeat1 -> empty .)
    (               reduce using rule 115 (array_exp_repeat1 -> empty .)
    NOT             reduce using rule 115 (array_exp_repeat1 -> empty .)
    NOTL            reduce using rule 115 (array_exp_repeat1 -> empty .)
    INTEGER_CONST   reduce using rule 115 (array_exp_repeat1 -> empty .)
    FLOAT_CONST     reduce using rule 115 (array_exp_repeat1 -> empty .)
    ELIF            reduce using rule 115 (array_exp_repeat1 -> empty .)
    ELSE            reduce using rule 115 (array_exp_repeat1 -> empty .)
    ASSIGN          reduce using rule 115 (array_exp_repeat1 -> empty .)
    CONNECT         reduce using rule 115 (array_exp_repeat1 -> empty .)

  ! .               [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! MUL             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! DIV             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! MOD             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! POWER           [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! ADD             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! SUB             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! SLL             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! SRL             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! SRA             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! LT              [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! GT              [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! GE              [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! LE              [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! EQUAL           [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! NEQ             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! AND             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! OR              [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! XOR             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! XNOR            [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! LAND            [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! LOR             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! ]               [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! )               [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! ,               [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! ;               [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! COLON           [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! }               [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! RETURN          [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! CONST           [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! ID              [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! {               [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! MUX             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! WHEN            [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! IF              [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! FOR             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! GENERATE        [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! INT             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! FLOAT           [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! REG             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! WIRE            [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! CLOCK           [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! SIGNAL          [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! (               [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! NOT             [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! NOTL            [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! INTEGER_CONST   [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! FLOAT_CONST     [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! ELIF            [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! ELSE            [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! ASSIGN          [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]
  ! CONNECT         [ reduce using rule 117 (array_exp_repeat2 -> empty .) ]


state 158

    (116) array_exp_repeat1 -> [ . exp ] array_exp_repeat1
    (118) array_exp_repeat2 -> [ . exp COLON exp ] array_exp_repeat2
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 220
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 159

    (110) primaryExp -> ( exp . )
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 221
    BIT_WIDTH_NUMBER shift and go to state 132


state 160

    (126) unaryExp -> SIGNAL ( . unaryExp )
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    unaryExp                       shift and go to state 222
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    exp                            shift and go to state 162
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77

state 161

    (127) unaryExp -> unaryOp unaryExp .
    (136) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for AND resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for OR resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for XOR resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 127 (unaryExp -> unaryOp unaryExp .)
    MUL             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    DIV             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    MOD             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    POWER           reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    ADD             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    SUB             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    SLL             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    SRL             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    SRA             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    LT              reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    GT              reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    GE              reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    LE              reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    EQUAL           reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    NEQ             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    AND             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    OR              reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    XOR             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    XNOR            reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    LAND            reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    LOR             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    ]               reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    )               reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    ,               reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    ;               reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    COLON           reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    }               reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    RETURN          reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    CONST           reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    ID              reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    {               reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    MUX             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    WHEN            reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    IF              reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    FOR             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    GENERATE        reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    INT             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    FLOAT           reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    REG             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    WIRE            reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    CLOCK           reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    SIGNAL          reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    (               reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    NOT             reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    NOTL            reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    INTEGER_CONST   reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    FLOAT_CONST     reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    ELIF            reduce using rule 127 (unaryExp -> unaryOp unaryExp .)
    ELSE            reduce using rule 127 (unaryExp -> unaryOp unaryExp .)

  ! MUL             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! DIV             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! MOD             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! POWER           [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! ADD             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! SUB             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! SLL             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! SRL             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! SRA             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! LT              [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! GT              [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! GE              [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! LE              [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! EQUAL           [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! NEQ             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! AND             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! OR              [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! XOR             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! XNOR            [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! LAND            [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! LOR             [ reduce using rule 136 (mulExp -> unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 136 (mulExp -> unaryExp .) ]


state 162

    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    BIT_WIDTH_NUMBER shift and go to state 132


state 163

    (109) lVal -> lVal . . ID

    ID              shift and go to state 223


state 164

    (106) lVal -> { ID . array_exp_repeat1 lVal_repeat }
    (107) lVal -> { ID . array_exp_repeat2 lVal_repeat }
    (115) array_exp_repeat1 -> . empty
    (116) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (117) array_exp_repeat2 -> . empty
    (118) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

    [               shift and go to state 158
    ,               reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    array_exp_repeat1              shift and go to state 224
    array_exp_repeat2              shift and go to state 225
    empty                          shift and go to state 157

state 165

    (108) lVal -> MUX ( . exp , exp , exp )
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 226
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 166

    (60) cir_function -> cir_type ID ( cir_funcFParams ) . block
    (81) block -> . { block_repeat }

    {               shift and go to state 228

    block                          shift and go to state 227

state 167

    (64) cir_funcFParams -> cir_funcFParam cir_funcFParams_repeat .

    )               reduce using rule 64 (cir_funcFParams -> cir_funcFParam cir_funcFParams_repeat .)


state 168

    (62) cir_funcFParams_repeat -> empty .

    )               reduce using rule 62 (cir_funcFParams_repeat -> empty .)


state 169

    (63) cir_funcFParams_repeat -> , . cir_funcFParam cir_funcFParams_repeat
    (68) cir_funcFParam -> . type_def ID array
    (25) type_def -> . val_type
    (26) type_def -> . cir_type
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    ID              shift and go to state 96

    cir_funcFParam                 shift and go to state 229
    type_def                       shift and go to state 99
    val_type                       shift and go to state 100
    cir_type                       shift and go to state 95
    cir_basic_type                 shift and go to state 18

state 170

    (68) cir_funcFParam -> type_def ID . array
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 46
    ,               reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

    array                          shift and go to state 230
    empty                          shift and go to state 45

state 171

    (59) cirDef -> ID array ASSIGN initVal .

    ,               reduce using rule 59 (cirDef -> ID array ASSIGN initVal .)
    ;               reduce using rule 59 (cirDef -> ID array ASSIGN initVal .)


state 172

    (53) initVal -> exp .
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ,               reduce using rule 53 (initVal -> exp .)
    ;               reduce using rule 53 (initVal -> exp .)
    }               reduce using rule 53 (initVal -> exp .)
    BIT_WIDTH_NUMBER shift and go to state 132


state 173

    (54) initVal -> { . initVal initVal_repeat }
    (106) lVal -> { . ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> { . ID array_exp_repeat2 lVal_repeat }
    (53) initVal -> . exp
    (54) initVal -> . { initVal initVal_repeat }
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 232
    {               shift and go to state 173
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    initVal                        shift and go to state 231
    exp                            shift and go to state 172
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 174

    (28) array -> [ constExp ] . array
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 46
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

    array                          shift and go to state 233
    empty                          shift and go to state 45

state 175

    (56) cirDecl_repeat -> , cirDef cirDecl_repeat .

    ;               reduce using rule 56 (cirDecl_repeat -> , cirDef cirDecl_repeat .)


state 176

    (39) modDecl -> ID ( module_R_params ) ID . array ;
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 46
    ;               reduce using rule 1 (empty -> .)

    array                          shift and go to state 234
    empty                          shift and go to state 45

state 177

    (45) module_R_params_repeat -> , p_module_R_params_item . module_R_params_repeat
    (44) module_R_params_repeat -> . empty
    (45) module_R_params_repeat -> . , p_module_R_params_item module_R_params_repeat
    (1) empty -> .

    ,               shift and go to state 110
    )               reduce using rule 1 (empty -> .)

    module_R_params_repeat         shift and go to state 235
    empty                          shift and go to state 109

state 178

    (43) p_module_R_params_item -> R_port_def ID ( . ID )

    ID              shift and go to state 236


state 179

    (48) bundleDecl_repeat -> , bundleDef bundleDecl_repeat .

    MODULE          reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    BUNDLE          reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    CONST           reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    ID              reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    INT             reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    FLOAT           reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    REG             reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    WIRE            reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    CLOCK           reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    $end            reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    ;               reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    RETURN          reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    {               reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    MUX             reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    WHEN            reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    IF              reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    FOR             reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    GENERATE        reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    SIGNAL          reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    (               reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    ADD             reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    SUB             reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    NOT             reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    NOTL            reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    INTEGER_CONST   reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    FLOAT_CONST     reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    }               reduce using rule 48 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)


state 180

    (69) funcFParam -> val_type ID . array
    (27) array -> . empty
    (28) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 46
    ,               reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

    array                          shift and go to state 237
    empty                          shift and go to state 45

state 181

    (61) function -> val_type ID ( funcFParams ) . block
    (81) block -> . { block_repeat }

    {               shift and go to state 228

    block                          shift and go to state 238

state 182

    (67) funcFParams -> funcFParam funcFParams_repeat .

    )               reduce using rule 67 (funcFParams -> funcFParam funcFParams_repeat .)


state 183

    (65) funcFParams_repeat -> empty .

    )               reduce using rule 65 (funcFParams_repeat -> empty .)


state 184

    (66) funcFParams_repeat -> , . funcFParam funcFParams_repeat
    (69) funcFParam -> . val_type ID array
    (23) val_type -> . INT
    (24) val_type -> . FLOAT

    INT             shift and go to state 19
    FLOAT           shift and go to state 20

    funcFParam                     shift and go to state 239
    val_type                       shift and go to state 116

state 185

    (38) varDef -> ID array ASSIGN initVal .

    ,               reduce using rule 38 (varDef -> ID array ASSIGN initVal .)
    ;               reduce using rule 38 (varDef -> ID array ASSIGN initVal .)


state 186

    (35) varDef_repeat -> , varDef varDef_repeat .

    ;               reduce using rule 35 (varDef_repeat -> , varDef varDef_repeat .)


state 187

    (75) module -> MODULE ID ( module_para_para port_def . ID p_module_para_port ) block

    ID              shift and go to state 240


state 188

    (165) port_def -> INPUT . cir_type
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    ID              shift and go to state 96

    cir_type                       shift and go to state 241
    cir_basic_type                 shift and go to state 18

state 189

    (166) port_def -> OUTPUT . cir_type
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    ID              shift and go to state 96

    cir_type                       shift and go to state 242
    cir_basic_type                 shift and go to state 18

state 190

    (167) port_def -> INOUT . cir_type
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    ID              shift and go to state 96

    cir_type                       shift and go to state 243
    cir_basic_type                 shift and go to state 18

state 191

    (71) module_para_para -> PARA val_type . ID ,
    (72) module_para_para -> PARA val_type . ID , module_para_para

    ID              shift and go to state 244


state 192

    (78) bundle -> BUNDLE ID ( cir_type ID . bundle_repeat )
    (76) bundle_repeat -> . empty
    (77) bundle_repeat -> . , cir_type ID bundle_repeat
    (1) empty -> .

    ,               shift and go to state 247
    )               reduce using rule 1 (empty -> .)

    bundle_repeat                  shift and go to state 245
    empty                          shift and go to state 246

state 193

    (16) constDecl -> CONST val_type constDef constDecl_repeat ; .

    MODULE          reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    BUNDLE          reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    CONST           reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    ID              reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    INT             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    FLOAT           reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    REG             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    WIRE            reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    CLOCK           reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    $end            reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    ;               reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    RETURN          reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    {               reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    MUX             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    WHEN            reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    IF              reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    FOR             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    GENERATE        reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    SIGNAL          reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    (               reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    ADD             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    SUB             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    NOT             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    NOTL            reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    INTEGER_CONST   reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    FLOAT_CONST     reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    }               reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)


state 194

    (15) constDecl_repeat -> , constDef . constDecl_repeat
    (14) constDecl_repeat -> . empty
    (15) constDecl_repeat -> . , constDef constDecl_repeat
    (1) empty -> .

    ,               shift and go to state 129
    ;               reduce using rule 1 (empty -> .)

    constDecl_repeat               shift and go to state 248
    empty                          shift and go to state 128

state 195

    (29) constDef -> ID array ASSIGN . constInitVal
    (32) constInitVal -> . constExp
    (33) constInitVal -> . { constInitVal constInitVal_repeat }
    (168) constExp -> . exp
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    {               shift and go to state 251
    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    constInitVal                   shift and go to state 249
    constExp                       shift and go to state 250
    exp                            shift and go to state 103
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 196

    (164) lOrExp -> lOrExp LOR lAndExp .
    (162) lAndExp -> lAndExp . LAND redExp
    (163) lOrExp -> lAndExp .

  ! reduce/reduce conflict for LOR resolved using rule 163 (lOrExp -> lAndExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 163 (lOrExp -> lAndExp .)
    ]               reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    )               reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    ,               reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    ;               reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    COLON           reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    }               reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    RETURN          reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    CONST           reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    ID              reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    {               reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    MUX             reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    WHEN            reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    IF              reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    FOR             reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    GENERATE        reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    INT             reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    FLOAT           reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    REG             reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    WIRE            reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    CLOCK           reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    SIGNAL          reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    (               reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    ADD             reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    SUB             reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    NOT             reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    NOTL            reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    INTEGER_CONST   reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    FLOAT_CONST     reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    ELIF            reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    ELSE            reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .)
    LAND            shift and go to state 134
    LOR             reduce using rule 163 (lOrExp -> lAndExp .)
    BIT_WIDTH_NUMBER reduce using rule 163 (lOrExp -> lAndExp .)

  ! LOR             [ reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 164 (lOrExp -> lOrExp LOR lAndExp .) ]


state 197

    (162) lAndExp -> lAndExp LAND redExp .
    (157) redExp -> redExp . AND eqExp
    (158) redExp -> redExp . OR eqExp
    (159) redExp -> redExp . XOR eqExp
    (160) redExp -> redExp . XNOR eqExp
    (161) lAndExp -> redExp .

  ! reduce/reduce conflict for LAND resolved using rule 161 (lAndExp -> redExp .)
  ! reduce/reduce conflict for LOR resolved using rule 161 (lAndExp -> redExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 161 (lAndExp -> redExp .)
    ]               reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    )               reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    ,               reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    ;               reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    COLON           reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    }               reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    RETURN          reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    CONST           reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    ID              reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    {               reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    MUX             reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    WHEN            reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    IF              reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    FOR             reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    GENERATE        reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    INT             reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    FLOAT           reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    REG             reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    WIRE            reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    CLOCK           reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    SIGNAL          reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    (               reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    ADD             reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    SUB             reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    NOT             reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    NOTL            reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    INTEGER_CONST   reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    FLOAT_CONST     reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    ELIF            reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    ELSE            reduce using rule 162 (lAndExp -> lAndExp LAND redExp .)
    AND             shift and go to state 135
    OR              shift and go to state 136
    XOR             shift and go to state 137
    XNOR            shift and go to state 138
    LAND            reduce using rule 161 (lAndExp -> redExp .)
    LOR             reduce using rule 161 (lAndExp -> redExp .)
    BIT_WIDTH_NUMBER reduce using rule 161 (lAndExp -> redExp .)

  ! LAND            [ reduce using rule 162 (lAndExp -> lAndExp LAND redExp .) ]
  ! LOR             [ reduce using rule 162 (lAndExp -> lAndExp LAND redExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 162 (lAndExp -> lAndExp LAND redExp .) ]


state 198

    (157) redExp -> redExp AND eqExp .
    (154) eqExp -> eqExp . EQUAL eqExp
    (155) eqExp -> eqExp . NEQ eqExp
    (156) redExp -> eqExp .

  ! reduce/reduce conflict for AND resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for OR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for XOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for LAND resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 156 (redExp -> eqExp .)
    ]               reduce using rule 157 (redExp -> redExp AND eqExp .)
    )               reduce using rule 157 (redExp -> redExp AND eqExp .)
    ,               reduce using rule 157 (redExp -> redExp AND eqExp .)
    ;               reduce using rule 157 (redExp -> redExp AND eqExp .)
    COLON           reduce using rule 157 (redExp -> redExp AND eqExp .)
    }               reduce using rule 157 (redExp -> redExp AND eqExp .)
    RETURN          reduce using rule 157 (redExp -> redExp AND eqExp .)
    CONST           reduce using rule 157 (redExp -> redExp AND eqExp .)
    ID              reduce using rule 157 (redExp -> redExp AND eqExp .)
    {               reduce using rule 157 (redExp -> redExp AND eqExp .)
    MUX             reduce using rule 157 (redExp -> redExp AND eqExp .)
    WHEN            reduce using rule 157 (redExp -> redExp AND eqExp .)
    IF              reduce using rule 157 (redExp -> redExp AND eqExp .)
    FOR             reduce using rule 157 (redExp -> redExp AND eqExp .)
    GENERATE        reduce using rule 157 (redExp -> redExp AND eqExp .)
    INT             reduce using rule 157 (redExp -> redExp AND eqExp .)
    FLOAT           reduce using rule 157 (redExp -> redExp AND eqExp .)
    REG             reduce using rule 157 (redExp -> redExp AND eqExp .)
    WIRE            reduce using rule 157 (redExp -> redExp AND eqExp .)
    CLOCK           reduce using rule 157 (redExp -> redExp AND eqExp .)
    SIGNAL          reduce using rule 157 (redExp -> redExp AND eqExp .)
    (               reduce using rule 157 (redExp -> redExp AND eqExp .)
    ADD             reduce using rule 157 (redExp -> redExp AND eqExp .)
    SUB             reduce using rule 157 (redExp -> redExp AND eqExp .)
    NOT             reduce using rule 157 (redExp -> redExp AND eqExp .)
    NOTL            reduce using rule 157 (redExp -> redExp AND eqExp .)
    INTEGER_CONST   reduce using rule 157 (redExp -> redExp AND eqExp .)
    FLOAT_CONST     reduce using rule 157 (redExp -> redExp AND eqExp .)
    ELIF            reduce using rule 157 (redExp -> redExp AND eqExp .)
    ELSE            reduce using rule 157 (redExp -> redExp AND eqExp .)
    EQUAL           shift and go to state 139
    NEQ             shift and go to state 140
    AND             reduce using rule 156 (redExp -> eqExp .)
    OR              reduce using rule 156 (redExp -> eqExp .)
    XOR             reduce using rule 156 (redExp -> eqExp .)
    XNOR            reduce using rule 156 (redExp -> eqExp .)
    LAND            reduce using rule 156 (redExp -> eqExp .)
    LOR             reduce using rule 156 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 156 (redExp -> eqExp .)

  ! AND             [ reduce using rule 157 (redExp -> redExp AND eqExp .) ]
  ! OR              [ reduce using rule 157 (redExp -> redExp AND eqExp .) ]
  ! XOR             [ reduce using rule 157 (redExp -> redExp AND eqExp .) ]
  ! XNOR            [ reduce using rule 157 (redExp -> redExp AND eqExp .) ]
  ! LAND            [ reduce using rule 157 (redExp -> redExp AND eqExp .) ]
  ! LOR             [ reduce using rule 157 (redExp -> redExp AND eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 157 (redExp -> redExp AND eqExp .) ]


state 199

    (158) redExp -> redExp OR eqExp .
    (154) eqExp -> eqExp . EQUAL eqExp
    (155) eqExp -> eqExp . NEQ eqExp
    (156) redExp -> eqExp .

  ! reduce/reduce conflict for AND resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for OR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for XOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for LAND resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 156 (redExp -> eqExp .)
    ]               reduce using rule 158 (redExp -> redExp OR eqExp .)
    )               reduce using rule 158 (redExp -> redExp OR eqExp .)
    ,               reduce using rule 158 (redExp -> redExp OR eqExp .)
    ;               reduce using rule 158 (redExp -> redExp OR eqExp .)
    COLON           reduce using rule 158 (redExp -> redExp OR eqExp .)
    }               reduce using rule 158 (redExp -> redExp OR eqExp .)
    RETURN          reduce using rule 158 (redExp -> redExp OR eqExp .)
    CONST           reduce using rule 158 (redExp -> redExp OR eqExp .)
    ID              reduce using rule 158 (redExp -> redExp OR eqExp .)
    {               reduce using rule 158 (redExp -> redExp OR eqExp .)
    MUX             reduce using rule 158 (redExp -> redExp OR eqExp .)
    WHEN            reduce using rule 158 (redExp -> redExp OR eqExp .)
    IF              reduce using rule 158 (redExp -> redExp OR eqExp .)
    FOR             reduce using rule 158 (redExp -> redExp OR eqExp .)
    GENERATE        reduce using rule 158 (redExp -> redExp OR eqExp .)
    INT             reduce using rule 158 (redExp -> redExp OR eqExp .)
    FLOAT           reduce using rule 158 (redExp -> redExp OR eqExp .)
    REG             reduce using rule 158 (redExp -> redExp OR eqExp .)
    WIRE            reduce using rule 158 (redExp -> redExp OR eqExp .)
    CLOCK           reduce using rule 158 (redExp -> redExp OR eqExp .)
    SIGNAL          reduce using rule 158 (redExp -> redExp OR eqExp .)
    (               reduce using rule 158 (redExp -> redExp OR eqExp .)
    ADD             reduce using rule 158 (redExp -> redExp OR eqExp .)
    SUB             reduce using rule 158 (redExp -> redExp OR eqExp .)
    NOT             reduce using rule 158 (redExp -> redExp OR eqExp .)
    NOTL            reduce using rule 158 (redExp -> redExp OR eqExp .)
    INTEGER_CONST   reduce using rule 158 (redExp -> redExp OR eqExp .)
    FLOAT_CONST     reduce using rule 158 (redExp -> redExp OR eqExp .)
    ELIF            reduce using rule 158 (redExp -> redExp OR eqExp .)
    ELSE            reduce using rule 158 (redExp -> redExp OR eqExp .)
    EQUAL           shift and go to state 139
    NEQ             shift and go to state 140
    AND             reduce using rule 156 (redExp -> eqExp .)
    OR              reduce using rule 156 (redExp -> eqExp .)
    XOR             reduce using rule 156 (redExp -> eqExp .)
    XNOR            reduce using rule 156 (redExp -> eqExp .)
    LAND            reduce using rule 156 (redExp -> eqExp .)
    LOR             reduce using rule 156 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 156 (redExp -> eqExp .)

  ! AND             [ reduce using rule 158 (redExp -> redExp OR eqExp .) ]
  ! OR              [ reduce using rule 158 (redExp -> redExp OR eqExp .) ]
  ! XOR             [ reduce using rule 158 (redExp -> redExp OR eqExp .) ]
  ! XNOR            [ reduce using rule 158 (redExp -> redExp OR eqExp .) ]
  ! LAND            [ reduce using rule 158 (redExp -> redExp OR eqExp .) ]
  ! LOR             [ reduce using rule 158 (redExp -> redExp OR eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 158 (redExp -> redExp OR eqExp .) ]


state 200

    (159) redExp -> redExp XOR eqExp .
    (154) eqExp -> eqExp . EQUAL eqExp
    (155) eqExp -> eqExp . NEQ eqExp
    (156) redExp -> eqExp .

  ! reduce/reduce conflict for AND resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for OR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for XOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for LAND resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 156 (redExp -> eqExp .)
    ]               reduce using rule 159 (redExp -> redExp XOR eqExp .)
    )               reduce using rule 159 (redExp -> redExp XOR eqExp .)
    ,               reduce using rule 159 (redExp -> redExp XOR eqExp .)
    ;               reduce using rule 159 (redExp -> redExp XOR eqExp .)
    COLON           reduce using rule 159 (redExp -> redExp XOR eqExp .)
    }               reduce using rule 159 (redExp -> redExp XOR eqExp .)
    RETURN          reduce using rule 159 (redExp -> redExp XOR eqExp .)
    CONST           reduce using rule 159 (redExp -> redExp XOR eqExp .)
    ID              reduce using rule 159 (redExp -> redExp XOR eqExp .)
    {               reduce using rule 159 (redExp -> redExp XOR eqExp .)
    MUX             reduce using rule 159 (redExp -> redExp XOR eqExp .)
    WHEN            reduce using rule 159 (redExp -> redExp XOR eqExp .)
    IF              reduce using rule 159 (redExp -> redExp XOR eqExp .)
    FOR             reduce using rule 159 (redExp -> redExp XOR eqExp .)
    GENERATE        reduce using rule 159 (redExp -> redExp XOR eqExp .)
    INT             reduce using rule 159 (redExp -> redExp XOR eqExp .)
    FLOAT           reduce using rule 159 (redExp -> redExp XOR eqExp .)
    REG             reduce using rule 159 (redExp -> redExp XOR eqExp .)
    WIRE            reduce using rule 159 (redExp -> redExp XOR eqExp .)
    CLOCK           reduce using rule 159 (redExp -> redExp XOR eqExp .)
    SIGNAL          reduce using rule 159 (redExp -> redExp XOR eqExp .)
    (               reduce using rule 159 (redExp -> redExp XOR eqExp .)
    ADD             reduce using rule 159 (redExp -> redExp XOR eqExp .)
    SUB             reduce using rule 159 (redExp -> redExp XOR eqExp .)
    NOT             reduce using rule 159 (redExp -> redExp XOR eqExp .)
    NOTL            reduce using rule 159 (redExp -> redExp XOR eqExp .)
    INTEGER_CONST   reduce using rule 159 (redExp -> redExp XOR eqExp .)
    FLOAT_CONST     reduce using rule 159 (redExp -> redExp XOR eqExp .)
    ELIF            reduce using rule 159 (redExp -> redExp XOR eqExp .)
    ELSE            reduce using rule 159 (redExp -> redExp XOR eqExp .)
    EQUAL           shift and go to state 139
    NEQ             shift and go to state 140
    AND             reduce using rule 156 (redExp -> eqExp .)
    OR              reduce using rule 156 (redExp -> eqExp .)
    XOR             reduce using rule 156 (redExp -> eqExp .)
    XNOR            reduce using rule 156 (redExp -> eqExp .)
    LAND            reduce using rule 156 (redExp -> eqExp .)
    LOR             reduce using rule 156 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 156 (redExp -> eqExp .)

  ! AND             [ reduce using rule 159 (redExp -> redExp XOR eqExp .) ]
  ! OR              [ reduce using rule 159 (redExp -> redExp XOR eqExp .) ]
  ! XOR             [ reduce using rule 159 (redExp -> redExp XOR eqExp .) ]
  ! XNOR            [ reduce using rule 159 (redExp -> redExp XOR eqExp .) ]
  ! LAND            [ reduce using rule 159 (redExp -> redExp XOR eqExp .) ]
  ! LOR             [ reduce using rule 159 (redExp -> redExp XOR eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 159 (redExp -> redExp XOR eqExp .) ]


state 201

    (160) redExp -> redExp XNOR eqExp .
    (154) eqExp -> eqExp . EQUAL eqExp
    (155) eqExp -> eqExp . NEQ eqExp
    (156) redExp -> eqExp .

  ! reduce/reduce conflict for AND resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for OR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for XOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for LAND resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 156 (redExp -> eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 156 (redExp -> eqExp .)
    ]               reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    )               reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    ,               reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    ;               reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    COLON           reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    }               reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    RETURN          reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    CONST           reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    ID              reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    {               reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    MUX             reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    WHEN            reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    IF              reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    FOR             reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    GENERATE        reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    INT             reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    FLOAT           reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    REG             reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    WIRE            reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    CLOCK           reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    SIGNAL          reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    (               reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    ADD             reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    SUB             reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    NOT             reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    NOTL            reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    INTEGER_CONST   reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    FLOAT_CONST     reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    ELIF            reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    ELSE            reduce using rule 160 (redExp -> redExp XNOR eqExp .)
    EQUAL           shift and go to state 139
    NEQ             shift and go to state 140
    AND             reduce using rule 156 (redExp -> eqExp .)
    OR              reduce using rule 156 (redExp -> eqExp .)
    XOR             reduce using rule 156 (redExp -> eqExp .)
    XNOR            reduce using rule 156 (redExp -> eqExp .)
    LAND            reduce using rule 156 (redExp -> eqExp .)
    LOR             reduce using rule 156 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 156 (redExp -> eqExp .)

  ! AND             [ reduce using rule 160 (redExp -> redExp XNOR eqExp .) ]
  ! OR              [ reduce using rule 160 (redExp -> redExp XNOR eqExp .) ]
  ! XOR             [ reduce using rule 160 (redExp -> redExp XNOR eqExp .) ]
  ! XNOR            [ reduce using rule 160 (redExp -> redExp XNOR eqExp .) ]
  ! LAND            [ reduce using rule 160 (redExp -> redExp XNOR eqExp .) ]
  ! LOR             [ reduce using rule 160 (redExp -> redExp XNOR eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 160 (redExp -> redExp XNOR eqExp .) ]


state 202

    (154) eqExp -> eqExp EQUAL eqExp .
    (154) eqExp -> eqExp . EQUAL eqExp
    (155) eqExp -> eqExp . NEQ eqExp
    (156) redExp -> eqExp .

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! reduce/reduce conflict for AND resolved using rule 154 (eqExp -> eqExp EQUAL eqExp .)
  ! reduce/reduce conflict for OR resolved using rule 154 (eqExp -> eqExp EQUAL eqExp .)
  ! reduce/reduce conflict for XOR resolved using rule 154 (eqExp -> eqExp EQUAL eqExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 154 (eqExp -> eqExp EQUAL eqExp .)
  ! reduce/reduce conflict for LAND resolved using rule 154 (eqExp -> eqExp EQUAL eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 154 (eqExp -> eqExp EQUAL eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    AND             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    OR              reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    XOR             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    XNOR            reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    LAND            reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    LOR             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    ]               reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    )               reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    ,               reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    ;               reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    COLON           reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    }               reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    RETURN          reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    CONST           reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    ID              reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    {               reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    MUX             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    WHEN            reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    IF              reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    FOR             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    GENERATE        reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    INT             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    FLOAT           reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    REG             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    WIRE            reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    CLOCK           reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    SIGNAL          reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    (               reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    ADD             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    SUB             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    NOT             reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    NOTL            reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    INTEGER_CONST   reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    FLOAT_CONST     reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    ELIF            reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    ELSE            reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .)
    EQUAL           shift and go to state 139
    NEQ             shift and go to state 140

  ! EQUAL           [ reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .) ]
  ! NEQ             [ reduce using rule 154 (eqExp -> eqExp EQUAL eqExp .) ]
  ! AND             [ reduce using rule 156 (redExp -> eqExp .) ]
  ! OR              [ reduce using rule 156 (redExp -> eqExp .) ]
  ! XOR             [ reduce using rule 156 (redExp -> eqExp .) ]
  ! XNOR            [ reduce using rule 156 (redExp -> eqExp .) ]
  ! LAND            [ reduce using rule 156 (redExp -> eqExp .) ]
  ! LOR             [ reduce using rule 156 (redExp -> eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 156 (redExp -> eqExp .) ]


state 203

    (155) eqExp -> eqExp NEQ eqExp .
    (154) eqExp -> eqExp . EQUAL eqExp
    (155) eqExp -> eqExp . NEQ eqExp
    (156) redExp -> eqExp .

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! reduce/reduce conflict for AND resolved using rule 155 (eqExp -> eqExp NEQ eqExp .)
  ! reduce/reduce conflict for OR resolved using rule 155 (eqExp -> eqExp NEQ eqExp .)
  ! reduce/reduce conflict for XOR resolved using rule 155 (eqExp -> eqExp NEQ eqExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 155 (eqExp -> eqExp NEQ eqExp .)
  ! reduce/reduce conflict for LAND resolved using rule 155 (eqExp -> eqExp NEQ eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 155 (eqExp -> eqExp NEQ eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 155 (eqExp -> eqExp NEQ eqExp .)
    AND             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    OR              reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    XOR             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    XNOR            reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    LAND            reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    LOR             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    ]               reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    )               reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    ,               reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    ;               reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    COLON           reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    }               reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    RETURN          reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    CONST           reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    ID              reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    {               reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    MUX             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    WHEN            reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    IF              reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    FOR             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    GENERATE        reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    INT             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    FLOAT           reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    REG             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    WIRE            reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    CLOCK           reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    SIGNAL          reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    (               reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    ADD             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    SUB             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    NOT             reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    NOTL            reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    INTEGER_CONST   reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    FLOAT_CONST     reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    ELIF            reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    ELSE            reduce using rule 155 (eqExp -> eqExp NEQ eqExp .)
    EQUAL           shift and go to state 139
    NEQ             shift and go to state 140

  ! EQUAL           [ reduce using rule 155 (eqExp -> eqExp NEQ eqExp .) ]
  ! NEQ             [ reduce using rule 155 (eqExp -> eqExp NEQ eqExp .) ]
  ! AND             [ reduce using rule 156 (redExp -> eqExp .) ]
  ! OR              [ reduce using rule 156 (redExp -> eqExp .) ]
  ! XOR             [ reduce using rule 156 (redExp -> eqExp .) ]
  ! XNOR            [ reduce using rule 156 (redExp -> eqExp .) ]
  ! LAND            [ reduce using rule 156 (redExp -> eqExp .) ]
  ! LOR             [ reduce using rule 156 (redExp -> eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 156 (redExp -> eqExp .) ]


state 204

    (149) relExp -> relExp LT addExp .
    (142) addExp -> addExp . ADD mulExp
    (143) addExp -> addExp . SUB mulExp
    (144) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for AND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for OR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 144 (shiftExp -> addExp .)
    ]               reduce using rule 149 (relExp -> relExp LT addExp .)
    )               reduce using rule 149 (relExp -> relExp LT addExp .)
    ,               reduce using rule 149 (relExp -> relExp LT addExp .)
    ;               reduce using rule 149 (relExp -> relExp LT addExp .)
    COLON           reduce using rule 149 (relExp -> relExp LT addExp .)
    }               reduce using rule 149 (relExp -> relExp LT addExp .)
    RETURN          reduce using rule 149 (relExp -> relExp LT addExp .)
    CONST           reduce using rule 149 (relExp -> relExp LT addExp .)
    ID              reduce using rule 149 (relExp -> relExp LT addExp .)
    {               reduce using rule 149 (relExp -> relExp LT addExp .)
    MUX             reduce using rule 149 (relExp -> relExp LT addExp .)
    WHEN            reduce using rule 149 (relExp -> relExp LT addExp .)
    IF              reduce using rule 149 (relExp -> relExp LT addExp .)
    FOR             reduce using rule 149 (relExp -> relExp LT addExp .)
    GENERATE        reduce using rule 149 (relExp -> relExp LT addExp .)
    INT             reduce using rule 149 (relExp -> relExp LT addExp .)
    FLOAT           reduce using rule 149 (relExp -> relExp LT addExp .)
    REG             reduce using rule 149 (relExp -> relExp LT addExp .)
    WIRE            reduce using rule 149 (relExp -> relExp LT addExp .)
    CLOCK           reduce using rule 149 (relExp -> relExp LT addExp .)
    SIGNAL          reduce using rule 149 (relExp -> relExp LT addExp .)
    (               reduce using rule 149 (relExp -> relExp LT addExp .)
    NOT             reduce using rule 149 (relExp -> relExp LT addExp .)
    NOTL            reduce using rule 149 (relExp -> relExp LT addExp .)
    INTEGER_CONST   reduce using rule 149 (relExp -> relExp LT addExp .)
    FLOAT_CONST     reduce using rule 149 (relExp -> relExp LT addExp .)
    ELIF            reduce using rule 149 (relExp -> relExp LT addExp .)
    ELSE            reduce using rule 149 (relExp -> relExp LT addExp .)
    ADD             shift and go to state 148
    SUB             shift and go to state 149
    SLL             reduce using rule 144 (shiftExp -> addExp .)
    SRL             reduce using rule 144 (shiftExp -> addExp .)
    SRA             reduce using rule 144 (shiftExp -> addExp .)
    LT              reduce using rule 144 (shiftExp -> addExp .)
    GT              reduce using rule 144 (shiftExp -> addExp .)
    GE              reduce using rule 144 (shiftExp -> addExp .)
    LE              reduce using rule 144 (shiftExp -> addExp .)
    EQUAL           reduce using rule 144 (shiftExp -> addExp .)
    NEQ             reduce using rule 144 (shiftExp -> addExp .)
    AND             reduce using rule 144 (shiftExp -> addExp .)
    OR              reduce using rule 144 (shiftExp -> addExp .)
    XOR             reduce using rule 144 (shiftExp -> addExp .)
    XNOR            reduce using rule 144 (shiftExp -> addExp .)
    LAND            reduce using rule 144 (shiftExp -> addExp .)
    LOR             reduce using rule 144 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 144 (shiftExp -> addExp .)

  ! LT              [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! GT              [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! GE              [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! LE              [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! EQUAL           [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! NEQ             [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! AND             [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! OR              [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! XOR             [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! XNOR            [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! LAND            [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! LOR             [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! ADD             [ reduce using rule 149 (relExp -> relExp LT addExp .) ]
  ! SUB             [ reduce using rule 149 (relExp -> relExp LT addExp .) ]


state 205

    (150) relExp -> relExp GT addExp .
    (142) addExp -> addExp . ADD mulExp
    (143) addExp -> addExp . SUB mulExp
    (144) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for AND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for OR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 144 (shiftExp -> addExp .)
    ]               reduce using rule 150 (relExp -> relExp GT addExp .)
    )               reduce using rule 150 (relExp -> relExp GT addExp .)
    ,               reduce using rule 150 (relExp -> relExp GT addExp .)
    ;               reduce using rule 150 (relExp -> relExp GT addExp .)
    COLON           reduce using rule 150 (relExp -> relExp GT addExp .)
    }               reduce using rule 150 (relExp -> relExp GT addExp .)
    RETURN          reduce using rule 150 (relExp -> relExp GT addExp .)
    CONST           reduce using rule 150 (relExp -> relExp GT addExp .)
    ID              reduce using rule 150 (relExp -> relExp GT addExp .)
    {               reduce using rule 150 (relExp -> relExp GT addExp .)
    MUX             reduce using rule 150 (relExp -> relExp GT addExp .)
    WHEN            reduce using rule 150 (relExp -> relExp GT addExp .)
    IF              reduce using rule 150 (relExp -> relExp GT addExp .)
    FOR             reduce using rule 150 (relExp -> relExp GT addExp .)
    GENERATE        reduce using rule 150 (relExp -> relExp GT addExp .)
    INT             reduce using rule 150 (relExp -> relExp GT addExp .)
    FLOAT           reduce using rule 150 (relExp -> relExp GT addExp .)
    REG             reduce using rule 150 (relExp -> relExp GT addExp .)
    WIRE            reduce using rule 150 (relExp -> relExp GT addExp .)
    CLOCK           reduce using rule 150 (relExp -> relExp GT addExp .)
    SIGNAL          reduce using rule 150 (relExp -> relExp GT addExp .)
    (               reduce using rule 150 (relExp -> relExp GT addExp .)
    NOT             reduce using rule 150 (relExp -> relExp GT addExp .)
    NOTL            reduce using rule 150 (relExp -> relExp GT addExp .)
    INTEGER_CONST   reduce using rule 150 (relExp -> relExp GT addExp .)
    FLOAT_CONST     reduce using rule 150 (relExp -> relExp GT addExp .)
    ELIF            reduce using rule 150 (relExp -> relExp GT addExp .)
    ELSE            reduce using rule 150 (relExp -> relExp GT addExp .)
    ADD             shift and go to state 148
    SUB             shift and go to state 149
    SLL             reduce using rule 144 (shiftExp -> addExp .)
    SRL             reduce using rule 144 (shiftExp -> addExp .)
    SRA             reduce using rule 144 (shiftExp -> addExp .)
    LT              reduce using rule 144 (shiftExp -> addExp .)
    GT              reduce using rule 144 (shiftExp -> addExp .)
    GE              reduce using rule 144 (shiftExp -> addExp .)
    LE              reduce using rule 144 (shiftExp -> addExp .)
    EQUAL           reduce using rule 144 (shiftExp -> addExp .)
    NEQ             reduce using rule 144 (shiftExp -> addExp .)
    AND             reduce using rule 144 (shiftExp -> addExp .)
    OR              reduce using rule 144 (shiftExp -> addExp .)
    XOR             reduce using rule 144 (shiftExp -> addExp .)
    XNOR            reduce using rule 144 (shiftExp -> addExp .)
    LAND            reduce using rule 144 (shiftExp -> addExp .)
    LOR             reduce using rule 144 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 144 (shiftExp -> addExp .)

  ! LT              [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! GT              [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! GE              [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! LE              [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! EQUAL           [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! NEQ             [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! AND             [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! OR              [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! XOR             [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! XNOR            [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! LAND            [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! LOR             [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! ADD             [ reduce using rule 150 (relExp -> relExp GT addExp .) ]
  ! SUB             [ reduce using rule 150 (relExp -> relExp GT addExp .) ]


state 206

    (151) relExp -> relExp GE addExp .
    (142) addExp -> addExp . ADD mulExp
    (143) addExp -> addExp . SUB mulExp
    (144) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for AND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for OR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 144 (shiftExp -> addExp .)
    ]               reduce using rule 151 (relExp -> relExp GE addExp .)
    )               reduce using rule 151 (relExp -> relExp GE addExp .)
    ,               reduce using rule 151 (relExp -> relExp GE addExp .)
    ;               reduce using rule 151 (relExp -> relExp GE addExp .)
    COLON           reduce using rule 151 (relExp -> relExp GE addExp .)
    }               reduce using rule 151 (relExp -> relExp GE addExp .)
    RETURN          reduce using rule 151 (relExp -> relExp GE addExp .)
    CONST           reduce using rule 151 (relExp -> relExp GE addExp .)
    ID              reduce using rule 151 (relExp -> relExp GE addExp .)
    {               reduce using rule 151 (relExp -> relExp GE addExp .)
    MUX             reduce using rule 151 (relExp -> relExp GE addExp .)
    WHEN            reduce using rule 151 (relExp -> relExp GE addExp .)
    IF              reduce using rule 151 (relExp -> relExp GE addExp .)
    FOR             reduce using rule 151 (relExp -> relExp GE addExp .)
    GENERATE        reduce using rule 151 (relExp -> relExp GE addExp .)
    INT             reduce using rule 151 (relExp -> relExp GE addExp .)
    FLOAT           reduce using rule 151 (relExp -> relExp GE addExp .)
    REG             reduce using rule 151 (relExp -> relExp GE addExp .)
    WIRE            reduce using rule 151 (relExp -> relExp GE addExp .)
    CLOCK           reduce using rule 151 (relExp -> relExp GE addExp .)
    SIGNAL          reduce using rule 151 (relExp -> relExp GE addExp .)
    (               reduce using rule 151 (relExp -> relExp GE addExp .)
    NOT             reduce using rule 151 (relExp -> relExp GE addExp .)
    NOTL            reduce using rule 151 (relExp -> relExp GE addExp .)
    INTEGER_CONST   reduce using rule 151 (relExp -> relExp GE addExp .)
    FLOAT_CONST     reduce using rule 151 (relExp -> relExp GE addExp .)
    ELIF            reduce using rule 151 (relExp -> relExp GE addExp .)
    ELSE            reduce using rule 151 (relExp -> relExp GE addExp .)
    ADD             shift and go to state 148
    SUB             shift and go to state 149
    SLL             reduce using rule 144 (shiftExp -> addExp .)
    SRL             reduce using rule 144 (shiftExp -> addExp .)
    SRA             reduce using rule 144 (shiftExp -> addExp .)
    LT              reduce using rule 144 (shiftExp -> addExp .)
    GT              reduce using rule 144 (shiftExp -> addExp .)
    GE              reduce using rule 144 (shiftExp -> addExp .)
    LE              reduce using rule 144 (shiftExp -> addExp .)
    EQUAL           reduce using rule 144 (shiftExp -> addExp .)
    NEQ             reduce using rule 144 (shiftExp -> addExp .)
    AND             reduce using rule 144 (shiftExp -> addExp .)
    OR              reduce using rule 144 (shiftExp -> addExp .)
    XOR             reduce using rule 144 (shiftExp -> addExp .)
    XNOR            reduce using rule 144 (shiftExp -> addExp .)
    LAND            reduce using rule 144 (shiftExp -> addExp .)
    LOR             reduce using rule 144 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 144 (shiftExp -> addExp .)

  ! LT              [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! GT              [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! GE              [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! LE              [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! EQUAL           [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! NEQ             [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! AND             [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! OR              [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! XOR             [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! XNOR            [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! LAND            [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! LOR             [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! ADD             [ reduce using rule 151 (relExp -> relExp GE addExp .) ]
  ! SUB             [ reduce using rule 151 (relExp -> relExp GE addExp .) ]


state 207

    (152) relExp -> relExp LE addExp .
    (142) addExp -> addExp . ADD mulExp
    (143) addExp -> addExp . SUB mulExp
    (144) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for AND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for OR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 144 (shiftExp -> addExp .)
    ]               reduce using rule 152 (relExp -> relExp LE addExp .)
    )               reduce using rule 152 (relExp -> relExp LE addExp .)
    ,               reduce using rule 152 (relExp -> relExp LE addExp .)
    ;               reduce using rule 152 (relExp -> relExp LE addExp .)
    COLON           reduce using rule 152 (relExp -> relExp LE addExp .)
    }               reduce using rule 152 (relExp -> relExp LE addExp .)
    RETURN          reduce using rule 152 (relExp -> relExp LE addExp .)
    CONST           reduce using rule 152 (relExp -> relExp LE addExp .)
    ID              reduce using rule 152 (relExp -> relExp LE addExp .)
    {               reduce using rule 152 (relExp -> relExp LE addExp .)
    MUX             reduce using rule 152 (relExp -> relExp LE addExp .)
    WHEN            reduce using rule 152 (relExp -> relExp LE addExp .)
    IF              reduce using rule 152 (relExp -> relExp LE addExp .)
    FOR             reduce using rule 152 (relExp -> relExp LE addExp .)
    GENERATE        reduce using rule 152 (relExp -> relExp LE addExp .)
    INT             reduce using rule 152 (relExp -> relExp LE addExp .)
    FLOAT           reduce using rule 152 (relExp -> relExp LE addExp .)
    REG             reduce using rule 152 (relExp -> relExp LE addExp .)
    WIRE            reduce using rule 152 (relExp -> relExp LE addExp .)
    CLOCK           reduce using rule 152 (relExp -> relExp LE addExp .)
    SIGNAL          reduce using rule 152 (relExp -> relExp LE addExp .)
    (               reduce using rule 152 (relExp -> relExp LE addExp .)
    NOT             reduce using rule 152 (relExp -> relExp LE addExp .)
    NOTL            reduce using rule 152 (relExp -> relExp LE addExp .)
    INTEGER_CONST   reduce using rule 152 (relExp -> relExp LE addExp .)
    FLOAT_CONST     reduce using rule 152 (relExp -> relExp LE addExp .)
    ELIF            reduce using rule 152 (relExp -> relExp LE addExp .)
    ELSE            reduce using rule 152 (relExp -> relExp LE addExp .)
    ADD             shift and go to state 148
    SUB             shift and go to state 149
    SLL             reduce using rule 144 (shiftExp -> addExp .)
    SRL             reduce using rule 144 (shiftExp -> addExp .)
    SRA             reduce using rule 144 (shiftExp -> addExp .)
    LT              reduce using rule 144 (shiftExp -> addExp .)
    GT              reduce using rule 144 (shiftExp -> addExp .)
    GE              reduce using rule 144 (shiftExp -> addExp .)
    LE              reduce using rule 144 (shiftExp -> addExp .)
    EQUAL           reduce using rule 144 (shiftExp -> addExp .)
    NEQ             reduce using rule 144 (shiftExp -> addExp .)
    AND             reduce using rule 144 (shiftExp -> addExp .)
    OR              reduce using rule 144 (shiftExp -> addExp .)
    XOR             reduce using rule 144 (shiftExp -> addExp .)
    XNOR            reduce using rule 144 (shiftExp -> addExp .)
    LAND            reduce using rule 144 (shiftExp -> addExp .)
    LOR             reduce using rule 144 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 144 (shiftExp -> addExp .)

  ! LT              [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! GT              [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! GE              [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! LE              [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! EQUAL           [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! NEQ             [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! AND             [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! OR              [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! XOR             [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! XNOR            [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! LAND            [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! LOR             [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! ADD             [ reduce using rule 152 (relExp -> relExp LE addExp .) ]
  ! SUB             [ reduce using rule 152 (relExp -> relExp LE addExp .) ]


state 208

    (145) shiftExp -> shiftExp SLL addExp .
    (142) addExp -> addExp . ADD mulExp
    (143) addExp -> addExp . SUB mulExp
    (144) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for SLL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRA resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for AND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for OR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 144 (shiftExp -> addExp .)
    ]               reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    )               reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    ,               reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    ;               reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    COLON           reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    }               reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    RETURN          reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    CONST           reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    ID              reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    {               reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    MUX             reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    WHEN            reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    IF              reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    FOR             reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    GENERATE        reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    INT             reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    FLOAT           reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    REG             reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    WIRE            reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    CLOCK           reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    SIGNAL          reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    (               reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    NOT             reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    NOTL            reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    INTEGER_CONST   reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    FLOAT_CONST     reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    ELIF            reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    ELSE            reduce using rule 145 (shiftExp -> shiftExp SLL addExp .)
    ADD             shift and go to state 148
    SUB             shift and go to state 149
    SLL             reduce using rule 144 (shiftExp -> addExp .)
    SRL             reduce using rule 144 (shiftExp -> addExp .)
    SRA             reduce using rule 144 (shiftExp -> addExp .)
    LT              reduce using rule 144 (shiftExp -> addExp .)
    GT              reduce using rule 144 (shiftExp -> addExp .)
    GE              reduce using rule 144 (shiftExp -> addExp .)
    LE              reduce using rule 144 (shiftExp -> addExp .)
    EQUAL           reduce using rule 144 (shiftExp -> addExp .)
    NEQ             reduce using rule 144 (shiftExp -> addExp .)
    AND             reduce using rule 144 (shiftExp -> addExp .)
    OR              reduce using rule 144 (shiftExp -> addExp .)
    XOR             reduce using rule 144 (shiftExp -> addExp .)
    XNOR            reduce using rule 144 (shiftExp -> addExp .)
    LAND            reduce using rule 144 (shiftExp -> addExp .)
    LOR             reduce using rule 144 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 144 (shiftExp -> addExp .)

  ! SLL             [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! SRL             [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! SRA             [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! LT              [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! GT              [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! GE              [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! LE              [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! EQUAL           [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! NEQ             [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! AND             [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! OR              [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! XOR             [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! XNOR            [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! LAND            [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! LOR             [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! ADD             [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]
  ! SUB             [ reduce using rule 145 (shiftExp -> shiftExp SLL addExp .) ]


state 209

    (146) shiftExp -> shiftExp SRL addExp .
    (142) addExp -> addExp . ADD mulExp
    (143) addExp -> addExp . SUB mulExp
    (144) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for SLL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRA resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for AND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for OR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 144 (shiftExp -> addExp .)
    ]               reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    )               reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    ,               reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    ;               reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    COLON           reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    }               reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    RETURN          reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    CONST           reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    ID              reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    {               reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    MUX             reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    WHEN            reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    IF              reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    FOR             reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    GENERATE        reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    INT             reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    FLOAT           reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    REG             reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    WIRE            reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    CLOCK           reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    SIGNAL          reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    (               reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    NOT             reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    NOTL            reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    INTEGER_CONST   reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    FLOAT_CONST     reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    ELIF            reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    ELSE            reduce using rule 146 (shiftExp -> shiftExp SRL addExp .)
    ADD             shift and go to state 148
    SUB             shift and go to state 149
    SLL             reduce using rule 144 (shiftExp -> addExp .)
    SRL             reduce using rule 144 (shiftExp -> addExp .)
    SRA             reduce using rule 144 (shiftExp -> addExp .)
    LT              reduce using rule 144 (shiftExp -> addExp .)
    GT              reduce using rule 144 (shiftExp -> addExp .)
    GE              reduce using rule 144 (shiftExp -> addExp .)
    LE              reduce using rule 144 (shiftExp -> addExp .)
    EQUAL           reduce using rule 144 (shiftExp -> addExp .)
    NEQ             reduce using rule 144 (shiftExp -> addExp .)
    AND             reduce using rule 144 (shiftExp -> addExp .)
    OR              reduce using rule 144 (shiftExp -> addExp .)
    XOR             reduce using rule 144 (shiftExp -> addExp .)
    XNOR            reduce using rule 144 (shiftExp -> addExp .)
    LAND            reduce using rule 144 (shiftExp -> addExp .)
    LOR             reduce using rule 144 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 144 (shiftExp -> addExp .)

  ! SLL             [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! SRL             [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! SRA             [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! LT              [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! GT              [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! GE              [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! LE              [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! EQUAL           [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! NEQ             [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! AND             [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! OR              [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! XOR             [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! XNOR            [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! LAND            [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! LOR             [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! ADD             [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]
  ! SUB             [ reduce using rule 146 (shiftExp -> shiftExp SRL addExp .) ]


state 210

    (147) shiftExp -> shiftExp SRA addExp .
    (142) addExp -> addExp . ADD mulExp
    (143) addExp -> addExp . SUB mulExp
    (144) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for SLL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRA resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for AND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for OR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 144 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 144 (shiftExp -> addExp .)
    ]               reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    )               reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    ,               reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    ;               reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    COLON           reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    }               reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    RETURN          reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    CONST           reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    ID              reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    {               reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    MUX             reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    WHEN            reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    IF              reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    FOR             reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    GENERATE        reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    INT             reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    FLOAT           reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    REG             reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    WIRE            reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    CLOCK           reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    SIGNAL          reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    (               reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    NOT             reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    NOTL            reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    INTEGER_CONST   reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    FLOAT_CONST     reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    ELIF            reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    ELSE            reduce using rule 147 (shiftExp -> shiftExp SRA addExp .)
    ADD             shift and go to state 148
    SUB             shift and go to state 149
    SLL             reduce using rule 144 (shiftExp -> addExp .)
    SRL             reduce using rule 144 (shiftExp -> addExp .)
    SRA             reduce using rule 144 (shiftExp -> addExp .)
    LT              reduce using rule 144 (shiftExp -> addExp .)
    GT              reduce using rule 144 (shiftExp -> addExp .)
    GE              reduce using rule 144 (shiftExp -> addExp .)
    LE              reduce using rule 144 (shiftExp -> addExp .)
    EQUAL           reduce using rule 144 (shiftExp -> addExp .)
    NEQ             reduce using rule 144 (shiftExp -> addExp .)
    AND             reduce using rule 144 (shiftExp -> addExp .)
    OR              reduce using rule 144 (shiftExp -> addExp .)
    XOR             reduce using rule 144 (shiftExp -> addExp .)
    XNOR            reduce using rule 144 (shiftExp -> addExp .)
    LAND            reduce using rule 144 (shiftExp -> addExp .)
    LOR             reduce using rule 144 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 144 (shiftExp -> addExp .)

  ! SLL             [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! SRL             [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! SRA             [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! LT              [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! GT              [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! GE              [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! LE              [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! EQUAL           [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! NEQ             [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! AND             [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! OR              [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! XOR             [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! XNOR            [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! LAND            [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! LOR             [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! ADD             [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]
  ! SUB             [ reduce using rule 147 (shiftExp -> shiftExp SRA addExp .) ]


state 211

    (142) addExp -> addExp ADD mulExp .
    (137) mulExp -> mulExp . MUL unaryExp
    (138) mulExp -> mulExp . DIV unaryExp
    (139) mulExp -> mulExp . MOD unaryExp
    (140) mulExp -> mulExp . POWER unaryExp
    (141) addExp -> mulExp .

  ! reduce/reduce conflict for ADD resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for SUB resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for SLL resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for SRL resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for SRA resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for LT resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for GT resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for GE resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for LE resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for AND resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for OR resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for XOR resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for LAND resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for LOR resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 141 (addExp -> mulExp .)
    ]               reduce using rule 142 (addExp -> addExp ADD mulExp .)
    )               reduce using rule 142 (addExp -> addExp ADD mulExp .)
    ,               reduce using rule 142 (addExp -> addExp ADD mulExp .)
    ;               reduce using rule 142 (addExp -> addExp ADD mulExp .)
    COLON           reduce using rule 142 (addExp -> addExp ADD mulExp .)
    }               reduce using rule 142 (addExp -> addExp ADD mulExp .)
    RETURN          reduce using rule 142 (addExp -> addExp ADD mulExp .)
    CONST           reduce using rule 142 (addExp -> addExp ADD mulExp .)
    ID              reduce using rule 142 (addExp -> addExp ADD mulExp .)
    {               reduce using rule 142 (addExp -> addExp ADD mulExp .)
    MUX             reduce using rule 142 (addExp -> addExp ADD mulExp .)
    WHEN            reduce using rule 142 (addExp -> addExp ADD mulExp .)
    IF              reduce using rule 142 (addExp -> addExp ADD mulExp .)
    FOR             reduce using rule 142 (addExp -> addExp ADD mulExp .)
    GENERATE        reduce using rule 142 (addExp -> addExp ADD mulExp .)
    INT             reduce using rule 142 (addExp -> addExp ADD mulExp .)
    FLOAT           reduce using rule 142 (addExp -> addExp ADD mulExp .)
    REG             reduce using rule 142 (addExp -> addExp ADD mulExp .)
    WIRE            reduce using rule 142 (addExp -> addExp ADD mulExp .)
    CLOCK           reduce using rule 142 (addExp -> addExp ADD mulExp .)
    SIGNAL          reduce using rule 142 (addExp -> addExp ADD mulExp .)
    (               reduce using rule 142 (addExp -> addExp ADD mulExp .)
    NOT             reduce using rule 142 (addExp -> addExp ADD mulExp .)
    NOTL            reduce using rule 142 (addExp -> addExp ADD mulExp .)
    INTEGER_CONST   reduce using rule 142 (addExp -> addExp ADD mulExp .)
    FLOAT_CONST     reduce using rule 142 (addExp -> addExp ADD mulExp .)
    ELIF            reduce using rule 142 (addExp -> addExp ADD mulExp .)
    ELSE            reduce using rule 142 (addExp -> addExp ADD mulExp .)
    MUL             shift and go to state 150
    DIV             shift and go to state 151
    MOD             shift and go to state 152
    POWER           shift and go to state 153
    ADD             reduce using rule 141 (addExp -> mulExp .)
    SUB             reduce using rule 141 (addExp -> mulExp .)
    SLL             reduce using rule 141 (addExp -> mulExp .)
    SRL             reduce using rule 141 (addExp -> mulExp .)
    SRA             reduce using rule 141 (addExp -> mulExp .)
    LT              reduce using rule 141 (addExp -> mulExp .)
    GT              reduce using rule 141 (addExp -> mulExp .)
    GE              reduce using rule 141 (addExp -> mulExp .)
    LE              reduce using rule 141 (addExp -> mulExp .)
    EQUAL           reduce using rule 141 (addExp -> mulExp .)
    NEQ             reduce using rule 141 (addExp -> mulExp .)
    AND             reduce using rule 141 (addExp -> mulExp .)
    OR              reduce using rule 141 (addExp -> mulExp .)
    XOR             reduce using rule 141 (addExp -> mulExp .)
    XNOR            reduce using rule 141 (addExp -> mulExp .)
    LAND            reduce using rule 141 (addExp -> mulExp .)
    LOR             reduce using rule 141 (addExp -> mulExp .)
    BIT_WIDTH_NUMBER reduce using rule 141 (addExp -> mulExp .)

  ! ADD             [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! SUB             [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! SLL             [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! SRL             [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! SRA             [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! LT              [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! GT              [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! GE              [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! LE              [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! EQUAL           [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! NEQ             [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! AND             [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! OR              [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! XOR             [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! XNOR            [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! LAND            [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! LOR             [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 142 (addExp -> addExp ADD mulExp .) ]


state 212

    (143) addExp -> addExp SUB mulExp .
    (137) mulExp -> mulExp . MUL unaryExp
    (138) mulExp -> mulExp . DIV unaryExp
    (139) mulExp -> mulExp . MOD unaryExp
    (140) mulExp -> mulExp . POWER unaryExp
    (141) addExp -> mulExp .

  ! reduce/reduce conflict for ADD resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for SUB resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for SLL resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for SRL resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for SRA resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for LT resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for GT resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for GE resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for LE resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for AND resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for OR resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for XOR resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for LAND resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for LOR resolved using rule 141 (addExp -> mulExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 141 (addExp -> mulExp .)
    ]               reduce using rule 143 (addExp -> addExp SUB mulExp .)
    )               reduce using rule 143 (addExp -> addExp SUB mulExp .)
    ,               reduce using rule 143 (addExp -> addExp SUB mulExp .)
    ;               reduce using rule 143 (addExp -> addExp SUB mulExp .)
    COLON           reduce using rule 143 (addExp -> addExp SUB mulExp .)
    }               reduce using rule 143 (addExp -> addExp SUB mulExp .)
    RETURN          reduce using rule 143 (addExp -> addExp SUB mulExp .)
    CONST           reduce using rule 143 (addExp -> addExp SUB mulExp .)
    ID              reduce using rule 143 (addExp -> addExp SUB mulExp .)
    {               reduce using rule 143 (addExp -> addExp SUB mulExp .)
    MUX             reduce using rule 143 (addExp -> addExp SUB mulExp .)
    WHEN            reduce using rule 143 (addExp -> addExp SUB mulExp .)
    IF              reduce using rule 143 (addExp -> addExp SUB mulExp .)
    FOR             reduce using rule 143 (addExp -> addExp SUB mulExp .)
    GENERATE        reduce using rule 143 (addExp -> addExp SUB mulExp .)
    INT             reduce using rule 143 (addExp -> addExp SUB mulExp .)
    FLOAT           reduce using rule 143 (addExp -> addExp SUB mulExp .)
    REG             reduce using rule 143 (addExp -> addExp SUB mulExp .)
    WIRE            reduce using rule 143 (addExp -> addExp SUB mulExp .)
    CLOCK           reduce using rule 143 (addExp -> addExp SUB mulExp .)
    SIGNAL          reduce using rule 143 (addExp -> addExp SUB mulExp .)
    (               reduce using rule 143 (addExp -> addExp SUB mulExp .)
    NOT             reduce using rule 143 (addExp -> addExp SUB mulExp .)
    NOTL            reduce using rule 143 (addExp -> addExp SUB mulExp .)
    INTEGER_CONST   reduce using rule 143 (addExp -> addExp SUB mulExp .)
    FLOAT_CONST     reduce using rule 143 (addExp -> addExp SUB mulExp .)
    ELIF            reduce using rule 143 (addExp -> addExp SUB mulExp .)
    ELSE            reduce using rule 143 (addExp -> addExp SUB mulExp .)
    MUL             shift and go to state 150
    DIV             shift and go to state 151
    MOD             shift and go to state 152
    POWER           shift and go to state 153
    ADD             reduce using rule 141 (addExp -> mulExp .)
    SUB             reduce using rule 141 (addExp -> mulExp .)
    SLL             reduce using rule 141 (addExp -> mulExp .)
    SRL             reduce using rule 141 (addExp -> mulExp .)
    SRA             reduce using rule 141 (addExp -> mulExp .)
    LT              reduce using rule 141 (addExp -> mulExp .)
    GT              reduce using rule 141 (addExp -> mulExp .)
    GE              reduce using rule 141 (addExp -> mulExp .)
    LE              reduce using rule 141 (addExp -> mulExp .)
    EQUAL           reduce using rule 141 (addExp -> mulExp .)
    NEQ             reduce using rule 141 (addExp -> mulExp .)
    AND             reduce using rule 141 (addExp -> mulExp .)
    OR              reduce using rule 141 (addExp -> mulExp .)
    XOR             reduce using rule 141 (addExp -> mulExp .)
    XNOR            reduce using rule 141 (addExp -> mulExp .)
    LAND            reduce using rule 141 (addExp -> mulExp .)
    LOR             reduce using rule 141 (addExp -> mulExp .)
    BIT_WIDTH_NUMBER reduce using rule 141 (addExp -> mulExp .)

  ! ADD             [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! SUB             [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! SLL             [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! SRL             [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! SRA             [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! LT              [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! GT              [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! GE              [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! LE              [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! EQUAL           [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! NEQ             [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! AND             [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! OR              [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! XOR             [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! XNOR            [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! LAND            [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! LOR             [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 143 (addExp -> addExp SUB mulExp .) ]


state 213

    (137) mulExp -> mulExp MUL unaryExp .
    (136) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for AND resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for OR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for XOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 136 (mulExp -> unaryExp .)
    ]               reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    )               reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    ,               reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    ;               reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    COLON           reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    }               reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    RETURN          reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    CONST           reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    ID              reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    {               reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    MUX             reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    WHEN            reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    IF              reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    FOR             reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    GENERATE        reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    INT             reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    FLOAT           reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    REG             reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    WIRE            reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    CLOCK           reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    SIGNAL          reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    (               reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    NOT             reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    NOTL            reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    INTEGER_CONST   reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    FLOAT_CONST     reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    ELIF            reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    ELSE            reduce using rule 137 (mulExp -> mulExp MUL unaryExp .)
    MUL             reduce using rule 136 (mulExp -> unaryExp .)
    DIV             reduce using rule 136 (mulExp -> unaryExp .)
    MOD             reduce using rule 136 (mulExp -> unaryExp .)
    POWER           reduce using rule 136 (mulExp -> unaryExp .)
    ADD             reduce using rule 136 (mulExp -> unaryExp .)
    SUB             reduce using rule 136 (mulExp -> unaryExp .)
    SLL             reduce using rule 136 (mulExp -> unaryExp .)
    SRL             reduce using rule 136 (mulExp -> unaryExp .)
    SRA             reduce using rule 136 (mulExp -> unaryExp .)
    LT              reduce using rule 136 (mulExp -> unaryExp .)
    GT              reduce using rule 136 (mulExp -> unaryExp .)
    GE              reduce using rule 136 (mulExp -> unaryExp .)
    LE              reduce using rule 136 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 136 (mulExp -> unaryExp .)
    NEQ             reduce using rule 136 (mulExp -> unaryExp .)
    AND             reduce using rule 136 (mulExp -> unaryExp .)
    OR              reduce using rule 136 (mulExp -> unaryExp .)
    XOR             reduce using rule 136 (mulExp -> unaryExp .)
    XNOR            reduce using rule 136 (mulExp -> unaryExp .)
    LAND            reduce using rule 136 (mulExp -> unaryExp .)
    LOR             reduce using rule 136 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 136 (mulExp -> unaryExp .)

  ! MUL             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! DIV             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! MOD             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! POWER           [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! ADD             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! SUB             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! SLL             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! SRL             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! SRA             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! LT              [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! GT              [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! GE              [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! LE              [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! EQUAL           [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! NEQ             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! AND             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! OR              [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! XOR             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! XNOR            [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! LAND            [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! LOR             [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 137 (mulExp -> mulExp MUL unaryExp .) ]


state 214

    (138) mulExp -> mulExp DIV unaryExp .
    (136) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for AND resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for OR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for XOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 136 (mulExp -> unaryExp .)
    ]               reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    )               reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    ,               reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    ;               reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    COLON           reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    }               reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    RETURN          reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    CONST           reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    ID              reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    {               reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    MUX             reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    WHEN            reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    IF              reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    FOR             reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    GENERATE        reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    INT             reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    FLOAT           reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    REG             reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    WIRE            reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    CLOCK           reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    SIGNAL          reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    (               reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    NOT             reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    NOTL            reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    INTEGER_CONST   reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    FLOAT_CONST     reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    ELIF            reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    ELSE            reduce using rule 138 (mulExp -> mulExp DIV unaryExp .)
    MUL             reduce using rule 136 (mulExp -> unaryExp .)
    DIV             reduce using rule 136 (mulExp -> unaryExp .)
    MOD             reduce using rule 136 (mulExp -> unaryExp .)
    POWER           reduce using rule 136 (mulExp -> unaryExp .)
    ADD             reduce using rule 136 (mulExp -> unaryExp .)
    SUB             reduce using rule 136 (mulExp -> unaryExp .)
    SLL             reduce using rule 136 (mulExp -> unaryExp .)
    SRL             reduce using rule 136 (mulExp -> unaryExp .)
    SRA             reduce using rule 136 (mulExp -> unaryExp .)
    LT              reduce using rule 136 (mulExp -> unaryExp .)
    GT              reduce using rule 136 (mulExp -> unaryExp .)
    GE              reduce using rule 136 (mulExp -> unaryExp .)
    LE              reduce using rule 136 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 136 (mulExp -> unaryExp .)
    NEQ             reduce using rule 136 (mulExp -> unaryExp .)
    AND             reduce using rule 136 (mulExp -> unaryExp .)
    OR              reduce using rule 136 (mulExp -> unaryExp .)
    XOR             reduce using rule 136 (mulExp -> unaryExp .)
    XNOR            reduce using rule 136 (mulExp -> unaryExp .)
    LAND            reduce using rule 136 (mulExp -> unaryExp .)
    LOR             reduce using rule 136 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 136 (mulExp -> unaryExp .)

  ! MUL             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! DIV             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! MOD             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! POWER           [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! ADD             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! SUB             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! SLL             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! SRL             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! SRA             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! LT              [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! GT              [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! GE              [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! LE              [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! EQUAL           [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! NEQ             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! AND             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! OR              [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! XOR             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! XNOR            [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! LAND            [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! LOR             [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 138 (mulExp -> mulExp DIV unaryExp .) ]


state 215

    (139) mulExp -> mulExp MOD unaryExp .
    (136) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for AND resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for OR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for XOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 136 (mulExp -> unaryExp .)
    ]               reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    )               reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    ,               reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    ;               reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    COLON           reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    }               reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    RETURN          reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    CONST           reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    ID              reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    {               reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    MUX             reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    WHEN            reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    IF              reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    FOR             reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    GENERATE        reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    INT             reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    FLOAT           reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    REG             reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    WIRE            reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    CLOCK           reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    SIGNAL          reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    (               reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    NOT             reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    NOTL            reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    INTEGER_CONST   reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    FLOAT_CONST     reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    ELIF            reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    ELSE            reduce using rule 139 (mulExp -> mulExp MOD unaryExp .)
    MUL             reduce using rule 136 (mulExp -> unaryExp .)
    DIV             reduce using rule 136 (mulExp -> unaryExp .)
    MOD             reduce using rule 136 (mulExp -> unaryExp .)
    POWER           reduce using rule 136 (mulExp -> unaryExp .)
    ADD             reduce using rule 136 (mulExp -> unaryExp .)
    SUB             reduce using rule 136 (mulExp -> unaryExp .)
    SLL             reduce using rule 136 (mulExp -> unaryExp .)
    SRL             reduce using rule 136 (mulExp -> unaryExp .)
    SRA             reduce using rule 136 (mulExp -> unaryExp .)
    LT              reduce using rule 136 (mulExp -> unaryExp .)
    GT              reduce using rule 136 (mulExp -> unaryExp .)
    GE              reduce using rule 136 (mulExp -> unaryExp .)
    LE              reduce using rule 136 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 136 (mulExp -> unaryExp .)
    NEQ             reduce using rule 136 (mulExp -> unaryExp .)
    AND             reduce using rule 136 (mulExp -> unaryExp .)
    OR              reduce using rule 136 (mulExp -> unaryExp .)
    XOR             reduce using rule 136 (mulExp -> unaryExp .)
    XNOR            reduce using rule 136 (mulExp -> unaryExp .)
    LAND            reduce using rule 136 (mulExp -> unaryExp .)
    LOR             reduce using rule 136 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 136 (mulExp -> unaryExp .)

  ! MUL             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! DIV             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! MOD             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! POWER           [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! ADD             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! SUB             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! SLL             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! SRL             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! SRA             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! LT              [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! GT              [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! GE              [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! LE              [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! EQUAL           [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! NEQ             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! AND             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! OR              [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! XOR             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! XNOR            [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! LAND            [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! LOR             [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 139 (mulExp -> mulExp MOD unaryExp .) ]


state 216

    (140) mulExp -> mulExp POWER unaryExp .
    (136) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for AND resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for OR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for XOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for XNOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 136 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 136 (mulExp -> unaryExp .)
    ]               reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    )               reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    ,               reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    ;               reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    COLON           reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    }               reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    RETURN          reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    CONST           reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    ID              reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    {               reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    MUX             reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    WHEN            reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    IF              reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    FOR             reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    GENERATE        reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    INT             reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    FLOAT           reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    REG             reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    WIRE            reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    CLOCK           reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    SIGNAL          reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    (               reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    NOT             reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    NOTL            reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    INTEGER_CONST   reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    FLOAT_CONST     reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    ELIF            reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    ELSE            reduce using rule 140 (mulExp -> mulExp POWER unaryExp .)
    MUL             reduce using rule 136 (mulExp -> unaryExp .)
    DIV             reduce using rule 136 (mulExp -> unaryExp .)
    MOD             reduce using rule 136 (mulExp -> unaryExp .)
    POWER           reduce using rule 136 (mulExp -> unaryExp .)
    ADD             reduce using rule 136 (mulExp -> unaryExp .)
    SUB             reduce using rule 136 (mulExp -> unaryExp .)
    SLL             reduce using rule 136 (mulExp -> unaryExp .)
    SRL             reduce using rule 136 (mulExp -> unaryExp .)
    SRA             reduce using rule 136 (mulExp -> unaryExp .)
    LT              reduce using rule 136 (mulExp -> unaryExp .)
    GT              reduce using rule 136 (mulExp -> unaryExp .)
    GE              reduce using rule 136 (mulExp -> unaryExp .)
    LE              reduce using rule 136 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 136 (mulExp -> unaryExp .)
    NEQ             reduce using rule 136 (mulExp -> unaryExp .)
    AND             reduce using rule 136 (mulExp -> unaryExp .)
    OR              reduce using rule 136 (mulExp -> unaryExp .)
    XOR             reduce using rule 136 (mulExp -> unaryExp .)
    XNOR            reduce using rule 136 (mulExp -> unaryExp .)
    LAND            reduce using rule 136 (mulExp -> unaryExp .)
    LOR             reduce using rule 136 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 136 (mulExp -> unaryExp .)

  ! MUL             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! DIV             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! MOD             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! POWER           [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! ADD             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! SUB             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! SLL             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! SRL             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! SRA             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! LT              [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! GT              [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! GE              [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! LE              [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! EQUAL           [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! NEQ             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! AND             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! OR              [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! XOR             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! XNOR            [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! LAND            [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! LOR             [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 140 (mulExp -> mulExp POWER unaryExp .) ]


state 217

    (124) unaryExp -> ID ( ) .

    MUL             reduce using rule 124 (unaryExp -> ID ( ) .)
    DIV             reduce using rule 124 (unaryExp -> ID ( ) .)
    MOD             reduce using rule 124 (unaryExp -> ID ( ) .)
    POWER           reduce using rule 124 (unaryExp -> ID ( ) .)
    ADD             reduce using rule 124 (unaryExp -> ID ( ) .)
    SUB             reduce using rule 124 (unaryExp -> ID ( ) .)
    SLL             reduce using rule 124 (unaryExp -> ID ( ) .)
    SRL             reduce using rule 124 (unaryExp -> ID ( ) .)
    SRA             reduce using rule 124 (unaryExp -> ID ( ) .)
    LT              reduce using rule 124 (unaryExp -> ID ( ) .)
    GT              reduce using rule 124 (unaryExp -> ID ( ) .)
    GE              reduce using rule 124 (unaryExp -> ID ( ) .)
    LE              reduce using rule 124 (unaryExp -> ID ( ) .)
    EQUAL           reduce using rule 124 (unaryExp -> ID ( ) .)
    NEQ             reduce using rule 124 (unaryExp -> ID ( ) .)
    AND             reduce using rule 124 (unaryExp -> ID ( ) .)
    OR              reduce using rule 124 (unaryExp -> ID ( ) .)
    XOR             reduce using rule 124 (unaryExp -> ID ( ) .)
    XNOR            reduce using rule 124 (unaryExp -> ID ( ) .)
    LAND            reduce using rule 124 (unaryExp -> ID ( ) .)
    LOR             reduce using rule 124 (unaryExp -> ID ( ) .)
    ]               reduce using rule 124 (unaryExp -> ID ( ) .)
    BIT_WIDTH_NUMBER reduce using rule 124 (unaryExp -> ID ( ) .)
    )               reduce using rule 124 (unaryExp -> ID ( ) .)
    ,               reduce using rule 124 (unaryExp -> ID ( ) .)
    ;               reduce using rule 124 (unaryExp -> ID ( ) .)
    COLON           reduce using rule 124 (unaryExp -> ID ( ) .)
    }               reduce using rule 124 (unaryExp -> ID ( ) .)
    RETURN          reduce using rule 124 (unaryExp -> ID ( ) .)
    CONST           reduce using rule 124 (unaryExp -> ID ( ) .)
    ID              reduce using rule 124 (unaryExp -> ID ( ) .)
    {               reduce using rule 124 (unaryExp -> ID ( ) .)
    MUX             reduce using rule 124 (unaryExp -> ID ( ) .)
    WHEN            reduce using rule 124 (unaryExp -> ID ( ) .)
    IF              reduce using rule 124 (unaryExp -> ID ( ) .)
    FOR             reduce using rule 124 (unaryExp -> ID ( ) .)
    GENERATE        reduce using rule 124 (unaryExp -> ID ( ) .)
    INT             reduce using rule 124 (unaryExp -> ID ( ) .)
    FLOAT           reduce using rule 124 (unaryExp -> ID ( ) .)
    REG             reduce using rule 124 (unaryExp -> ID ( ) .)
    WIRE            reduce using rule 124 (unaryExp -> ID ( ) .)
    CLOCK           reduce using rule 124 (unaryExp -> ID ( ) .)
    SIGNAL          reduce using rule 124 (unaryExp -> ID ( ) .)
    (               reduce using rule 124 (unaryExp -> ID ( ) .)
    NOT             reduce using rule 124 (unaryExp -> ID ( ) .)
    NOTL            reduce using rule 124 (unaryExp -> ID ( ) .)
    INTEGER_CONST   reduce using rule 124 (unaryExp -> ID ( ) .)
    FLOAT_CONST     reduce using rule 124 (unaryExp -> ID ( ) .)
    ELIF            reduce using rule 124 (unaryExp -> ID ( ) .)
    ELSE            reduce using rule 124 (unaryExp -> ID ( ) .)


state 218

    (125) unaryExp -> ID ( funcRParams . )

    )               shift and go to state 252


state 219

    (134) funcRParams -> exp .
    (135) funcRParams -> exp . exp_repeat
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER
    (132) exp_repeat -> . empty
    (133) exp_repeat -> . , exp exp_repeat
    (1) empty -> .

  ! reduce/reduce conflict for ) resolved using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER shift and go to state 132
    ,               shift and go to state 255
    )               reduce using rule 1 (empty -> .)

  ! )               [ reduce using rule 134 (funcRParams -> exp .) ]

    exp_repeat                     shift and go to state 253
    empty                          shift and go to state 254

state 220

    (116) array_exp_repeat1 -> [ exp . ] array_exp_repeat1
    (118) array_exp_repeat2 -> [ exp . COLON exp ] array_exp_repeat2
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               shift and go to state 256
    COLON           shift and go to state 257
    BIT_WIDTH_NUMBER shift and go to state 132


state 221

    (110) primaryExp -> ( exp ) .

    MUL             reduce using rule 110 (primaryExp -> ( exp ) .)
    DIV             reduce using rule 110 (primaryExp -> ( exp ) .)
    MOD             reduce using rule 110 (primaryExp -> ( exp ) .)
    POWER           reduce using rule 110 (primaryExp -> ( exp ) .)
    ADD             reduce using rule 110 (primaryExp -> ( exp ) .)
    SUB             reduce using rule 110 (primaryExp -> ( exp ) .)
    SLL             reduce using rule 110 (primaryExp -> ( exp ) .)
    SRL             reduce using rule 110 (primaryExp -> ( exp ) .)
    SRA             reduce using rule 110 (primaryExp -> ( exp ) .)
    LT              reduce using rule 110 (primaryExp -> ( exp ) .)
    GT              reduce using rule 110 (primaryExp -> ( exp ) .)
    GE              reduce using rule 110 (primaryExp -> ( exp ) .)
    LE              reduce using rule 110 (primaryExp -> ( exp ) .)
    EQUAL           reduce using rule 110 (primaryExp -> ( exp ) .)
    NEQ             reduce using rule 110 (primaryExp -> ( exp ) .)
    AND             reduce using rule 110 (primaryExp -> ( exp ) .)
    OR              reduce using rule 110 (primaryExp -> ( exp ) .)
    XOR             reduce using rule 110 (primaryExp -> ( exp ) .)
    XNOR            reduce using rule 110 (primaryExp -> ( exp ) .)
    LAND            reduce using rule 110 (primaryExp -> ( exp ) .)
    LOR             reduce using rule 110 (primaryExp -> ( exp ) .)
    ]               reduce using rule 110 (primaryExp -> ( exp ) .)
    BIT_WIDTH_NUMBER reduce using rule 110 (primaryExp -> ( exp ) .)
    )               reduce using rule 110 (primaryExp -> ( exp ) .)
    ,               reduce using rule 110 (primaryExp -> ( exp ) .)
    ;               reduce using rule 110 (primaryExp -> ( exp ) .)
    COLON           reduce using rule 110 (primaryExp -> ( exp ) .)
    }               reduce using rule 110 (primaryExp -> ( exp ) .)
    RETURN          reduce using rule 110 (primaryExp -> ( exp ) .)
    CONST           reduce using rule 110 (primaryExp -> ( exp ) .)
    ID              reduce using rule 110 (primaryExp -> ( exp ) .)
    {               reduce using rule 110 (primaryExp -> ( exp ) .)
    MUX             reduce using rule 110 (primaryExp -> ( exp ) .)
    WHEN            reduce using rule 110 (primaryExp -> ( exp ) .)
    IF              reduce using rule 110 (primaryExp -> ( exp ) .)
    FOR             reduce using rule 110 (primaryExp -> ( exp ) .)
    GENERATE        reduce using rule 110 (primaryExp -> ( exp ) .)
    INT             reduce using rule 110 (primaryExp -> ( exp ) .)
    FLOAT           reduce using rule 110 (primaryExp -> ( exp ) .)
    REG             reduce using rule 110 (primaryExp -> ( exp ) .)
    WIRE            reduce using rule 110 (primaryExp -> ( exp ) .)
    CLOCK           reduce using rule 110 (primaryExp -> ( exp ) .)
    SIGNAL          reduce using rule 110 (primaryExp -> ( exp ) .)
    (               reduce using rule 110 (primaryExp -> ( exp ) .)
    NOT             reduce using rule 110 (primaryExp -> ( exp ) .)
    NOTL            reduce using rule 110 (primaryExp -> ( exp ) .)
    INTEGER_CONST   reduce using rule 110 (primaryExp -> ( exp ) .)
    FLOAT_CONST     reduce using rule 110 (primaryExp -> ( exp ) .)
    ELIF            reduce using rule 110 (primaryExp -> ( exp ) .)
    ELSE            reduce using rule 110 (primaryExp -> ( exp ) .)


state 222

    (126) unaryExp -> SIGNAL ( unaryExp . )
    (136) mulExp -> unaryExp .

    )               shift and go to state 258
    MUL             reduce using rule 136 (mulExp -> unaryExp .)
    DIV             reduce using rule 136 (mulExp -> unaryExp .)
    MOD             reduce using rule 136 (mulExp -> unaryExp .)
    POWER           reduce using rule 136 (mulExp -> unaryExp .)
    ADD             reduce using rule 136 (mulExp -> unaryExp .)
    SUB             reduce using rule 136 (mulExp -> unaryExp .)
    SLL             reduce using rule 136 (mulExp -> unaryExp .)
    SRL             reduce using rule 136 (mulExp -> unaryExp .)
    SRA             reduce using rule 136 (mulExp -> unaryExp .)
    LT              reduce using rule 136 (mulExp -> unaryExp .)
    GT              reduce using rule 136 (mulExp -> unaryExp .)
    GE              reduce using rule 136 (mulExp -> unaryExp .)
    LE              reduce using rule 136 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 136 (mulExp -> unaryExp .)
    NEQ             reduce using rule 136 (mulExp -> unaryExp .)
    AND             reduce using rule 136 (mulExp -> unaryExp .)
    OR              reduce using rule 136 (mulExp -> unaryExp .)
    XOR             reduce using rule 136 (mulExp -> unaryExp .)
    XNOR            reduce using rule 136 (mulExp -> unaryExp .)
    LAND            reduce using rule 136 (mulExp -> unaryExp .)
    LOR             reduce using rule 136 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 136 (mulExp -> unaryExp .)


state 223

    (109) lVal -> lVal . ID .

    .               reduce using rule 109 (lVal -> lVal . ID .)
    MUL             reduce using rule 109 (lVal -> lVal . ID .)
    DIV             reduce using rule 109 (lVal -> lVal . ID .)
    MOD             reduce using rule 109 (lVal -> lVal . ID .)
    POWER           reduce using rule 109 (lVal -> lVal . ID .)
    ADD             reduce using rule 109 (lVal -> lVal . ID .)
    SUB             reduce using rule 109 (lVal -> lVal . ID .)
    SLL             reduce using rule 109 (lVal -> lVal . ID .)
    SRL             reduce using rule 109 (lVal -> lVal . ID .)
    SRA             reduce using rule 109 (lVal -> lVal . ID .)
    LT              reduce using rule 109 (lVal -> lVal . ID .)
    GT              reduce using rule 109 (lVal -> lVal . ID .)
    GE              reduce using rule 109 (lVal -> lVal . ID .)
    LE              reduce using rule 109 (lVal -> lVal . ID .)
    EQUAL           reduce using rule 109 (lVal -> lVal . ID .)
    NEQ             reduce using rule 109 (lVal -> lVal . ID .)
    AND             reduce using rule 109 (lVal -> lVal . ID .)
    OR              reduce using rule 109 (lVal -> lVal . ID .)
    XOR             reduce using rule 109 (lVal -> lVal . ID .)
    XNOR            reduce using rule 109 (lVal -> lVal . ID .)
    LAND            reduce using rule 109 (lVal -> lVal . ID .)
    LOR             reduce using rule 109 (lVal -> lVal . ID .)
    ]               reduce using rule 109 (lVal -> lVal . ID .)
    BIT_WIDTH_NUMBER reduce using rule 109 (lVal -> lVal . ID .)
    )               reduce using rule 109 (lVal -> lVal . ID .)
    ,               reduce using rule 109 (lVal -> lVal . ID .)
    ;               reduce using rule 109 (lVal -> lVal . ID .)
    COLON           reduce using rule 109 (lVal -> lVal . ID .)
    }               reduce using rule 109 (lVal -> lVal . ID .)
    RETURN          reduce using rule 109 (lVal -> lVal . ID .)
    CONST           reduce using rule 109 (lVal -> lVal . ID .)
    ID              reduce using rule 109 (lVal -> lVal . ID .)
    {               reduce using rule 109 (lVal -> lVal . ID .)
    MUX             reduce using rule 109 (lVal -> lVal . ID .)
    WHEN            reduce using rule 109 (lVal -> lVal . ID .)
    IF              reduce using rule 109 (lVal -> lVal . ID .)
    FOR             reduce using rule 109 (lVal -> lVal . ID .)
    GENERATE        reduce using rule 109 (lVal -> lVal . ID .)
    INT             reduce using rule 109 (lVal -> lVal . ID .)
    FLOAT           reduce using rule 109 (lVal -> lVal . ID .)
    REG             reduce using rule 109 (lVal -> lVal . ID .)
    WIRE            reduce using rule 109 (lVal -> lVal . ID .)
    CLOCK           reduce using rule 109 (lVal -> lVal . ID .)
    SIGNAL          reduce using rule 109 (lVal -> lVal . ID .)
    (               reduce using rule 109 (lVal -> lVal . ID .)
    NOT             reduce using rule 109 (lVal -> lVal . ID .)
    NOTL            reduce using rule 109 (lVal -> lVal . ID .)
    INTEGER_CONST   reduce using rule 109 (lVal -> lVal . ID .)
    FLOAT_CONST     reduce using rule 109 (lVal -> lVal . ID .)
    ELIF            reduce using rule 109 (lVal -> lVal . ID .)
    ELSE            reduce using rule 109 (lVal -> lVal . ID .)
    ASSIGN          reduce using rule 109 (lVal -> lVal . ID .)
    CONNECT         reduce using rule 109 (lVal -> lVal . ID .)


state 224

    (106) lVal -> { ID array_exp_repeat1 . lVal_repeat }
    (113) lVal_repeat -> . empty
    (114) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

    ,               shift and go to state 261
    }               reduce using rule 1 (empty -> .)

    lVal_repeat                    shift and go to state 259
    empty                          shift and go to state 260

state 225

    (107) lVal -> { ID array_exp_repeat2 . lVal_repeat }
    (113) lVal_repeat -> . empty
    (114) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

    ,               shift and go to state 261
    }               reduce using rule 1 (empty -> .)

    lVal_repeat                    shift and go to state 262
    empty                          shift and go to state 260

state 226

    (108) lVal -> MUX ( exp . , exp , exp )
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ,               shift and go to state 263
    BIT_WIDTH_NUMBER shift and go to state 132


state 227

    (60) cir_function -> cir_type ID ( cir_funcFParams ) block .

    MODULE          reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    BUNDLE          reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    CONST           reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    ID              reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    INT             reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    FLOAT           reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    REG             reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    WIRE            reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    CLOCK           reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    $end            reduce using rule 60 (cir_function -> cir_type ID ( cir_funcFParams ) block .)


state 228

    (81) block -> { . block_repeat }
    (79) block_repeat -> . empty
    (80) block_repeat -> . blockItem block_repeat
    (1) empty -> .
    (82) blockItem -> . decl
    (83) blockItem -> . stmt
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    }               reduce using rule 1 (empty -> .)
    ;               shift and go to state 272
    RETURN          shift and go to state 277
    CONST           shift and go to state 17
    ID              shift and go to state 280
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    block_repeat                   shift and go to state 265
    empty                          shift and go to state 266
    blockItem                      shift and go to state 267
    decl                           shift and go to state 268
    stmt                           shift and go to state 269
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    lVal                           shift and go to state 270
    exp                            shift and go to state 271
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    val_type                       shift and go to state 278
    cir_type                       shift and go to state 279
    lOrExp                         shift and go to state 70
    cir_basic_type                 shift and go to state 18
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 229

    (63) cir_funcFParams_repeat -> , cir_funcFParam . cir_funcFParams_repeat
    (62) cir_funcFParams_repeat -> . empty
    (63) cir_funcFParams_repeat -> . , cir_funcFParam cir_funcFParams_repeat
    (1) empty -> .

    ,               shift and go to state 169
    )               reduce using rule 1 (empty -> .)

    cir_funcFParams_repeat         shift and go to state 285
    empty                          shift and go to state 168

state 230

    (68) cir_funcFParam -> type_def ID array .

    ,               reduce using rule 68 (cir_funcFParam -> type_def ID array .)
    )               reduce using rule 68 (cir_funcFParam -> type_def ID array .)


state 231

    (54) initVal -> { initVal . initVal_repeat }
    (51) initVal_repeat -> . empty
    (52) initVal_repeat -> . , initVal initVal_repeat
    (1) empty -> .

    ,               shift and go to state 288
    }               reduce using rule 1 (empty -> .)

    initVal_repeat                 shift and go to state 286
    empty                          shift and go to state 287

state 232

    (106) lVal -> { ID . array_exp_repeat1 lVal_repeat }
    (107) lVal -> { ID . array_exp_repeat2 lVal_repeat }
    (124) unaryExp -> ID . ( )
    (125) unaryExp -> ID . ( funcRParams )
    (104) lVal -> ID . array_exp_repeat1
    (105) lVal -> ID . array_exp_repeat2
    (115) array_exp_repeat1 -> . empty
    (116) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (117) array_exp_repeat2 -> . empty
    (118) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

    (               shift and go to state 154
    [               shift and go to state 158
    ,               reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)

    array_exp_repeat1              shift and go to state 289
    array_exp_repeat2              shift and go to state 290
    empty                          shift and go to state 157

state 233

    (28) array -> [ constExp ] array .

    ASSIGN          reduce using rule 28 (array -> [ constExp ] array .)
    ,               reduce using rule 28 (array -> [ constExp ] array .)
    ;               reduce using rule 28 (array -> [ constExp ] array .)
    MODULE          reduce using rule 28 (array -> [ constExp ] array .)
    BUNDLE          reduce using rule 28 (array -> [ constExp ] array .)
    CONST           reduce using rule 28 (array -> [ constExp ] array .)
    ID              reduce using rule 28 (array -> [ constExp ] array .)
    INT             reduce using rule 28 (array -> [ constExp ] array .)
    FLOAT           reduce using rule 28 (array -> [ constExp ] array .)
    REG             reduce using rule 28 (array -> [ constExp ] array .)
    WIRE            reduce using rule 28 (array -> [ constExp ] array .)
    CLOCK           reduce using rule 28 (array -> [ constExp ] array .)
    $end            reduce using rule 28 (array -> [ constExp ] array .)
    RETURN          reduce using rule 28 (array -> [ constExp ] array .)
    {               reduce using rule 28 (array -> [ constExp ] array .)
    MUX             reduce using rule 28 (array -> [ constExp ] array .)
    WHEN            reduce using rule 28 (array -> [ constExp ] array .)
    IF              reduce using rule 28 (array -> [ constExp ] array .)
    FOR             reduce using rule 28 (array -> [ constExp ] array .)
    GENERATE        reduce using rule 28 (array -> [ constExp ] array .)
    SIGNAL          reduce using rule 28 (array -> [ constExp ] array .)
    (               reduce using rule 28 (array -> [ constExp ] array .)
    ADD             reduce using rule 28 (array -> [ constExp ] array .)
    SUB             reduce using rule 28 (array -> [ constExp ] array .)
    NOT             reduce using rule 28 (array -> [ constExp ] array .)
    NOTL            reduce using rule 28 (array -> [ constExp ] array .)
    INTEGER_CONST   reduce using rule 28 (array -> [ constExp ] array .)
    FLOAT_CONST     reduce using rule 28 (array -> [ constExp ] array .)
    }               reduce using rule 28 (array -> [ constExp ] array .)
    )               reduce using rule 28 (array -> [ constExp ] array .)


state 234

    (39) modDecl -> ID ( module_R_params ) ID array . ;

    ;               shift and go to state 291


state 235

    (45) module_R_params_repeat -> , p_module_R_params_item module_R_params_repeat .

    )               reduce using rule 45 (module_R_params_repeat -> , p_module_R_params_item module_R_params_repeat .)


state 236

    (43) p_module_R_params_item -> R_port_def ID ( ID . )

    )               shift and go to state 292


state 237

    (69) funcFParam -> val_type ID array .

    ,               reduce using rule 69 (funcFParam -> val_type ID array .)
    )               reduce using rule 69 (funcFParam -> val_type ID array .)


state 238

    (61) function -> val_type ID ( funcFParams ) block .

    MODULE          reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)
    BUNDLE          reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)
    CONST           reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)
    ID              reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)
    INT             reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)
    FLOAT           reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)
    REG             reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)
    WIRE            reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)
    CLOCK           reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)
    $end            reduce using rule 61 (function -> val_type ID ( funcFParams ) block .)


state 239

    (66) funcFParams_repeat -> , funcFParam . funcFParams_repeat
    (65) funcFParams_repeat -> . empty
    (66) funcFParams_repeat -> . , funcFParam funcFParams_repeat
    (1) empty -> .

    ,               shift and go to state 184
    )               reduce using rule 1 (empty -> .)

    funcFParams_repeat             shift and go to state 293
    empty                          shift and go to state 183

state 240

    (75) module -> MODULE ID ( module_para_para port_def ID . p_module_para_port ) block
    (73) p_module_para_port -> . empty
    (74) p_module_para_port -> . , port_def ID p_module_para_port
    (1) empty -> .

    ,               shift and go to state 296
    )               reduce using rule 1 (empty -> .)

    p_module_para_port             shift and go to state 294
    empty                          shift and go to state 295

state 241

    (165) port_def -> INPUT cir_type .

    ID              reduce using rule 165 (port_def -> INPUT cir_type .)


state 242

    (166) port_def -> OUTPUT cir_type .

    ID              reduce using rule 166 (port_def -> OUTPUT cir_type .)


state 243

    (167) port_def -> INOUT cir_type .

    ID              reduce using rule 167 (port_def -> INOUT cir_type .)


state 244

    (71) module_para_para -> PARA val_type ID . ,
    (72) module_para_para -> PARA val_type ID . , module_para_para

    ,               shift and go to state 297


state 245

    (78) bundle -> BUNDLE ID ( cir_type ID bundle_repeat . )

    )               shift and go to state 298


state 246

    (76) bundle_repeat -> empty .

    )               reduce using rule 76 (bundle_repeat -> empty .)


state 247

    (77) bundle_repeat -> , . cir_type ID bundle_repeat
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID

    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    ID              shift and go to state 96

    cir_type                       shift and go to state 299
    cir_basic_type                 shift and go to state 18

state 248

    (15) constDecl_repeat -> , constDef constDecl_repeat .

    ;               reduce using rule 15 (constDecl_repeat -> , constDef constDecl_repeat .)


state 249

    (29) constDef -> ID array ASSIGN constInitVal .

    ,               reduce using rule 29 (constDef -> ID array ASSIGN constInitVal .)
    ;               reduce using rule 29 (constDef -> ID array ASSIGN constInitVal .)


state 250

    (32) constInitVal -> constExp .

    ,               reduce using rule 32 (constInitVal -> constExp .)
    ;               reduce using rule 32 (constInitVal -> constExp .)
    }               reduce using rule 32 (constInitVal -> constExp .)


state 251

    (33) constInitVal -> { . constInitVal constInitVal_repeat }
    (106) lVal -> { . ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> { . ID array_exp_repeat2 lVal_repeat }
    (32) constInitVal -> . constExp
    (33) constInitVal -> . { constInitVal constInitVal_repeat }
    (168) constExp -> . exp
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 232
    {               shift and go to state 251
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    constInitVal                   shift and go to state 300
    constExp                       shift and go to state 250
    exp                            shift and go to state 103
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 252

    (125) unaryExp -> ID ( funcRParams ) .

    MUL             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    DIV             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    MOD             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    POWER           reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    ADD             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    SUB             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    SLL             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    SRL             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    SRA             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    LT              reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    GT              reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    GE              reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    LE              reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    EQUAL           reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    NEQ             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    AND             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    OR              reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    XOR             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    XNOR            reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    LAND            reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    LOR             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    ]               reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    BIT_WIDTH_NUMBER reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    )               reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    ,               reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    ;               reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    COLON           reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    }               reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    RETURN          reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    CONST           reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    ID              reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    {               reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    MUX             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    WHEN            reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    IF              reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    FOR             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    GENERATE        reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    INT             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    FLOAT           reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    REG             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    WIRE            reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    CLOCK           reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    SIGNAL          reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    (               reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    NOT             reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    NOTL            reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    INTEGER_CONST   reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    FLOAT_CONST     reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    ELIF            reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)
    ELSE            reduce using rule 125 (unaryExp -> ID ( funcRParams ) .)


state 253

    (135) funcRParams -> exp exp_repeat .

    )               reduce using rule 135 (funcRParams -> exp exp_repeat .)


state 254

    (132) exp_repeat -> empty .

    )               reduce using rule 132 (exp_repeat -> empty .)


state 255

    (133) exp_repeat -> , . exp exp_repeat
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 301
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 256

    (116) array_exp_repeat1 -> [ exp ] . array_exp_repeat1
    (115) array_exp_repeat1 -> . empty
    (116) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (1) empty -> .

    [               shift and go to state 302
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    ]               reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    COLON           reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    ELIF            reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)

    array_exp_repeat1              shift and go to state 303
    empty                          shift and go to state 304

state 257

    (118) array_exp_repeat2 -> [ exp COLON . exp ] array_exp_repeat2
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 305
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 258

    (126) unaryExp -> SIGNAL ( unaryExp ) .

    MUL             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    DIV             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    MOD             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    POWER           reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    ADD             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    SUB             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    SLL             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    SRL             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    SRA             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    LT              reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    GT              reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    GE              reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    LE              reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    EQUAL           reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    NEQ             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    AND             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    OR              reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    XOR             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    XNOR            reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    LAND            reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    LOR             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    ]               reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    BIT_WIDTH_NUMBER reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    )               reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    ,               reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    ;               reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    COLON           reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    }               reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    RETURN          reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    CONST           reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    ID              reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    {               reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    MUX             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    WHEN            reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    IF              reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    FOR             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    GENERATE        reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    INT             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    FLOAT           reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    REG             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    WIRE            reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    CLOCK           reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    SIGNAL          reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    (               reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    NOT             reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    NOTL            reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    INTEGER_CONST   reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    FLOAT_CONST     reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    ELIF            reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)
    ELSE            reduce using rule 126 (unaryExp -> SIGNAL ( unaryExp ) .)


state 259

    (106) lVal -> { ID array_exp_repeat1 lVal_repeat . }

    }               shift and go to state 306


state 260

    (113) lVal_repeat -> empty .

    }               reduce using rule 113 (lVal_repeat -> empty .)


state 261

    (114) lVal_repeat -> , . lVal lVal_repeat
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID

    ID              shift and go to state 308
    {               shift and go to state 90
    MUX             shift and go to state 91

    lVal                           shift and go to state 307

state 262

    (107) lVal -> { ID array_exp_repeat2 lVal_repeat . }

    }               shift and go to state 309


state 263

    (108) lVal -> MUX ( exp , . exp , exp )
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 310
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 264

    (106) lVal -> { . ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> { . ID array_exp_repeat2 lVal_repeat }
    (81) block -> { . block_repeat }
    (79) block_repeat -> . empty
    (80) block_repeat -> . blockItem block_repeat
    (1) empty -> .
    (82) blockItem -> . decl
    (83) blockItem -> . stmt
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 311
    }               reduce using rule 1 (empty -> .)
    ;               shift and go to state 272
    RETURN          shift and go to state 277
    CONST           shift and go to state 17
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    block_repeat                   shift and go to state 265
    empty                          shift and go to state 266
    blockItem                      shift and go to state 267
    decl                           shift and go to state 268
    stmt                           shift and go to state 269
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    lVal                           shift and go to state 270
    exp                            shift and go to state 271
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    val_type                       shift and go to state 278
    cir_type                       shift and go to state 279
    lOrExp                         shift and go to state 70
    cir_basic_type                 shift and go to state 18
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 265

    (81) block -> { block_repeat . }

    }               shift and go to state 312


state 266

    (79) block_repeat -> empty .

    }               reduce using rule 79 (block_repeat -> empty .)


state 267

    (80) block_repeat -> blockItem . block_repeat
    (79) block_repeat -> . empty
    (80) block_repeat -> . blockItem block_repeat
    (1) empty -> .
    (82) blockItem -> . decl
    (83) blockItem -> . stmt
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (57) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (39) modDecl -> . ID ( module_R_params ) ID array ;
    (49) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (23) val_type -> . INT
    (24) val_type -> . FLOAT
    (21) cir_type -> . cir_basic_type
    (22) cir_type -> . cir_basic_type [ exp ]
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (20) cir_basic_type -> . ID
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    }               reduce using rule 1 (empty -> .)
    ;               shift and go to state 272
    RETURN          shift and go to state 277
    CONST           shift and go to state 17
    ID              shift and go to state 280
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    REG             shift and go to state 21
    WIRE            shift and go to state 22
    CLOCK           shift and go to state 23
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    blockItem                      shift and go to state 267
    block_repeat                   shift and go to state 313
    empty                          shift and go to state 266
    decl                           shift and go to state 268
    stmt                           shift and go to state 269
    constDecl                      shift and go to state 7
    varDecl                        shift and go to state 8
    cirDecl                        shift and go to state 9
    modDecl                        shift and go to state 10
    bundleDecl                     shift and go to state 11
    lVal                           shift and go to state 270
    exp                            shift and go to state 271
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    val_type                       shift and go to state 278
    cir_type                       shift and go to state 279
    lOrExp                         shift and go to state 70
    cir_basic_type                 shift and go to state 18
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 268

    (82) blockItem -> decl .

    ;               reduce using rule 82 (blockItem -> decl .)
    RETURN          reduce using rule 82 (blockItem -> decl .)
    CONST           reduce using rule 82 (blockItem -> decl .)
    ID              reduce using rule 82 (blockItem -> decl .)
    {               reduce using rule 82 (blockItem -> decl .)
    MUX             reduce using rule 82 (blockItem -> decl .)
    WHEN            reduce using rule 82 (blockItem -> decl .)
    IF              reduce using rule 82 (blockItem -> decl .)
    FOR             reduce using rule 82 (blockItem -> decl .)
    GENERATE        reduce using rule 82 (blockItem -> decl .)
    INT             reduce using rule 82 (blockItem -> decl .)
    FLOAT           reduce using rule 82 (blockItem -> decl .)
    REG             reduce using rule 82 (blockItem -> decl .)
    WIRE            reduce using rule 82 (blockItem -> decl .)
    CLOCK           reduce using rule 82 (blockItem -> decl .)
    SIGNAL          reduce using rule 82 (blockItem -> decl .)
    (               reduce using rule 82 (blockItem -> decl .)
    ADD             reduce using rule 82 (blockItem -> decl .)
    SUB             reduce using rule 82 (blockItem -> decl .)
    NOT             reduce using rule 82 (blockItem -> decl .)
    NOTL            reduce using rule 82 (blockItem -> decl .)
    INTEGER_CONST   reduce using rule 82 (blockItem -> decl .)
    FLOAT_CONST     reduce using rule 82 (blockItem -> decl .)
    }               reduce using rule 82 (blockItem -> decl .)


state 269

    (83) blockItem -> stmt .

    ;               reduce using rule 83 (blockItem -> stmt .)
    RETURN          reduce using rule 83 (blockItem -> stmt .)
    CONST           reduce using rule 83 (blockItem -> stmt .)
    ID              reduce using rule 83 (blockItem -> stmt .)
    {               reduce using rule 83 (blockItem -> stmt .)
    MUX             reduce using rule 83 (blockItem -> stmt .)
    WHEN            reduce using rule 83 (blockItem -> stmt .)
    IF              reduce using rule 83 (blockItem -> stmt .)
    FOR             reduce using rule 83 (blockItem -> stmt .)
    GENERATE        reduce using rule 83 (blockItem -> stmt .)
    INT             reduce using rule 83 (blockItem -> stmt .)
    FLOAT           reduce using rule 83 (blockItem -> stmt .)
    REG             reduce using rule 83 (blockItem -> stmt .)
    WIRE            reduce using rule 83 (blockItem -> stmt .)
    CLOCK           reduce using rule 83 (blockItem -> stmt .)
    SIGNAL          reduce using rule 83 (blockItem -> stmt .)
    (               reduce using rule 83 (blockItem -> stmt .)
    ADD             reduce using rule 83 (blockItem -> stmt .)
    SUB             reduce using rule 83 (blockItem -> stmt .)
    NOT             reduce using rule 83 (blockItem -> stmt .)
    NOTL            reduce using rule 83 (blockItem -> stmt .)
    INTEGER_CONST   reduce using rule 83 (blockItem -> stmt .)
    FLOAT_CONST     reduce using rule 83 (blockItem -> stmt .)
    }               reduce using rule 83 (blockItem -> stmt .)


state 270

    (84) stmt -> lVal . ASSIGN exp ;
    (85) stmt -> lVal . CONNECT exp ;
    (109) lVal -> lVal . . ID
    (111) primaryExp -> lVal .

    ASSIGN          shift and go to state 314
    CONNECT         shift and go to state 315
    .               shift and go to state 163
    MUL             reduce using rule 111 (primaryExp -> lVal .)
    DIV             reduce using rule 111 (primaryExp -> lVal .)
    MOD             reduce using rule 111 (primaryExp -> lVal .)
    POWER           reduce using rule 111 (primaryExp -> lVal .)
    ADD             reduce using rule 111 (primaryExp -> lVal .)
    SUB             reduce using rule 111 (primaryExp -> lVal .)
    SLL             reduce using rule 111 (primaryExp -> lVal .)
    SRL             reduce using rule 111 (primaryExp -> lVal .)
    SRA             reduce using rule 111 (primaryExp -> lVal .)
    LT              reduce using rule 111 (primaryExp -> lVal .)
    GT              reduce using rule 111 (primaryExp -> lVal .)
    GE              reduce using rule 111 (primaryExp -> lVal .)
    LE              reduce using rule 111 (primaryExp -> lVal .)
    EQUAL           reduce using rule 111 (primaryExp -> lVal .)
    NEQ             reduce using rule 111 (primaryExp -> lVal .)
    AND             reduce using rule 111 (primaryExp -> lVal .)
    OR              reduce using rule 111 (primaryExp -> lVal .)
    XOR             reduce using rule 111 (primaryExp -> lVal .)
    XNOR            reduce using rule 111 (primaryExp -> lVal .)
    LAND            reduce using rule 111 (primaryExp -> lVal .)
    LOR             reduce using rule 111 (primaryExp -> lVal .)
    BIT_WIDTH_NUMBER reduce using rule 111 (primaryExp -> lVal .)
    ;               reduce using rule 111 (primaryExp -> lVal .)
    RETURN          reduce using rule 111 (primaryExp -> lVal .)
    CONST           reduce using rule 111 (primaryExp -> lVal .)
    ID              reduce using rule 111 (primaryExp -> lVal .)
    {               reduce using rule 111 (primaryExp -> lVal .)
    MUX             reduce using rule 111 (primaryExp -> lVal .)
    WHEN            reduce using rule 111 (primaryExp -> lVal .)
    IF              reduce using rule 111 (primaryExp -> lVal .)
    FOR             reduce using rule 111 (primaryExp -> lVal .)
    GENERATE        reduce using rule 111 (primaryExp -> lVal .)
    INT             reduce using rule 111 (primaryExp -> lVal .)
    FLOAT           reduce using rule 111 (primaryExp -> lVal .)
    REG             reduce using rule 111 (primaryExp -> lVal .)
    WIRE            reduce using rule 111 (primaryExp -> lVal .)
    CLOCK           reduce using rule 111 (primaryExp -> lVal .)
    SIGNAL          reduce using rule 111 (primaryExp -> lVal .)
    (               reduce using rule 111 (primaryExp -> lVal .)
    NOT             reduce using rule 111 (primaryExp -> lVal .)
    NOTL            reduce using rule 111 (primaryExp -> lVal .)
    INTEGER_CONST   reduce using rule 111 (primaryExp -> lVal .)
    FLOAT_CONST     reduce using rule 111 (primaryExp -> lVal .)
    }               reduce using rule 111 (primaryExp -> lVal .)
    ELIF            reduce using rule 111 (primaryExp -> lVal .)
    ELSE            reduce using rule 111 (primaryExp -> lVal .)
    )               reduce using rule 111 (primaryExp -> lVal .)


state 271

    (87) stmt -> exp .
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               reduce using rule 87 (stmt -> exp .)
    RETURN          reduce using rule 87 (stmt -> exp .)
    CONST           reduce using rule 87 (stmt -> exp .)
    ID              reduce using rule 87 (stmt -> exp .)
    {               reduce using rule 87 (stmt -> exp .)
    MUX             reduce using rule 87 (stmt -> exp .)
    WHEN            reduce using rule 87 (stmt -> exp .)
    IF              reduce using rule 87 (stmt -> exp .)
    FOR             reduce using rule 87 (stmt -> exp .)
    GENERATE        reduce using rule 87 (stmt -> exp .)
    INT             reduce using rule 87 (stmt -> exp .)
    FLOAT           reduce using rule 87 (stmt -> exp .)
    REG             reduce using rule 87 (stmt -> exp .)
    WIRE            reduce using rule 87 (stmt -> exp .)
    CLOCK           reduce using rule 87 (stmt -> exp .)
    SIGNAL          reduce using rule 87 (stmt -> exp .)
    (               reduce using rule 87 (stmt -> exp .)
    ADD             reduce using rule 87 (stmt -> exp .)
    SUB             reduce using rule 87 (stmt -> exp .)
    NOT             reduce using rule 87 (stmt -> exp .)
    NOTL            reduce using rule 87 (stmt -> exp .)
    INTEGER_CONST   reduce using rule 87 (stmt -> exp .)
    FLOAT_CONST     reduce using rule 87 (stmt -> exp .)
    }               reduce using rule 87 (stmt -> exp .)
    ELIF            reduce using rule 87 (stmt -> exp .)
    ELSE            reduce using rule 87 (stmt -> exp .)
    )               reduce using rule 87 (stmt -> exp .)
    BIT_WIDTH_NUMBER shift and go to state 132


state 272

    (86) stmt -> ; .

    ;               reduce using rule 86 (stmt -> ; .)
    RETURN          reduce using rule 86 (stmt -> ; .)
    CONST           reduce using rule 86 (stmt -> ; .)
    ID              reduce using rule 86 (stmt -> ; .)
    {               reduce using rule 86 (stmt -> ; .)
    MUX             reduce using rule 86 (stmt -> ; .)
    WHEN            reduce using rule 86 (stmt -> ; .)
    IF              reduce using rule 86 (stmt -> ; .)
    FOR             reduce using rule 86 (stmt -> ; .)
    GENERATE        reduce using rule 86 (stmt -> ; .)
    INT             reduce using rule 86 (stmt -> ; .)
    FLOAT           reduce using rule 86 (stmt -> ; .)
    REG             reduce using rule 86 (stmt -> ; .)
    WIRE            reduce using rule 86 (stmt -> ; .)
    CLOCK           reduce using rule 86 (stmt -> ; .)
    SIGNAL          reduce using rule 86 (stmt -> ; .)
    (               reduce using rule 86 (stmt -> ; .)
    ADD             reduce using rule 86 (stmt -> ; .)
    SUB             reduce using rule 86 (stmt -> ; .)
    NOT             reduce using rule 86 (stmt -> ; .)
    NOTL            reduce using rule 86 (stmt -> ; .)
    INTEGER_CONST   reduce using rule 86 (stmt -> ; .)
    FLOAT_CONST     reduce using rule 86 (stmt -> ; .)
    }               reduce using rule 86 (stmt -> ; .)
    ELIF            reduce using rule 86 (stmt -> ; .)
    ELSE            reduce using rule 86 (stmt -> ; .)
    )               reduce using rule 86 (stmt -> ; .)


state 273

    (88) stmt -> block .

    ;               reduce using rule 88 (stmt -> block .)
    RETURN          reduce using rule 88 (stmt -> block .)
    CONST           reduce using rule 88 (stmt -> block .)
    ID              reduce using rule 88 (stmt -> block .)
    {               reduce using rule 88 (stmt -> block .)
    MUX             reduce using rule 88 (stmt -> block .)
    WHEN            reduce using rule 88 (stmt -> block .)
    IF              reduce using rule 88 (stmt -> block .)
    FOR             reduce using rule 88 (stmt -> block .)
    GENERATE        reduce using rule 88 (stmt -> block .)
    INT             reduce using rule 88 (stmt -> block .)
    FLOAT           reduce using rule 88 (stmt -> block .)
    REG             reduce using rule 88 (stmt -> block .)
    WIRE            reduce using rule 88 (stmt -> block .)
    CLOCK           reduce using rule 88 (stmt -> block .)
    SIGNAL          reduce using rule 88 (stmt -> block .)
    (               reduce using rule 88 (stmt -> block .)
    ADD             reduce using rule 88 (stmt -> block .)
    SUB             reduce using rule 88 (stmt -> block .)
    NOT             reduce using rule 88 (stmt -> block .)
    NOTL            reduce using rule 88 (stmt -> block .)
    INTEGER_CONST   reduce using rule 88 (stmt -> block .)
    FLOAT_CONST     reduce using rule 88 (stmt -> block .)
    }               reduce using rule 88 (stmt -> block .)
    ELIF            reduce using rule 88 (stmt -> block .)
    ELSE            reduce using rule 88 (stmt -> block .)
    )               reduce using rule 88 (stmt -> block .)


state 274

    (89) stmt -> seqLogStmt .

    ;               reduce using rule 89 (stmt -> seqLogStmt .)
    RETURN          reduce using rule 89 (stmt -> seqLogStmt .)
    CONST           reduce using rule 89 (stmt -> seqLogStmt .)
    ID              reduce using rule 89 (stmt -> seqLogStmt .)
    {               reduce using rule 89 (stmt -> seqLogStmt .)
    MUX             reduce using rule 89 (stmt -> seqLogStmt .)
    WHEN            reduce using rule 89 (stmt -> seqLogStmt .)
    IF              reduce using rule 89 (stmt -> seqLogStmt .)
    FOR             reduce using rule 89 (stmt -> seqLogStmt .)
    GENERATE        reduce using rule 89 (stmt -> seqLogStmt .)
    INT             reduce using rule 89 (stmt -> seqLogStmt .)
    FLOAT           reduce using rule 89 (stmt -> seqLogStmt .)
    REG             reduce using rule 89 (stmt -> seqLogStmt .)
    WIRE            reduce using rule 89 (stmt -> seqLogStmt .)
    CLOCK           reduce using rule 89 (stmt -> seqLogStmt .)
    SIGNAL          reduce using rule 89 (stmt -> seqLogStmt .)
    (               reduce using rule 89 (stmt -> seqLogStmt .)
    ADD             reduce using rule 89 (stmt -> seqLogStmt .)
    SUB             reduce using rule 89 (stmt -> seqLogStmt .)
    NOT             reduce using rule 89 (stmt -> seqLogStmt .)
    NOTL            reduce using rule 89 (stmt -> seqLogStmt .)
    INTEGER_CONST   reduce using rule 89 (stmt -> seqLogStmt .)
    FLOAT_CONST     reduce using rule 89 (stmt -> seqLogStmt .)
    }               reduce using rule 89 (stmt -> seqLogStmt .)
    ELIF            reduce using rule 89 (stmt -> seqLogStmt .)
    ELSE            reduce using rule 89 (stmt -> seqLogStmt .)
    )               reduce using rule 89 (stmt -> seqLogStmt .)


state 275

    (90) stmt -> ifStmt .

    ;               reduce using rule 90 (stmt -> ifStmt .)
    RETURN          reduce using rule 90 (stmt -> ifStmt .)
    CONST           reduce using rule 90 (stmt -> ifStmt .)
    ID              reduce using rule 90 (stmt -> ifStmt .)
    {               reduce using rule 90 (stmt -> ifStmt .)
    MUX             reduce using rule 90 (stmt -> ifStmt .)
    WHEN            reduce using rule 90 (stmt -> ifStmt .)
    IF              reduce using rule 90 (stmt -> ifStmt .)
    FOR             reduce using rule 90 (stmt -> ifStmt .)
    GENERATE        reduce using rule 90 (stmt -> ifStmt .)
    INT             reduce using rule 90 (stmt -> ifStmt .)
    FLOAT           reduce using rule 90 (stmt -> ifStmt .)
    REG             reduce using rule 90 (stmt -> ifStmt .)
    WIRE            reduce using rule 90 (stmt -> ifStmt .)
    CLOCK           reduce using rule 90 (stmt -> ifStmt .)
    SIGNAL          reduce using rule 90 (stmt -> ifStmt .)
    (               reduce using rule 90 (stmt -> ifStmt .)
    ADD             reduce using rule 90 (stmt -> ifStmt .)
    SUB             reduce using rule 90 (stmt -> ifStmt .)
    NOT             reduce using rule 90 (stmt -> ifStmt .)
    NOTL            reduce using rule 90 (stmt -> ifStmt .)
    INTEGER_CONST   reduce using rule 90 (stmt -> ifStmt .)
    FLOAT_CONST     reduce using rule 90 (stmt -> ifStmt .)
    }               reduce using rule 90 (stmt -> ifStmt .)
    ELIF            reduce using rule 90 (stmt -> ifStmt .)
    ELSE            reduce using rule 90 (stmt -> ifStmt .)
    )               reduce using rule 90 (stmt -> ifStmt .)


state 276

    (91) stmt -> forStmt .

    ;               reduce using rule 91 (stmt -> forStmt .)
    RETURN          reduce using rule 91 (stmt -> forStmt .)
    CONST           reduce using rule 91 (stmt -> forStmt .)
    ID              reduce using rule 91 (stmt -> forStmt .)
    {               reduce using rule 91 (stmt -> forStmt .)
    MUX             reduce using rule 91 (stmt -> forStmt .)
    WHEN            reduce using rule 91 (stmt -> forStmt .)
    IF              reduce using rule 91 (stmt -> forStmt .)
    FOR             reduce using rule 91 (stmt -> forStmt .)
    GENERATE        reduce using rule 91 (stmt -> forStmt .)
    INT             reduce using rule 91 (stmt -> forStmt .)
    FLOAT           reduce using rule 91 (stmt -> forStmt .)
    REG             reduce using rule 91 (stmt -> forStmt .)
    WIRE            reduce using rule 91 (stmt -> forStmt .)
    CLOCK           reduce using rule 91 (stmt -> forStmt .)
    SIGNAL          reduce using rule 91 (stmt -> forStmt .)
    (               reduce using rule 91 (stmt -> forStmt .)
    ADD             reduce using rule 91 (stmt -> forStmt .)
    SUB             reduce using rule 91 (stmt -> forStmt .)
    NOT             reduce using rule 91 (stmt -> forStmt .)
    NOTL            reduce using rule 91 (stmt -> forStmt .)
    INTEGER_CONST   reduce using rule 91 (stmt -> forStmt .)
    FLOAT_CONST     reduce using rule 91 (stmt -> forStmt .)
    }               reduce using rule 91 (stmt -> forStmt .)
    ELIF            reduce using rule 91 (stmt -> forStmt .)
    ELSE            reduce using rule 91 (stmt -> forStmt .)
    )               reduce using rule 91 (stmt -> forStmt .)


state 277

    (92) stmt -> RETURN . exp ;
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 316
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 278

    (36) varDecl -> val_type . varDef varDef_repeat ;
    (37) varDef -> . ID array
    (38) varDef -> . ID array ASSIGN initVal

    ID              shift and go to state 122

    varDef                         shift and go to state 37

state 279

    (57) cirDecl -> cir_type . cirDef cirDecl_repeat ;
    (58) cirDef -> . ID array
    (59) cirDef -> . ID array ASSIGN initVal

    ID              shift and go to state 106

    cirDef                         shift and go to state 32

state 280

    (39) modDecl -> ID . ( module_R_params ) ID array ;
    (49) bundleDecl -> ID . bundleDef bundleDecl_repeat
    (104) lVal -> ID . array_exp_repeat1
    (105) lVal -> ID . array_exp_repeat2
    (20) cir_basic_type -> ID .
    (124) unaryExp -> ID . ( )
    (125) unaryExp -> ID . ( funcRParams )
    (50) bundleDef -> . ID array
    (115) array_exp_repeat1 -> . empty
    (116) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (117) array_exp_repeat2 -> . empty
    (118) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 317
    ID              shift and go to state 33
    [               shift and go to state 158
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

  ! [               [ reduce using rule 20 (cir_basic_type -> ID .) ]
  ! ID              [ reduce using rule 20 (cir_basic_type -> ID .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! (               [ reduce using rule 1 (empty -> .) ]

    bundleDef                      shift and go to state 35
    array_exp_repeat1              shift and go to state 155
    array_exp_repeat2              shift and go to state 156
    empty                          shift and go to state 157

state 281

    (93) seqLogStmt -> WHEN . ( ID ) stmt
    (94) seqLogStmt -> WHEN . ( ID . RISING ) stmt
    (95) seqLogStmt -> WHEN . ( ID . FALLING ) stmt

    (               shift and go to state 318


state 282

    (100) ifStmt -> IF . ( exp ) stmt elifStmt elseStmt

    (               shift and go to state 319


state 283

    (101) forStmt -> FOR . ( varDecl exp ; stmt ) stmt

    (               shift and go to state 320


state 284

    (102) forStmt -> GENERATE . FOR ( varDecl exp ; exp ) COLON ID stmt

    FOR             shift and go to state 321


state 285

    (63) cir_funcFParams_repeat -> , cir_funcFParam cir_funcFParams_repeat .

    )               reduce using rule 63 (cir_funcFParams_repeat -> , cir_funcFParam cir_funcFParams_repeat .)


state 286

    (54) initVal -> { initVal initVal_repeat . }

    }               shift and go to state 322


state 287

    (51) initVal_repeat -> empty .

    }               reduce using rule 51 (initVal_repeat -> empty .)


state 288

    (52) initVal_repeat -> , . initVal initVal_repeat
    (53) initVal -> . exp
    (54) initVal -> . { initVal initVal_repeat }
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    {               shift and go to state 173
    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    initVal                        shift and go to state 323
    exp                            shift and go to state 172
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 289

    (106) lVal -> { ID array_exp_repeat1 . lVal_repeat }
    (104) lVal -> ID array_exp_repeat1 .
    (113) lVal_repeat -> . empty
    (114) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

  ! shift/reduce conflict for , resolved as shift
  ! reduce/reduce conflict for } resolved using rule 1 (empty -> .)
    .               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    MUL             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    DIV             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    MOD             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    POWER           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ADD             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SUB             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SLL             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SRL             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SRA             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    LT              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    GT              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    GE              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    LE              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    EQUAL           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    NEQ             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    AND             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    OR              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    XOR             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    XNOR            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    LAND            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    LOR             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    BIT_WIDTH_NUMBER reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ASSIGN          reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    CONNECT         reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ;               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    RETURN          reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    CONST           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ID              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    {               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    MUX             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    WHEN            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    IF              reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    FOR             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    GENERATE        reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    INT             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    FLOAT           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    REG             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    WIRE            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    CLOCK           reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    SIGNAL          reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    (               reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    NOT             reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    NOTL            reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    INTEGER_CONST   reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    FLOAT_CONST     reduce using rule 104 (lVal -> ID array_exp_repeat1 .)
    ,               shift and go to state 261
    }               reduce using rule 1 (empty -> .)

  ! ,               [ reduce using rule 104 (lVal -> ID array_exp_repeat1 .) ]
  ! }               [ reduce using rule 104 (lVal -> ID array_exp_repeat1 .) ]

    lVal_repeat                    shift and go to state 259
    empty                          shift and go to state 260

state 290

    (107) lVal -> { ID array_exp_repeat2 . lVal_repeat }
    (105) lVal -> ID array_exp_repeat2 .
    (113) lVal_repeat -> . empty
    (114) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

  ! shift/reduce conflict for , resolved as shift
  ! reduce/reduce conflict for } resolved using rule 1 (empty -> .)
    .               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    MUL             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    DIV             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    MOD             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    POWER           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ADD             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SUB             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SLL             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SRL             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SRA             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    LT              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    GT              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    GE              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    LE              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    EQUAL           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    NEQ             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    AND             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    OR              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    XOR             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    XNOR            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    LAND            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    LOR             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    BIT_WIDTH_NUMBER reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ASSIGN          reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    CONNECT         reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ;               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    RETURN          reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    CONST           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ID              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    {               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    MUX             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    WHEN            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    IF              reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    FOR             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    GENERATE        reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    INT             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    FLOAT           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    REG             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    WIRE            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    CLOCK           reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    SIGNAL          reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    (               reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    NOT             reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    NOTL            reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    INTEGER_CONST   reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    FLOAT_CONST     reduce using rule 105 (lVal -> ID array_exp_repeat2 .)
    ,               shift and go to state 261
    }               reduce using rule 1 (empty -> .)

  ! ,               [ reduce using rule 105 (lVal -> ID array_exp_repeat2 .) ]
  ! }               [ reduce using rule 105 (lVal -> ID array_exp_repeat2 .) ]

    lVal_repeat                    shift and go to state 262
    empty                          shift and go to state 260

state 291

    (39) modDecl -> ID ( module_R_params ) ID array ; .

    MODULE          reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    BUNDLE          reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    CONST           reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    ID              reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    INT             reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    FLOAT           reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    REG             reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    WIRE            reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    CLOCK           reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    $end            reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    ;               reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    RETURN          reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    {               reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    MUX             reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    WHEN            reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    IF              reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    FOR             reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    GENERATE        reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    SIGNAL          reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    (               reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    ADD             reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    SUB             reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    NOT             reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    NOTL            reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    INTEGER_CONST   reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    FLOAT_CONST     reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)
    }               reduce using rule 39 (modDecl -> ID ( module_R_params ) ID array ; .)


state 292

    (43) p_module_R_params_item -> R_port_def ID ( ID ) .

    ,               reduce using rule 43 (p_module_R_params_item -> R_port_def ID ( ID ) .)
    )               reduce using rule 43 (p_module_R_params_item -> R_port_def ID ( ID ) .)


state 293

    (66) funcFParams_repeat -> , funcFParam funcFParams_repeat .

    )               reduce using rule 66 (funcFParams_repeat -> , funcFParam funcFParams_repeat .)


state 294

    (75) module -> MODULE ID ( module_para_para port_def ID p_module_para_port . ) block

    )               shift and go to state 324


state 295

    (73) p_module_para_port -> empty .

    )               reduce using rule 73 (p_module_para_port -> empty .)


state 296

    (74) p_module_para_port -> , . port_def ID p_module_para_port
    (165) port_def -> . INPUT cir_type
    (166) port_def -> . OUTPUT cir_type
    (167) port_def -> . INOUT cir_type

    INPUT           shift and go to state 188
    OUTPUT          shift and go to state 189
    INOUT           shift and go to state 190

    port_def                       shift and go to state 325

state 297

    (71) module_para_para -> PARA val_type ID , .
    (72) module_para_para -> PARA val_type ID , . module_para_para
    (70) module_para_para -> . empty
    (71) module_para_para -> . PARA val_type ID ,
    (72) module_para_para -> . PARA val_type ID , module_para_para
    (1) empty -> .

  ! reduce/reduce conflict for INPUT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for INOUT resolved using rule 1 (empty -> .)
    PARA            shift and go to state 125
    INPUT           reduce using rule 1 (empty -> .)
    OUTPUT          reduce using rule 1 (empty -> .)
    INOUT           reduce using rule 1 (empty -> .)

  ! INPUT           [ reduce using rule 71 (module_para_para -> PARA val_type ID , .) ]
  ! OUTPUT          [ reduce using rule 71 (module_para_para -> PARA val_type ID , .) ]
  ! INOUT           [ reduce using rule 71 (module_para_para -> PARA val_type ID , .) ]

    module_para_para               shift and go to state 326
    empty                          shift and go to state 124

state 298

    (78) bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .

    MODULE          reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    BUNDLE          reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    CONST           reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    ID              reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    INT             reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    FLOAT           reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    REG             reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    WIRE            reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    CLOCK           reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    $end            reduce using rule 78 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)


state 299

    (77) bundle_repeat -> , cir_type . ID bundle_repeat

    ID              shift and go to state 327


state 300

    (33) constInitVal -> { constInitVal . constInitVal_repeat }
    (30) constInitVal_repeat -> . empty
    (31) constInitVal_repeat -> . , constInitVal constInitVal_repeat
    (1) empty -> .

    ,               shift and go to state 330
    }               reduce using rule 1 (empty -> .)

    constInitVal_repeat            shift and go to state 328
    empty                          shift and go to state 329

state 301

    (133) exp_repeat -> , exp . exp_repeat
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER
    (132) exp_repeat -> . empty
    (133) exp_repeat -> . , exp exp_repeat
    (1) empty -> .

    BIT_WIDTH_NUMBER shift and go to state 132
    ,               shift and go to state 255
    )               reduce using rule 1 (empty -> .)

    exp_repeat                     shift and go to state 331
    empty                          shift and go to state 254

state 302

    (116) array_exp_repeat1 -> [ . exp ] array_exp_repeat1
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 332
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 303

    (116) array_exp_repeat1 -> [ exp ] array_exp_repeat1 .

    .               reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    MUL             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    DIV             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    MOD             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    POWER           reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ADD             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SUB             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SLL             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SRL             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SRA             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    LT              reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    GT              reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    GE              reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    LE              reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    EQUAL           reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    NEQ             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    AND             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    OR              reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    XOR             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    XNOR            reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    LAND            reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    LOR             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ]               reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    BIT_WIDTH_NUMBER reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    )               reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ,               reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ;               reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    COLON           reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    }               reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    RETURN          reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    CONST           reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ID              reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    {               reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    MUX             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    WHEN            reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    IF              reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    FOR             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    GENERATE        reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    INT             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    FLOAT           reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    REG             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    WIRE            reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    CLOCK           reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SIGNAL          reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    (               reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    NOT             reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    NOTL            reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    INTEGER_CONST   reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    FLOAT_CONST     reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ELIF            reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ELSE            reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ASSIGN          reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    CONNECT         reduce using rule 116 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)


state 304

    (115) array_exp_repeat1 -> empty .

    .               reduce using rule 115 (array_exp_repeat1 -> empty .)
    MUL             reduce using rule 115 (array_exp_repeat1 -> empty .)
    DIV             reduce using rule 115 (array_exp_repeat1 -> empty .)
    MOD             reduce using rule 115 (array_exp_repeat1 -> empty .)
    POWER           reduce using rule 115 (array_exp_repeat1 -> empty .)
    ADD             reduce using rule 115 (array_exp_repeat1 -> empty .)
    SUB             reduce using rule 115 (array_exp_repeat1 -> empty .)
    SLL             reduce using rule 115 (array_exp_repeat1 -> empty .)
    SRL             reduce using rule 115 (array_exp_repeat1 -> empty .)
    SRA             reduce using rule 115 (array_exp_repeat1 -> empty .)
    LT              reduce using rule 115 (array_exp_repeat1 -> empty .)
    GT              reduce using rule 115 (array_exp_repeat1 -> empty .)
    GE              reduce using rule 115 (array_exp_repeat1 -> empty .)
    LE              reduce using rule 115 (array_exp_repeat1 -> empty .)
    EQUAL           reduce using rule 115 (array_exp_repeat1 -> empty .)
    NEQ             reduce using rule 115 (array_exp_repeat1 -> empty .)
    AND             reduce using rule 115 (array_exp_repeat1 -> empty .)
    OR              reduce using rule 115 (array_exp_repeat1 -> empty .)
    XOR             reduce using rule 115 (array_exp_repeat1 -> empty .)
    XNOR            reduce using rule 115 (array_exp_repeat1 -> empty .)
    LAND            reduce using rule 115 (array_exp_repeat1 -> empty .)
    LOR             reduce using rule 115 (array_exp_repeat1 -> empty .)
    ]               reduce using rule 115 (array_exp_repeat1 -> empty .)
    BIT_WIDTH_NUMBER reduce using rule 115 (array_exp_repeat1 -> empty .)
    )               reduce using rule 115 (array_exp_repeat1 -> empty .)
    ,               reduce using rule 115 (array_exp_repeat1 -> empty .)
    ;               reduce using rule 115 (array_exp_repeat1 -> empty .)
    COLON           reduce using rule 115 (array_exp_repeat1 -> empty .)
    }               reduce using rule 115 (array_exp_repeat1 -> empty .)
    RETURN          reduce using rule 115 (array_exp_repeat1 -> empty .)
    CONST           reduce using rule 115 (array_exp_repeat1 -> empty .)
    ID              reduce using rule 115 (array_exp_repeat1 -> empty .)
    {               reduce using rule 115 (array_exp_repeat1 -> empty .)
    MUX             reduce using rule 115 (array_exp_repeat1 -> empty .)
    WHEN            reduce using rule 115 (array_exp_repeat1 -> empty .)
    IF              reduce using rule 115 (array_exp_repeat1 -> empty .)
    FOR             reduce using rule 115 (array_exp_repeat1 -> empty .)
    GENERATE        reduce using rule 115 (array_exp_repeat1 -> empty .)
    INT             reduce using rule 115 (array_exp_repeat1 -> empty .)
    FLOAT           reduce using rule 115 (array_exp_repeat1 -> empty .)
    REG             reduce using rule 115 (array_exp_repeat1 -> empty .)
    WIRE            reduce using rule 115 (array_exp_repeat1 -> empty .)
    CLOCK           reduce using rule 115 (array_exp_repeat1 -> empty .)
    SIGNAL          reduce using rule 115 (array_exp_repeat1 -> empty .)
    (               reduce using rule 115 (array_exp_repeat1 -> empty .)
    NOT             reduce using rule 115 (array_exp_repeat1 -> empty .)
    NOTL            reduce using rule 115 (array_exp_repeat1 -> empty .)
    INTEGER_CONST   reduce using rule 115 (array_exp_repeat1 -> empty .)
    FLOAT_CONST     reduce using rule 115 (array_exp_repeat1 -> empty .)
    ELIF            reduce using rule 115 (array_exp_repeat1 -> empty .)
    ELSE            reduce using rule 115 (array_exp_repeat1 -> empty .)
    ASSIGN          reduce using rule 115 (array_exp_repeat1 -> empty .)
    CONNECT         reduce using rule 115 (array_exp_repeat1 -> empty .)


state 305

    (118) array_exp_repeat2 -> [ exp COLON exp . ] array_exp_repeat2
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               shift and go to state 333
    BIT_WIDTH_NUMBER shift and go to state 132


state 306

    (106) lVal -> { ID array_exp_repeat1 lVal_repeat } .

    .               reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    MUL             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    DIV             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    MOD             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    POWER           reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ADD             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SUB             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SLL             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SRL             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SRA             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    LT              reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    GT              reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    GE              reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    LE              reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    EQUAL           reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    NEQ             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    AND             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    OR              reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    XOR             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    XNOR            reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    LAND            reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    LOR             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ]               reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    BIT_WIDTH_NUMBER reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    )               reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ,               reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ;               reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    COLON           reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    }               reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    RETURN          reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    CONST           reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ID              reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    {               reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    MUX             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    WHEN            reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    IF              reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    FOR             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    GENERATE        reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    INT             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    FLOAT           reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    REG             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    WIRE            reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    CLOCK           reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SIGNAL          reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    (               reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    NOT             reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    NOTL            reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    INTEGER_CONST   reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    FLOAT_CONST     reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ELIF            reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ELSE            reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ASSIGN          reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    CONNECT         reduce using rule 106 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)


state 307

    (114) lVal_repeat -> , lVal . lVal_repeat
    (109) lVal -> lVal . . ID
    (113) lVal_repeat -> . empty
    (114) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

    .               shift and go to state 163
    ,               shift and go to state 261
    }               reduce using rule 1 (empty -> .)

    lVal_repeat                    shift and go to state 334
    empty                          shift and go to state 260

state 308

    (104) lVal -> ID . array_exp_repeat1
    (105) lVal -> ID . array_exp_repeat2
    (115) array_exp_repeat1 -> . empty
    (116) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (117) array_exp_repeat2 -> . empty
    (118) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

    [               shift and go to state 158
    .               reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    array_exp_repeat1              shift and go to state 155
    array_exp_repeat2              shift and go to state 156
    empty                          shift and go to state 157

state 309

    (107) lVal -> { ID array_exp_repeat2 lVal_repeat } .

    .               reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    MUL             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    DIV             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    MOD             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    POWER           reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ADD             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SUB             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SLL             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SRL             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SRA             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    LT              reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    GT              reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    GE              reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    LE              reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    EQUAL           reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    NEQ             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    AND             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    OR              reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    XOR             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    XNOR            reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    LAND            reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    LOR             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ]               reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    BIT_WIDTH_NUMBER reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    )               reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ,               reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ;               reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    COLON           reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    }               reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    RETURN          reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    CONST           reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ID              reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    {               reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    MUX             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    WHEN            reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    IF              reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    FOR             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    GENERATE        reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    INT             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    FLOAT           reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    REG             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    WIRE            reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    CLOCK           reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SIGNAL          reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    (               reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    NOT             reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    NOTL            reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    INTEGER_CONST   reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    FLOAT_CONST     reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ELIF            reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ELSE            reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ASSIGN          reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    CONNECT         reduce using rule 107 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)


state 310

    (108) lVal -> MUX ( exp , exp . , exp )
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ,               shift and go to state 335
    BIT_WIDTH_NUMBER shift and go to state 132


state 311

    (106) lVal -> { ID . array_exp_repeat1 lVal_repeat }
    (107) lVal -> { ID . array_exp_repeat2 lVal_repeat }
    (39) modDecl -> ID . ( module_R_params ) ID array ;
    (49) bundleDecl -> ID . bundleDef bundleDecl_repeat
    (104) lVal -> ID . array_exp_repeat1
    (105) lVal -> ID . array_exp_repeat2
    (20) cir_basic_type -> ID .
    (124) unaryExp -> ID . ( )
    (125) unaryExp -> ID . ( funcRParams )
    (115) array_exp_repeat1 -> . empty
    (116) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (117) array_exp_repeat2 -> . empty
    (118) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (50) bundleDef -> . ID array
    (1) empty -> .

  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 317
    [               shift and go to state 158
    ID              shift and go to state 33
    ,               reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)

  ! [               [ reduce using rule 20 (cir_basic_type -> ID .) ]
  ! ID              [ reduce using rule 20 (cir_basic_type -> ID .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! (               [ reduce using rule 1 (empty -> .) ]

    array_exp_repeat1              shift and go to state 289
    array_exp_repeat2              shift and go to state 290
    bundleDef                      shift and go to state 35
    empty                          shift and go to state 157

state 312

    (81) block -> { block_repeat } .

    MODULE          reduce using rule 81 (block -> { block_repeat } .)
    BUNDLE          reduce using rule 81 (block -> { block_repeat } .)
    CONST           reduce using rule 81 (block -> { block_repeat } .)
    ID              reduce using rule 81 (block -> { block_repeat } .)
    INT             reduce using rule 81 (block -> { block_repeat } .)
    FLOAT           reduce using rule 81 (block -> { block_repeat } .)
    REG             reduce using rule 81 (block -> { block_repeat } .)
    WIRE            reduce using rule 81 (block -> { block_repeat } .)
    CLOCK           reduce using rule 81 (block -> { block_repeat } .)
    $end            reduce using rule 81 (block -> { block_repeat } .)
    ;               reduce using rule 81 (block -> { block_repeat } .)
    RETURN          reduce using rule 81 (block -> { block_repeat } .)
    {               reduce using rule 81 (block -> { block_repeat } .)
    MUX             reduce using rule 81 (block -> { block_repeat } .)
    WHEN            reduce using rule 81 (block -> { block_repeat } .)
    IF              reduce using rule 81 (block -> { block_repeat } .)
    FOR             reduce using rule 81 (block -> { block_repeat } .)
    GENERATE        reduce using rule 81 (block -> { block_repeat } .)
    SIGNAL          reduce using rule 81 (block -> { block_repeat } .)
    (               reduce using rule 81 (block -> { block_repeat } .)
    ADD             reduce using rule 81 (block -> { block_repeat } .)
    SUB             reduce using rule 81 (block -> { block_repeat } .)
    NOT             reduce using rule 81 (block -> { block_repeat } .)
    NOTL            reduce using rule 81 (block -> { block_repeat } .)
    INTEGER_CONST   reduce using rule 81 (block -> { block_repeat } .)
    FLOAT_CONST     reduce using rule 81 (block -> { block_repeat } .)
    }               reduce using rule 81 (block -> { block_repeat } .)
    ELIF            reduce using rule 81 (block -> { block_repeat } .)
    ELSE            reduce using rule 81 (block -> { block_repeat } .)
    )               reduce using rule 81 (block -> { block_repeat } .)


state 313

    (80) block_repeat -> blockItem block_repeat .

    }               reduce using rule 80 (block_repeat -> blockItem block_repeat .)


state 314

    (84) stmt -> lVal ASSIGN . exp ;
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    lVal                           shift and go to state 86
    exp                            shift and go to state 336
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 315

    (85) stmt -> lVal CONNECT . exp ;
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    lVal                           shift and go to state 86
    exp                            shift and go to state 337
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 316

    (92) stmt -> RETURN exp . ;
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 338
    BIT_WIDTH_NUMBER shift and go to state 132


state 317

    (39) modDecl -> ID ( . module_R_params ) ID array ;
    (124) unaryExp -> ID ( . )
    (125) unaryExp -> ID ( . funcRParams )
    (46) module_R_params -> . p_module_R_params_item module_R_params_repeat
    (134) funcRParams -> . exp
    (135) funcRParams -> . exp exp_repeat
    (43) p_module_R_params_item -> . R_port_def ID ( ID )
    (103) exp -> . lOrExp
    (40) R_port_def -> . IN .
    (41) R_port_def -> . OUT .
    (42) R_port_def -> . INOUT .
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    )               shift and go to state 217
    IN              shift and go to state 54
    OUT             shift and go to state 55
    INOUT           shift and go to state 56
    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    module_R_params                shift and go to state 51
    funcRParams                    shift and go to state 218
    p_module_R_params_item         shift and go to state 52
    exp                            shift and go to state 219
    R_port_def                     shift and go to state 53
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 318

    (93) seqLogStmt -> WHEN ( . ID ) stmt
    (94) seqLogStmt -> WHEN ( . ID . RISING ) stmt
    (95) seqLogStmt -> WHEN ( . ID . FALLING ) stmt

    ID              shift and go to state 339


state 319

    (100) ifStmt -> IF ( . exp ) stmt elifStmt elseStmt
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 340
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 320

    (101) forStmt -> FOR ( . varDecl exp ; stmt ) stmt
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (23) val_type -> . INT
    (24) val_type -> . FLOAT

    INT             shift and go to state 19
    FLOAT           shift and go to state 20

    varDecl                        shift and go to state 341
    val_type                       shift and go to state 278

state 321

    (102) forStmt -> GENERATE FOR . ( varDecl exp ; exp ) COLON ID stmt

    (               shift and go to state 342


state 322

    (54) initVal -> { initVal initVal_repeat } .

    ,               reduce using rule 54 (initVal -> { initVal initVal_repeat } .)
    ;               reduce using rule 54 (initVal -> { initVal initVal_repeat } .)
    }               reduce using rule 54 (initVal -> { initVal initVal_repeat } .)


state 323

    (52) initVal_repeat -> , initVal . initVal_repeat
    (51) initVal_repeat -> . empty
    (52) initVal_repeat -> . , initVal initVal_repeat
    (1) empty -> .

    ,               shift and go to state 288
    }               reduce using rule 1 (empty -> .)

    initVal_repeat                 shift and go to state 343
    empty                          shift and go to state 287

state 324

    (75) module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) . block
    (81) block -> . { block_repeat }

    {               shift and go to state 228

    block                          shift and go to state 344

state 325

    (74) p_module_para_port -> , port_def . ID p_module_para_port

    ID              shift and go to state 345


state 326

    (72) module_para_para -> PARA val_type ID , module_para_para .

    INPUT           reduce using rule 72 (module_para_para -> PARA val_type ID , module_para_para .)
    OUTPUT          reduce using rule 72 (module_para_para -> PARA val_type ID , module_para_para .)
    INOUT           reduce using rule 72 (module_para_para -> PARA val_type ID , module_para_para .)


state 327

    (77) bundle_repeat -> , cir_type ID . bundle_repeat
    (76) bundle_repeat -> . empty
    (77) bundle_repeat -> . , cir_type ID bundle_repeat
    (1) empty -> .

    ,               shift and go to state 247
    )               reduce using rule 1 (empty -> .)

    bundle_repeat                  shift and go to state 346
    empty                          shift and go to state 246

state 328

    (33) constInitVal -> { constInitVal constInitVal_repeat . }

    }               shift and go to state 347


state 329

    (30) constInitVal_repeat -> empty .

    }               reduce using rule 30 (constInitVal_repeat -> empty .)


state 330

    (31) constInitVal_repeat -> , . constInitVal constInitVal_repeat
    (32) constInitVal -> . constExp
    (33) constInitVal -> . { constInitVal constInitVal_repeat }
    (168) constExp -> . exp
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    {               shift and go to state 251
    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    constInitVal                   shift and go to state 348
    constExp                       shift and go to state 250
    exp                            shift and go to state 103
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 331

    (133) exp_repeat -> , exp exp_repeat .

    )               reduce using rule 133 (exp_repeat -> , exp exp_repeat .)


state 332

    (116) array_exp_repeat1 -> [ exp . ] array_exp_repeat1
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               shift and go to state 256
    BIT_WIDTH_NUMBER shift and go to state 132


state 333

    (118) array_exp_repeat2 -> [ exp COLON exp ] . array_exp_repeat2
    (117) array_exp_repeat2 -> . empty
    (118) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

    [               shift and go to state 349
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    ]               reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    COLON           reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    ELIF            reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)

    array_exp_repeat2              shift and go to state 350
    empty                          shift and go to state 351

state 334

    (114) lVal_repeat -> , lVal lVal_repeat .

    }               reduce using rule 114 (lVal_repeat -> , lVal lVal_repeat .)


state 335

    (108) lVal -> MUX ( exp , exp , . exp )
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 352
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 336

    (84) stmt -> lVal ASSIGN exp . ;
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 353
    BIT_WIDTH_NUMBER shift and go to state 132


state 337

    (85) stmt -> lVal CONNECT exp . ;
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 354
    BIT_WIDTH_NUMBER shift and go to state 132


state 338

    (92) stmt -> RETURN exp ; .

    ;               reduce using rule 92 (stmt -> RETURN exp ; .)
    RETURN          reduce using rule 92 (stmt -> RETURN exp ; .)
    CONST           reduce using rule 92 (stmt -> RETURN exp ; .)
    ID              reduce using rule 92 (stmt -> RETURN exp ; .)
    {               reduce using rule 92 (stmt -> RETURN exp ; .)
    MUX             reduce using rule 92 (stmt -> RETURN exp ; .)
    WHEN            reduce using rule 92 (stmt -> RETURN exp ; .)
    IF              reduce using rule 92 (stmt -> RETURN exp ; .)
    FOR             reduce using rule 92 (stmt -> RETURN exp ; .)
    GENERATE        reduce using rule 92 (stmt -> RETURN exp ; .)
    INT             reduce using rule 92 (stmt -> RETURN exp ; .)
    FLOAT           reduce using rule 92 (stmt -> RETURN exp ; .)
    REG             reduce using rule 92 (stmt -> RETURN exp ; .)
    WIRE            reduce using rule 92 (stmt -> RETURN exp ; .)
    CLOCK           reduce using rule 92 (stmt -> RETURN exp ; .)
    SIGNAL          reduce using rule 92 (stmt -> RETURN exp ; .)
    (               reduce using rule 92 (stmt -> RETURN exp ; .)
    ADD             reduce using rule 92 (stmt -> RETURN exp ; .)
    SUB             reduce using rule 92 (stmt -> RETURN exp ; .)
    NOT             reduce using rule 92 (stmt -> RETURN exp ; .)
    NOTL            reduce using rule 92 (stmt -> RETURN exp ; .)
    INTEGER_CONST   reduce using rule 92 (stmt -> RETURN exp ; .)
    FLOAT_CONST     reduce using rule 92 (stmt -> RETURN exp ; .)
    }               reduce using rule 92 (stmt -> RETURN exp ; .)
    ELIF            reduce using rule 92 (stmt -> RETURN exp ; .)
    ELSE            reduce using rule 92 (stmt -> RETURN exp ; .)
    )               reduce using rule 92 (stmt -> RETURN exp ; .)


state 339

    (93) seqLogStmt -> WHEN ( ID . ) stmt
    (94) seqLogStmt -> WHEN ( ID . . RISING ) stmt
    (95) seqLogStmt -> WHEN ( ID . . FALLING ) stmt

    )               shift and go to state 355
    .               shift and go to state 356


state 340

    (100) ifStmt -> IF ( exp . ) stmt elifStmt elseStmt
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 357
    BIT_WIDTH_NUMBER shift and go to state 132


state 341

    (101) forStmt -> FOR ( varDecl . exp ; stmt ) stmt
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 358
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 342

    (102) forStmt -> GENERATE FOR ( . varDecl exp ; exp ) COLON ID stmt
    (36) varDecl -> . val_type varDef varDef_repeat ;
    (23) val_type -> . INT
    (24) val_type -> . FLOAT

    INT             shift and go to state 19
    FLOAT           shift and go to state 20

    varDecl                        shift and go to state 359
    val_type                       shift and go to state 278

state 343

    (52) initVal_repeat -> , initVal initVal_repeat .

    }               reduce using rule 52 (initVal_repeat -> , initVal initVal_repeat .)


state 344

    (75) module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .

    MODULE          reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)
    BUNDLE          reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)
    CONST           reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)
    ID              reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)
    INT             reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)
    FLOAT           reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)
    REG             reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)
    WIRE            reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)
    CLOCK           reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)
    $end            reduce using rule 75 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port ) block .)


state 345

    (74) p_module_para_port -> , port_def ID . p_module_para_port
    (73) p_module_para_port -> . empty
    (74) p_module_para_port -> . , port_def ID p_module_para_port
    (1) empty -> .

    ,               shift and go to state 296
    )               reduce using rule 1 (empty -> .)

    p_module_para_port             shift and go to state 360
    empty                          shift and go to state 295

state 346

    (77) bundle_repeat -> , cir_type ID bundle_repeat .

    )               reduce using rule 77 (bundle_repeat -> , cir_type ID bundle_repeat .)


state 347

    (33) constInitVal -> { constInitVal constInitVal_repeat } .

    ,               reduce using rule 33 (constInitVal -> { constInitVal constInitVal_repeat } .)
    ;               reduce using rule 33 (constInitVal -> { constInitVal constInitVal_repeat } .)
    }               reduce using rule 33 (constInitVal -> { constInitVal constInitVal_repeat } .)


state 348

    (31) constInitVal_repeat -> , constInitVal . constInitVal_repeat
    (30) constInitVal_repeat -> . empty
    (31) constInitVal_repeat -> . , constInitVal constInitVal_repeat
    (1) empty -> .

    ,               shift and go to state 330
    }               reduce using rule 1 (empty -> .)

    constInitVal_repeat            shift and go to state 361
    empty                          shift and go to state 329

state 349

    (118) array_exp_repeat2 -> [ . exp COLON exp ] array_exp_repeat2
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 362
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 350

    (118) array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .

    .               reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    MUL             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    DIV             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    MOD             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    POWER           reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ADD             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SUB             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SLL             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SRL             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SRA             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    LT              reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    GT              reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    GE              reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    LE              reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    EQUAL           reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    NEQ             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    AND             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    OR              reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    XOR             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    XNOR            reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    LAND            reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    LOR             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ]               reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    BIT_WIDTH_NUMBER reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    )               reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ,               reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ;               reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    COLON           reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    }               reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    RETURN          reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    CONST           reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ID              reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    {               reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    MUX             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    WHEN            reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    IF              reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    FOR             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    GENERATE        reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    INT             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    FLOAT           reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    REG             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    WIRE            reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    CLOCK           reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SIGNAL          reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    (               reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    NOT             reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    NOTL            reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    INTEGER_CONST   reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    FLOAT_CONST     reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ELIF            reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ELSE            reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ASSIGN          reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    CONNECT         reduce using rule 118 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)


state 351

    (117) array_exp_repeat2 -> empty .

    .               reduce using rule 117 (array_exp_repeat2 -> empty .)
    MUL             reduce using rule 117 (array_exp_repeat2 -> empty .)
    DIV             reduce using rule 117 (array_exp_repeat2 -> empty .)
    MOD             reduce using rule 117 (array_exp_repeat2 -> empty .)
    POWER           reduce using rule 117 (array_exp_repeat2 -> empty .)
    ADD             reduce using rule 117 (array_exp_repeat2 -> empty .)
    SUB             reduce using rule 117 (array_exp_repeat2 -> empty .)
    SLL             reduce using rule 117 (array_exp_repeat2 -> empty .)
    SRL             reduce using rule 117 (array_exp_repeat2 -> empty .)
    SRA             reduce using rule 117 (array_exp_repeat2 -> empty .)
    LT              reduce using rule 117 (array_exp_repeat2 -> empty .)
    GT              reduce using rule 117 (array_exp_repeat2 -> empty .)
    GE              reduce using rule 117 (array_exp_repeat2 -> empty .)
    LE              reduce using rule 117 (array_exp_repeat2 -> empty .)
    EQUAL           reduce using rule 117 (array_exp_repeat2 -> empty .)
    NEQ             reduce using rule 117 (array_exp_repeat2 -> empty .)
    AND             reduce using rule 117 (array_exp_repeat2 -> empty .)
    OR              reduce using rule 117 (array_exp_repeat2 -> empty .)
    XOR             reduce using rule 117 (array_exp_repeat2 -> empty .)
    XNOR            reduce using rule 117 (array_exp_repeat2 -> empty .)
    LAND            reduce using rule 117 (array_exp_repeat2 -> empty .)
    LOR             reduce using rule 117 (array_exp_repeat2 -> empty .)
    ]               reduce using rule 117 (array_exp_repeat2 -> empty .)
    BIT_WIDTH_NUMBER reduce using rule 117 (array_exp_repeat2 -> empty .)
    )               reduce using rule 117 (array_exp_repeat2 -> empty .)
    ,               reduce using rule 117 (array_exp_repeat2 -> empty .)
    ;               reduce using rule 117 (array_exp_repeat2 -> empty .)
    COLON           reduce using rule 117 (array_exp_repeat2 -> empty .)
    }               reduce using rule 117 (array_exp_repeat2 -> empty .)
    RETURN          reduce using rule 117 (array_exp_repeat2 -> empty .)
    CONST           reduce using rule 117 (array_exp_repeat2 -> empty .)
    ID              reduce using rule 117 (array_exp_repeat2 -> empty .)
    {               reduce using rule 117 (array_exp_repeat2 -> empty .)
    MUX             reduce using rule 117 (array_exp_repeat2 -> empty .)
    WHEN            reduce using rule 117 (array_exp_repeat2 -> empty .)
    IF              reduce using rule 117 (array_exp_repeat2 -> empty .)
    FOR             reduce using rule 117 (array_exp_repeat2 -> empty .)
    GENERATE        reduce using rule 117 (array_exp_repeat2 -> empty .)
    INT             reduce using rule 117 (array_exp_repeat2 -> empty .)
    FLOAT           reduce using rule 117 (array_exp_repeat2 -> empty .)
    REG             reduce using rule 117 (array_exp_repeat2 -> empty .)
    WIRE            reduce using rule 117 (array_exp_repeat2 -> empty .)
    CLOCK           reduce using rule 117 (array_exp_repeat2 -> empty .)
    SIGNAL          reduce using rule 117 (array_exp_repeat2 -> empty .)
    (               reduce using rule 117 (array_exp_repeat2 -> empty .)
    NOT             reduce using rule 117 (array_exp_repeat2 -> empty .)
    NOTL            reduce using rule 117 (array_exp_repeat2 -> empty .)
    INTEGER_CONST   reduce using rule 117 (array_exp_repeat2 -> empty .)
    FLOAT_CONST     reduce using rule 117 (array_exp_repeat2 -> empty .)
    ELIF            reduce using rule 117 (array_exp_repeat2 -> empty .)
    ELSE            reduce using rule 117 (array_exp_repeat2 -> empty .)
    ASSIGN          reduce using rule 117 (array_exp_repeat2 -> empty .)
    CONNECT         reduce using rule 117 (array_exp_repeat2 -> empty .)


state 352

    (108) lVal -> MUX ( exp , exp , exp . )
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 363
    BIT_WIDTH_NUMBER shift and go to state 132


state 353

    (84) stmt -> lVal ASSIGN exp ; .

    ;               reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    RETURN          reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    CONST           reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    ID              reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    {               reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    MUX             reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    WHEN            reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    IF              reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    FOR             reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    GENERATE        reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    INT             reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    FLOAT           reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    REG             reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    WIRE            reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    CLOCK           reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    SIGNAL          reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    (               reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    ADD             reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    SUB             reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    NOT             reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    NOTL            reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    INTEGER_CONST   reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    FLOAT_CONST     reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    }               reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    ELIF            reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    ELSE            reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)
    )               reduce using rule 84 (stmt -> lVal ASSIGN exp ; .)


state 354

    (85) stmt -> lVal CONNECT exp ; .

    ;               reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    RETURN          reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    CONST           reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    ID              reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    {               reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    MUX             reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    WHEN            reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    IF              reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    FOR             reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    GENERATE        reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    INT             reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    FLOAT           reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    REG             reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    WIRE            reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    CLOCK           reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    SIGNAL          reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    (               reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    ADD             reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    SUB             reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    NOT             reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    NOTL            reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    INTEGER_CONST   reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    FLOAT_CONST     reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    }               reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    ELIF            reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    ELSE            reduce using rule 85 (stmt -> lVal CONNECT exp ; .)
    )               reduce using rule 85 (stmt -> lVal CONNECT exp ; .)


state 355

    (93) seqLogStmt -> WHEN ( ID ) . stmt
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 272
    RETURN          shift and go to state 277
    ID              shift and go to state 364
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    stmt                           shift and go to state 365
    lVal                           shift and go to state 270
    exp                            shift and go to state 271
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 356

    (94) seqLogStmt -> WHEN ( ID . . RISING ) stmt
    (95) seqLogStmt -> WHEN ( ID . . FALLING ) stmt

    RISING          shift and go to state 366
    FALLING         shift and go to state 367


state 357

    (100) ifStmt -> IF ( exp ) . stmt elifStmt elseStmt
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 272
    RETURN          shift and go to state 277
    ID              shift and go to state 364
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 271
    stmt                           shift and go to state 368
    lVal                           shift and go to state 270
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 358

    (101) forStmt -> FOR ( varDecl exp . ; stmt ) stmt
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 369
    BIT_WIDTH_NUMBER shift and go to state 132


state 359

    (102) forStmt -> GENERATE FOR ( varDecl . exp ; exp ) COLON ID stmt
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 370
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 360

    (74) p_module_para_port -> , port_def ID p_module_para_port .

    )               reduce using rule 74 (p_module_para_port -> , port_def ID p_module_para_port .)


state 361

    (31) constInitVal_repeat -> , constInitVal constInitVal_repeat .

    }               reduce using rule 31 (constInitVal_repeat -> , constInitVal constInitVal_repeat .)


state 362

    (118) array_exp_repeat2 -> [ exp . COLON exp ] array_exp_repeat2
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    COLON           shift and go to state 257
    BIT_WIDTH_NUMBER shift and go to state 132


state 363

    (108) lVal -> MUX ( exp , exp , exp ) .

    .               reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    MUL             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    DIV             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    MOD             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    POWER           reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    ADD             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    SUB             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    SLL             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    SRL             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    SRA             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    LT              reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    GT              reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    GE              reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    LE              reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    EQUAL           reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    NEQ             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    AND             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    OR              reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    XOR             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    XNOR            reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    LAND            reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    LOR             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    ]               reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    BIT_WIDTH_NUMBER reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    )               reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    ,               reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    ;               reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    COLON           reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    }               reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    RETURN          reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    CONST           reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    ID              reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    {               reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    MUX             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    WHEN            reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    IF              reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    FOR             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    GENERATE        reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    INT             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    FLOAT           reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    REG             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    WIRE            reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    CLOCK           reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    SIGNAL          reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    (               reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    NOT             reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    NOTL            reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    INTEGER_CONST   reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    FLOAT_CONST     reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    ELIF            reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    ELSE            reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    ASSIGN          reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)
    CONNECT         reduce using rule 108 (lVal -> MUX ( exp , exp , exp ) .)


state 364

    (104) lVal -> ID . array_exp_repeat1
    (105) lVal -> ID . array_exp_repeat2
    (124) unaryExp -> ID . ( )
    (125) unaryExp -> ID . ( funcRParams )
    (115) array_exp_repeat1 -> . empty
    (116) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (117) array_exp_repeat2 -> . empty
    (118) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 154
    [               shift and go to state 158
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ELIF            reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

  ! (               [ reduce using rule 1 (empty -> .) ]

    array_exp_repeat1              shift and go to state 155
    array_exp_repeat2              shift and go to state 156
    empty                          shift and go to state 157

state 365

    (93) seqLogStmt -> WHEN ( ID ) stmt .

    ;               reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    RETURN          reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    CONST           reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    ID              reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    {               reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    MUX             reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    WHEN            reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    IF              reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    FOR             reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    GENERATE        reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    INT             reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    FLOAT           reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    REG             reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    WIRE            reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    CLOCK           reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    SIGNAL          reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    (               reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    ADD             reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    SUB             reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    NOT             reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    NOTL            reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    INTEGER_CONST   reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    FLOAT_CONST     reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    }               reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    ELIF            reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    ELSE            reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)
    )               reduce using rule 93 (seqLogStmt -> WHEN ( ID ) stmt .)


state 366

    (94) seqLogStmt -> WHEN ( ID . RISING . ) stmt

    )               shift and go to state 371


state 367

    (95) seqLogStmt -> WHEN ( ID . FALLING . ) stmt

    )               shift and go to state 372


state 368

    (100) ifStmt -> IF ( exp ) stmt . elifStmt elseStmt
    (96) elifStmt -> . ELIF ( exp ) stmt elifStmt
    (97) elifStmt -> . empty
    (1) empty -> .

  ! shift/reduce conflict for ELIF resolved as shift
    ELIF            shift and go to state 374
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

  ! ELIF            [ reduce using rule 1 (empty -> .) ]

    elifStmt                       shift and go to state 373
    empty                          shift and go to state 375

state 369

    (101) forStmt -> FOR ( varDecl exp ; . stmt ) stmt
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 272
    RETURN          shift and go to state 277
    ID              shift and go to state 364
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 271
    stmt                           shift and go to state 376
    lVal                           shift and go to state 270
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 370

    (102) forStmt -> GENERATE FOR ( varDecl exp . ; exp ) COLON ID stmt
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 377
    BIT_WIDTH_NUMBER shift and go to state 132


state 371

    (94) seqLogStmt -> WHEN ( ID . RISING ) . stmt
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 272
    RETURN          shift and go to state 277
    ID              shift and go to state 364
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    stmt                           shift and go to state 378
    lVal                           shift and go to state 270
    exp                            shift and go to state 271
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 372

    (95) seqLogStmt -> WHEN ( ID . FALLING ) . stmt
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 272
    RETURN          shift and go to state 277
    ID              shift and go to state 364
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    stmt                           shift and go to state 379
    lVal                           shift and go to state 270
    exp                            shift and go to state 271
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 373

    (100) ifStmt -> IF ( exp ) stmt elifStmt . elseStmt
    (98) elseStmt -> . ELSE stmt
    (99) elseStmt -> . empty
    (1) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 381
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ELIF            reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

  ! ELSE            [ reduce using rule 1 (empty -> .) ]

    elseStmt                       shift and go to state 380
    empty                          shift and go to state 382

state 374

    (96) elifStmt -> ELIF . ( exp ) stmt elifStmt

    (               shift and go to state 383


state 375

    (97) elifStmt -> empty .

    ;               reduce using rule 97 (elifStmt -> empty .)
    RETURN          reduce using rule 97 (elifStmt -> empty .)
    CONST           reduce using rule 97 (elifStmt -> empty .)
    ID              reduce using rule 97 (elifStmt -> empty .)
    {               reduce using rule 97 (elifStmt -> empty .)
    MUX             reduce using rule 97 (elifStmt -> empty .)
    WHEN            reduce using rule 97 (elifStmt -> empty .)
    IF              reduce using rule 97 (elifStmt -> empty .)
    FOR             reduce using rule 97 (elifStmt -> empty .)
    GENERATE        reduce using rule 97 (elifStmt -> empty .)
    INT             reduce using rule 97 (elifStmt -> empty .)
    FLOAT           reduce using rule 97 (elifStmt -> empty .)
    REG             reduce using rule 97 (elifStmt -> empty .)
    WIRE            reduce using rule 97 (elifStmt -> empty .)
    CLOCK           reduce using rule 97 (elifStmt -> empty .)
    SIGNAL          reduce using rule 97 (elifStmt -> empty .)
    (               reduce using rule 97 (elifStmt -> empty .)
    ADD             reduce using rule 97 (elifStmt -> empty .)
    SUB             reduce using rule 97 (elifStmt -> empty .)
    NOT             reduce using rule 97 (elifStmt -> empty .)
    NOTL            reduce using rule 97 (elifStmt -> empty .)
    INTEGER_CONST   reduce using rule 97 (elifStmt -> empty .)
    FLOAT_CONST     reduce using rule 97 (elifStmt -> empty .)
    }               reduce using rule 97 (elifStmt -> empty .)
    ELIF            reduce using rule 97 (elifStmt -> empty .)
    ELSE            reduce using rule 97 (elifStmt -> empty .)
    )               reduce using rule 97 (elifStmt -> empty .)


state 376

    (101) forStmt -> FOR ( varDecl exp ; stmt . ) stmt

    )               shift and go to state 384


state 377

    (102) forStmt -> GENERATE FOR ( varDecl exp ; . exp ) COLON ID stmt
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 385
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 378

    (94) seqLogStmt -> WHEN ( ID . RISING ) stmt .

    ;               reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    RETURN          reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    CONST           reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    ID              reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    {               reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    MUX             reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    WHEN            reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    IF              reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    FOR             reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    GENERATE        reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    INT             reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    FLOAT           reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    REG             reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    WIRE            reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    CLOCK           reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    SIGNAL          reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    (               reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    ADD             reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    SUB             reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    NOT             reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    NOTL            reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    INTEGER_CONST   reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    FLOAT_CONST     reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    }               reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    ELIF            reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    ELSE            reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    )               reduce using rule 94 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)


state 379

    (95) seqLogStmt -> WHEN ( ID . FALLING ) stmt .

    ;               reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    RETURN          reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    CONST           reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    ID              reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    {               reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    MUX             reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    WHEN            reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    IF              reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    FOR             reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    GENERATE        reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    INT             reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    FLOAT           reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    REG             reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    WIRE            reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    CLOCK           reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    SIGNAL          reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    (               reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    ADD             reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    SUB             reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    NOT             reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    NOTL            reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    INTEGER_CONST   reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    FLOAT_CONST     reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    }               reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    ELIF            reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    ELSE            reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    )               reduce using rule 95 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)


state 380

    (100) ifStmt -> IF ( exp ) stmt elifStmt elseStmt .

    ;               reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    RETURN          reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    CONST           reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    ID              reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    {               reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    MUX             reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    WHEN            reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    IF              reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    FOR             reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    GENERATE        reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    INT             reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    FLOAT           reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    REG             reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    WIRE            reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    CLOCK           reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    SIGNAL          reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    (               reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    ADD             reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    SUB             reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    NOT             reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    NOTL            reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    INTEGER_CONST   reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    FLOAT_CONST     reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    }               reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    ELIF            reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    ELSE            reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    )               reduce using rule 100 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)


state 381

    (98) elseStmt -> ELSE . stmt
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 272
    RETURN          shift and go to state 277
    ID              shift and go to state 364
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    stmt                           shift and go to state 386
    lVal                           shift and go to state 270
    exp                            shift and go to state 271
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 382

    (99) elseStmt -> empty .

    ;               reduce using rule 99 (elseStmt -> empty .)
    RETURN          reduce using rule 99 (elseStmt -> empty .)
    CONST           reduce using rule 99 (elseStmt -> empty .)
    ID              reduce using rule 99 (elseStmt -> empty .)
    {               reduce using rule 99 (elseStmt -> empty .)
    MUX             reduce using rule 99 (elseStmt -> empty .)
    WHEN            reduce using rule 99 (elseStmt -> empty .)
    IF              reduce using rule 99 (elseStmt -> empty .)
    FOR             reduce using rule 99 (elseStmt -> empty .)
    GENERATE        reduce using rule 99 (elseStmt -> empty .)
    INT             reduce using rule 99 (elseStmt -> empty .)
    FLOAT           reduce using rule 99 (elseStmt -> empty .)
    REG             reduce using rule 99 (elseStmt -> empty .)
    WIRE            reduce using rule 99 (elseStmt -> empty .)
    CLOCK           reduce using rule 99 (elseStmt -> empty .)
    SIGNAL          reduce using rule 99 (elseStmt -> empty .)
    (               reduce using rule 99 (elseStmt -> empty .)
    ADD             reduce using rule 99 (elseStmt -> empty .)
    SUB             reduce using rule 99 (elseStmt -> empty .)
    NOT             reduce using rule 99 (elseStmt -> empty .)
    NOTL            reduce using rule 99 (elseStmt -> empty .)
    INTEGER_CONST   reduce using rule 99 (elseStmt -> empty .)
    FLOAT_CONST     reduce using rule 99 (elseStmt -> empty .)
    }               reduce using rule 99 (elseStmt -> empty .)
    ELIF            reduce using rule 99 (elseStmt -> empty .)
    ELSE            reduce using rule 99 (elseStmt -> empty .)
    )               reduce using rule 99 (elseStmt -> empty .)


state 383

    (96) elifStmt -> ELIF ( . exp ) stmt elifStmt
    (103) exp -> . lOrExp
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 82
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    {               shift and go to state 90
    MUX             shift and go to state 91
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 387
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    lVal                           shift and go to state 86
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 384

    (101) forStmt -> FOR ( varDecl exp ; stmt ) . stmt
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 272
    RETURN          shift and go to state 277
    ID              shift and go to state 364
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 271
    stmt                           shift and go to state 388
    lVal                           shift and go to state 270
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 385

    (102) forStmt -> GENERATE FOR ( varDecl exp ; exp . ) COLON ID stmt
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 389
    BIT_WIDTH_NUMBER shift and go to state 132


state 386

    (98) elseStmt -> ELSE stmt .

    ;               reduce using rule 98 (elseStmt -> ELSE stmt .)
    RETURN          reduce using rule 98 (elseStmt -> ELSE stmt .)
    CONST           reduce using rule 98 (elseStmt -> ELSE stmt .)
    ID              reduce using rule 98 (elseStmt -> ELSE stmt .)
    {               reduce using rule 98 (elseStmt -> ELSE stmt .)
    MUX             reduce using rule 98 (elseStmt -> ELSE stmt .)
    WHEN            reduce using rule 98 (elseStmt -> ELSE stmt .)
    IF              reduce using rule 98 (elseStmt -> ELSE stmt .)
    FOR             reduce using rule 98 (elseStmt -> ELSE stmt .)
    GENERATE        reduce using rule 98 (elseStmt -> ELSE stmt .)
    INT             reduce using rule 98 (elseStmt -> ELSE stmt .)
    FLOAT           reduce using rule 98 (elseStmt -> ELSE stmt .)
    REG             reduce using rule 98 (elseStmt -> ELSE stmt .)
    WIRE            reduce using rule 98 (elseStmt -> ELSE stmt .)
    CLOCK           reduce using rule 98 (elseStmt -> ELSE stmt .)
    SIGNAL          reduce using rule 98 (elseStmt -> ELSE stmt .)
    (               reduce using rule 98 (elseStmt -> ELSE stmt .)
    ADD             reduce using rule 98 (elseStmt -> ELSE stmt .)
    SUB             reduce using rule 98 (elseStmt -> ELSE stmt .)
    NOT             reduce using rule 98 (elseStmt -> ELSE stmt .)
    NOTL            reduce using rule 98 (elseStmt -> ELSE stmt .)
    INTEGER_CONST   reduce using rule 98 (elseStmt -> ELSE stmt .)
    FLOAT_CONST     reduce using rule 98 (elseStmt -> ELSE stmt .)
    }               reduce using rule 98 (elseStmt -> ELSE stmt .)
    ELIF            reduce using rule 98 (elseStmt -> ELSE stmt .)
    ELSE            reduce using rule 98 (elseStmt -> ELSE stmt .)
    )               reduce using rule 98 (elseStmt -> ELSE stmt .)


state 387

    (96) elifStmt -> ELIF ( exp . ) stmt elifStmt
    (122) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 390
    BIT_WIDTH_NUMBER shift and go to state 132


state 388

    (101) forStmt -> FOR ( varDecl exp ; stmt ) stmt .

    ;               reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    RETURN          reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    CONST           reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    ID              reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    {               reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    MUX             reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    WHEN            reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    IF              reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    FOR             reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    GENERATE        reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    INT             reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    FLOAT           reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    REG             reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    WIRE            reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    CLOCK           reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    SIGNAL          reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    (               reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    ADD             reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    SUB             reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    NOT             reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    NOTL            reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    INTEGER_CONST   reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    FLOAT_CONST     reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    }               reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    ELIF            reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    ELSE            reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)
    )               reduce using rule 101 (forStmt -> FOR ( varDecl exp ; stmt ) stmt .)


state 389

    (102) forStmt -> GENERATE FOR ( varDecl exp ; exp ) . COLON ID stmt

    COLON           shift and go to state 391


state 390

    (96) elifStmt -> ELIF ( exp ) . stmt elifStmt
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 272
    RETURN          shift and go to state 277
    ID              shift and go to state 364
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 271
    stmt                           shift and go to state 392
    lVal                           shift and go to state 270
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 391

    (102) forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON . ID stmt

    ID              shift and go to state 393


state 392

    (96) elifStmt -> ELIF ( exp ) stmt . elifStmt
    (96) elifStmt -> . ELIF ( exp ) stmt elifStmt
    (97) elifStmt -> . empty
    (1) empty -> .

  ! shift/reduce conflict for ELIF resolved as shift
    ELIF            shift and go to state 374
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

  ! ELIF            [ reduce using rule 1 (empty -> .) ]

    elifStmt                       shift and go to state 394
    empty                          shift and go to state 375

state 393

    (102) forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID . stmt
    (84) stmt -> . lVal ASSIGN exp ;
    (85) stmt -> . lVal CONNECT exp ;
    (86) stmt -> . ;
    (87) stmt -> . exp
    (88) stmt -> . block
    (89) stmt -> . seqLogStmt
    (90) stmt -> . ifStmt
    (91) stmt -> . forStmt
    (92) stmt -> . RETURN exp ;
    (104) lVal -> . ID array_exp_repeat1
    (105) lVal -> . ID array_exp_repeat2
    (106) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (107) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (108) lVal -> . MUX ( exp , exp , exp )
    (109) lVal -> . lVal . ID
    (103) exp -> . lOrExp
    (81) block -> . { block_repeat }
    (93) seqLogStmt -> . WHEN ( ID ) stmt
    (94) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (95) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (100) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (101) forStmt -> . FOR ( varDecl exp ; stmt ) stmt
    (102) forStmt -> . GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt
    (163) lOrExp -> . lAndExp
    (164) lOrExp -> . lOrExp LOR lAndExp
    (161) lAndExp -> . redExp
    (162) lAndExp -> . lAndExp LAND redExp
    (156) redExp -> . eqExp
    (157) redExp -> . redExp AND eqExp
    (158) redExp -> . redExp OR eqExp
    (159) redExp -> . redExp XOR eqExp
    (160) redExp -> . redExp XNOR eqExp
    (153) eqExp -> . relExp
    (154) eqExp -> . eqExp EQUAL eqExp
    (155) eqExp -> . eqExp NEQ eqExp
    (148) relExp -> . shiftExp
    (149) relExp -> . relExp LT addExp
    (150) relExp -> . relExp GT addExp
    (151) relExp -> . relExp GE addExp
    (152) relExp -> . relExp LE addExp
    (144) shiftExp -> . addExp
    (145) shiftExp -> . shiftExp SLL addExp
    (146) shiftExp -> . shiftExp SRL addExp
    (147) shiftExp -> . shiftExp SRA addExp
    (141) addExp -> . mulExp
    (142) addExp -> . addExp ADD mulExp
    (143) addExp -> . addExp SUB mulExp
    (136) mulExp -> . unaryExp
    (137) mulExp -> . mulExp MUL unaryExp
    (138) mulExp -> . mulExp DIV unaryExp
    (139) mulExp -> . mulExp MOD unaryExp
    (140) mulExp -> . mulExp POWER unaryExp
    (123) unaryExp -> . primaryExp
    (124) unaryExp -> . ID ( )
    (125) unaryExp -> . ID ( funcRParams )
    (126) unaryExp -> . SIGNAL ( unaryExp )
    (127) unaryExp -> . unaryOp unaryExp
    (110) primaryExp -> . ( exp )
    (111) primaryExp -> . lVal
    (112) primaryExp -> . number
    (128) unaryOp -> . ADD
    (129) unaryOp -> . SUB
    (130) unaryOp -> . NOT
    (131) unaryOp -> . NOTL
    (119) number -> . INTEGER_CONST
    (120) number -> . FLOAT_CONST
    (121) number -> . circuit_const
    (122) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 272
    RETURN          shift and go to state 277
    ID              shift and go to state 364
    {               shift and go to state 264
    MUX             shift and go to state 91
    WHEN            shift and go to state 281
    IF              shift and go to state 282
    FOR             shift and go to state 283
    GENERATE        shift and go to state 284
    SIGNAL          shift and go to state 84
    (               shift and go to state 83
    ADD             shift and go to state 78
    SUB             shift and go to state 79
    NOT             shift and go to state 88
    NOTL            shift and go to state 89
    INTEGER_CONST   shift and go to state 92
    FLOAT_CONST     shift and go to state 93

    exp                            shift and go to state 271
    stmt                           shift and go to state 395
    lVal                           shift and go to state 270
    block                          shift and go to state 273
    seqLogStmt                     shift and go to state 274
    ifStmt                         shift and go to state 275
    forStmt                        shift and go to state 276
    lOrExp                         shift and go to state 70
    lAndExp                        shift and go to state 71
    redExp                         shift and go to state 72
    eqExp                          shift and go to state 73
    relExp                         shift and go to state 74
    shiftExp                       shift and go to state 75
    addExp                         shift and go to state 76
    mulExp                         shift and go to state 77
    unaryExp                       shift and go to state 80
    primaryExp                     shift and go to state 81
    unaryOp                        shift and go to state 85
    number                         shift and go to state 87
    circuit_const                  shift and go to state 94

state 394

    (96) elifStmt -> ELIF ( exp ) stmt elifStmt .

    ;               reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    RETURN          reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    CONST           reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    ID              reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    {               reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    MUX             reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    WHEN            reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    IF              reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    FOR             reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    GENERATE        reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    INT             reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    FLOAT           reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    REG             reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    WIRE            reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    CLOCK           reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    SIGNAL          reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    (               reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    ADD             reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    SUB             reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    NOT             reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    NOTL            reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    INTEGER_CONST   reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    FLOAT_CONST     reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    }               reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    ELIF            reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    ELSE            reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)
    )               reduce using rule 96 (elifStmt -> ELIF ( exp ) stmt elifStmt .)


state 395

    (102) forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .

    ;               reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    RETURN          reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    CONST           reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    ID              reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    {               reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    MUX             reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    WHEN            reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    IF              reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    FOR             reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    GENERATE        reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    INT             reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    FLOAT           reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    REG             reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    WIRE            reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    CLOCK           reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    SIGNAL          reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    (               reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    ADD             reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    SUB             reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    NOT             reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    NOTL            reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    INTEGER_CONST   reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    FLOAT_CONST     reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    }               reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    ELIF            reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    ELSE            reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)
    )               reduce using rule 102 (forStmt -> GENERATE FOR ( varDecl exp ; exp ) COLON ID stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MODULE in state 2 resolved as shift
WARNING: shift/reduce conflict for BUNDLE in state 2 resolved as shift
WARNING: shift/reduce conflict for CONST in state 2 resolved as shift
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
WARNING: shift/reduce conflict for INT in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for REG in state 2 resolved as shift
WARNING: shift/reduce conflict for WIRE in state 2 resolved as shift
WARNING: shift/reduce conflict for CLOCK in state 2 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 3 resolved as shift
WARNING: shift/reduce conflict for BUNDLE in state 3 resolved as shift
WARNING: shift/reduce conflict for CONST in state 3 resolved as shift
WARNING: shift/reduce conflict for ID in state 3 resolved as shift
WARNING: shift/reduce conflict for INT in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for REG in state 3 resolved as shift
WARNING: shift/reduce conflict for WIRE in state 3 resolved as shift
WARNING: shift/reduce conflict for CLOCK in state 3 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 4 resolved as shift
WARNING: shift/reduce conflict for BUNDLE in state 4 resolved as shift
WARNING: shift/reduce conflict for CONST in state 4 resolved as shift
WARNING: shift/reduce conflict for ID in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for REG in state 4 resolved as shift
WARNING: shift/reduce conflict for WIRE in state 4 resolved as shift
WARNING: shift/reduce conflict for CLOCK in state 4 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 5 resolved as shift
WARNING: shift/reduce conflict for BUNDLE in state 5 resolved as shift
WARNING: shift/reduce conflict for CONST in state 5 resolved as shift
WARNING: shift/reduce conflict for ID in state 5 resolved as shift
WARNING: shift/reduce conflict for INT in state 5 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 5 resolved as shift
WARNING: shift/reduce conflict for REG in state 5 resolved as shift
WARNING: shift/reduce conflict for WIRE in state 5 resolved as shift
WARNING: shift/reduce conflict for CLOCK in state 5 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 6 resolved as shift
WARNING: shift/reduce conflict for BUNDLE in state 6 resolved as shift
WARNING: shift/reduce conflict for CONST in state 6 resolved as shift
WARNING: shift/reduce conflict for ID in state 6 resolved as shift
WARNING: shift/reduce conflict for INT in state 6 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 6 resolved as shift
WARNING: shift/reduce conflict for REG in state 6 resolved as shift
WARNING: shift/reduce conflict for WIRE in state 6 resolved as shift
WARNING: shift/reduce conflict for CLOCK in state 6 resolved as shift
WARNING: shift/reduce conflict for ID in state 13 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 26 resolved as shift
WARNING: shift/reduce conflict for BUNDLE in state 26 resolved as shift
WARNING: shift/reduce conflict for CONST in state 26 resolved as shift
WARNING: shift/reduce conflict for ID in state 26 resolved as shift
WARNING: shift/reduce conflict for INT in state 26 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 26 resolved as shift
WARNING: shift/reduce conflict for REG in state 26 resolved as shift
WARNING: shift/reduce conflict for WIRE in state 26 resolved as shift
WARNING: shift/reduce conflict for CLOCK in state 26 resolved as shift
WARNING: shift/reduce conflict for ADD in state 76 resolved as shift
WARNING: shift/reduce conflict for SUB in state 76 resolved as shift
WARNING: shift/reduce conflict for ( in state 82 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 202 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 202 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 203 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 203 resolved as shift
WARNING: shift/reduce conflict for ADD in state 204 resolved as shift
WARNING: shift/reduce conflict for SUB in state 204 resolved as shift
WARNING: shift/reduce conflict for ADD in state 205 resolved as shift
WARNING: shift/reduce conflict for SUB in state 205 resolved as shift
WARNING: shift/reduce conflict for ADD in state 206 resolved as shift
WARNING: shift/reduce conflict for SUB in state 206 resolved as shift
WARNING: shift/reduce conflict for ADD in state 207 resolved as shift
WARNING: shift/reduce conflict for SUB in state 207 resolved as shift
WARNING: shift/reduce conflict for ADD in state 208 resolved as shift
WARNING: shift/reduce conflict for SUB in state 208 resolved as shift
WARNING: shift/reduce conflict for ADD in state 209 resolved as shift
WARNING: shift/reduce conflict for SUB in state 209 resolved as shift
WARNING: shift/reduce conflict for ADD in state 210 resolved as shift
WARNING: shift/reduce conflict for SUB in state 210 resolved as shift
WARNING: shift/reduce conflict for ID in state 280 resolved as shift
WARNING: shift/reduce conflict for [ in state 280 resolved as shift
WARNING: shift/reduce conflict for ID in state 280 resolved as shift
WARNING: shift/reduce conflict for ( in state 280 resolved as shift
WARNING: shift/reduce conflict for , in state 289 resolved as shift
WARNING: shift/reduce conflict for , in state 290 resolved as shift
WARNING: shift/reduce conflict for [ in state 311 resolved as shift
WARNING: shift/reduce conflict for ID in state 311 resolved as shift
WARNING: shift/reduce conflict for ID in state 311 resolved as shift
WARNING: shift/reduce conflict for ( in state 311 resolved as shift
WARNING: shift/reduce conflict for ( in state 364 resolved as shift
WARNING: shift/reduce conflict for ELIF in state 368 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 373 resolved as shift
WARNING: shift/reduce conflict for ELIF in state 392 resolved as shift
WARNING: reduce/reduce conflict in state 157 resolved using rule (array_exp_repeat1 -> empty)
WARNING: rejected rule (array_exp_repeat2 -> empty) in state 157
WARNING: reduce/reduce conflict in state 161 resolved using rule (unaryExp -> unaryOp unaryExp)
WARNING: rejected rule (mulExp -> unaryExp) in state 161
WARNING: reduce/reduce conflict in state 196 resolved using rule (lOrExp -> lAndExp)
WARNING: rejected rule (lOrExp -> lOrExp LOR lAndExp) in state 196
WARNING: reduce/reduce conflict in state 197 resolved using rule (lAndExp -> redExp)
WARNING: rejected rule (lAndExp -> lAndExp LAND redExp) in state 197
WARNING: reduce/reduce conflict in state 198 resolved using rule (redExp -> eqExp)
WARNING: rejected rule (redExp -> redExp AND eqExp) in state 198
WARNING: reduce/reduce conflict in state 199 resolved using rule (redExp -> eqExp)
WARNING: rejected rule (redExp -> redExp OR eqExp) in state 199
WARNING: reduce/reduce conflict in state 200 resolved using rule (redExp -> eqExp)
WARNING: rejected rule (redExp -> redExp XOR eqExp) in state 200
WARNING: reduce/reduce conflict in state 201 resolved using rule (redExp -> eqExp)
WARNING: rejected rule (redExp -> redExp XNOR eqExp) in state 201
WARNING: reduce/reduce conflict in state 202 resolved using rule (eqExp -> eqExp EQUAL eqExp)
WARNING: rejected rule (redExp -> eqExp) in state 202
WARNING: reduce/reduce conflict in state 203 resolved using rule (eqExp -> eqExp NEQ eqExp)
WARNING: rejected rule (redExp -> eqExp) in state 203
WARNING: reduce/reduce conflict in state 204 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (relExp -> relExp LT addExp) in state 204
WARNING: reduce/reduce conflict in state 205 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (relExp -> relExp GT addExp) in state 205
WARNING: reduce/reduce conflict in state 206 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (relExp -> relExp GE addExp) in state 206
WARNING: reduce/reduce conflict in state 207 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (relExp -> relExp LE addExp) in state 207
WARNING: reduce/reduce conflict in state 208 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (shiftExp -> shiftExp SLL addExp) in state 208
WARNING: reduce/reduce conflict in state 209 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (shiftExp -> shiftExp SRL addExp) in state 209
WARNING: reduce/reduce conflict in state 210 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (shiftExp -> shiftExp SRA addExp) in state 210
WARNING: reduce/reduce conflict in state 211 resolved using rule (addExp -> mulExp)
WARNING: rejected rule (addExp -> addExp ADD mulExp) in state 211
WARNING: reduce/reduce conflict in state 212 resolved using rule (addExp -> mulExp)
WARNING: rejected rule (addExp -> addExp SUB mulExp) in state 212
WARNING: reduce/reduce conflict in state 213 resolved using rule (mulExp -> unaryExp)
WARNING: rejected rule (mulExp -> mulExp MUL unaryExp) in state 213
WARNING: reduce/reduce conflict in state 214 resolved using rule (mulExp -> unaryExp)
WARNING: rejected rule (mulExp -> mulExp DIV unaryExp) in state 214
WARNING: reduce/reduce conflict in state 215 resolved using rule (mulExp -> unaryExp)
WARNING: rejected rule (mulExp -> mulExp MOD unaryExp) in state 215
WARNING: reduce/reduce conflict in state 216 resolved using rule (mulExp -> unaryExp)
WARNING: rejected rule (mulExp -> mulExp POWER unaryExp) in state 216
WARNING: reduce/reduce conflict in state 219 resolved using rule (empty -> <empty>)
WARNING: rejected rule (funcRParams -> exp) in state 219
WARNING: reduce/reduce conflict in state 289 resolved using rule (empty -> <empty>)
WARNING: rejected rule (lVal -> ID array_exp_repeat1) in state 289
WARNING: reduce/reduce conflict in state 290 resolved using rule (empty -> <empty>)
WARNING: rejected rule (lVal -> ID array_exp_repeat2) in state 290
WARNING: reduce/reduce conflict in state 297 resolved using rule (empty -> <empty>)
WARNING: rejected rule (module_para_para -> PARA val_type ID ,) in state 297
WARNING: Rule (funcRParams -> exp) is never reduced
WARNING: Rule (module_para_para -> PARA val_type ID ,) is never reduced
