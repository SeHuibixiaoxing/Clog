Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> compUnit
Rule 1     empty -> <empty>
Rule 2     compUnit -> empty
Rule 3     compUnit -> compUnit compUnit
Rule 4     compUnit -> decl
Rule 5     compUnit -> cir_function
Rule 6     compUnit -> function
Rule 7     compUnit -> module
Rule 8     compUnit -> bundle
Rule 9     decl -> constDecl
Rule 10    decl -> varDecl
Rule 11    decl -> cirDecl
Rule 12    decl -> modDecl
Rule 13    decl -> bundleDecl
Rule 14    constDecl_repeat -> empty
Rule 15    constDecl_repeat -> , constDef constDecl_repeat
Rule 16    constDecl -> CONST val_type constDef constDecl_repeat ;
Rule 17    cir_basic_type -> REG
Rule 18    cir_basic_type -> WIRE
Rule 19    cir_basic_type -> CLOCK
Rule 20    cir_type -> cir_basic_type
Rule 21    cir_type -> cir_basic_type [ exp ]
Rule 22    val_type -> INT
Rule 23    val_type -> FLOAT
Rule 24    type_def -> val_type
Rule 25    type_def -> cir_type
Rule 26    array -> empty
Rule 27    array -> [ constExp ] array
Rule 28    constDef -> ID array ASSIGN constInitVal
Rule 29    constInitVal_repeat -> empty
Rule 30    constInitVal_repeat -> , constInitVal constInitVal_repeat
Rule 31    constInitVal -> constExp
Rule 32    constInitVal -> { constInitVal constInitVal_repeat }
Rule 33    varDef_repeat -> empty
Rule 34    varDef_repeat -> , varDef varDef_repeat
Rule 35    varDecl -> val_type varDef varDef_repeat ;
Rule 36    varDef -> ID array
Rule 37    varDef -> ID array ASSIGN initVal
Rule 38    modDecl -> ID ID ( module_R_params )
Rule 39    R_port_def -> IN .
Rule 40    R_port_def -> OUT .
Rule 41    R_port_def -> INOUT .
Rule 42    p_module_R_params_item -> R_port_def ID ( ID )
Rule 43    module_R_params_repeat -> empty
Rule 44    module_R_params_repeat -> , p_module_R_params_item module_R_params_repeat
Rule 45    module_R_params -> p_module_R_params_item module_R_params_repeat
Rule 46    bundleDecl_repeat -> empty
Rule 47    bundleDecl_repeat -> , bundleDef bundleDecl_repeat
Rule 48    bundleDecl -> ID bundleDef bundleDecl_repeat
Rule 49    bundleDef -> ID array
Rule 50    initVal -> exp ;
Rule 51    cirDecl_repeat -> empty
Rule 52    cirDecl_repeat -> , cirDef cirDecl_repeat
Rule 53    cirDecl -> cir_type cirDef cirDecl_repeat ;
Rule 54    cirDef -> ID array
Rule 55    cirDef -> ID array ASSIGN initVal
Rule 56    cir_function -> cir_type ID ( cir_funcFParams ) block
Rule 57    function -> val_type ID ( funcFParams ) block
Rule 58    cir_funcFParams_repeat -> empty
Rule 59    cir_funcFParams_repeat -> , cir_funcFParam cir_funcFParams_repeat
Rule 60    cir_funcFParams -> cir_funcFParam cir_funcFParams_repeat
Rule 61    funcFParams_repeat -> empty
Rule 62    funcFParams_repeat -> , funcFParam funcFParams_repeat
Rule 63    funcFParams -> funcFParam funcFParams_repeat
Rule 64    cir_funcFParam -> type_def ID array
Rule 65    funcFParam -> val_type ID array
Rule 66    module_para_para -> empty
Rule 67    module_para_para -> PARA ID , module_para_para
Rule 68    p_module_para_port -> empty
Rule 69    p_module_para_port -> , port_def ID p_module_para_port
Rule 70    module -> MODULE ID ( module_para_para port_def ID p_module_para_port
Rule 71    bundle_repeat -> empty
Rule 72    bundle_repeat -> , cir_type ID bundle bundle_repeat
Rule 73    bundle -> BUNDLE ID ( cir_type ID bundle_repeat )
Rule 74    block_repeat -> empty
Rule 75    block_repeat -> blockItem block_repeat
Rule 76    block -> { block_repeat }
Rule 77    blockItem -> decl
Rule 78    blockItem -> stmt
Rule 79    stmt -> lVal ASSIGN exp ;
Rule 80    stmt -> lVal CONNECT exp ;
Rule 81    stmt -> ;
Rule 82    stmt -> exp
Rule 83    stmt -> block
Rule 84    stmt -> seqLogStmt
Rule 85    stmt -> ifStmt
Rule 86    stmt -> forStmt
Rule 87    stmt -> RETURN exp ;
Rule 88    seqLogStmt -> WHEN ( ID ) stmt
Rule 89    seqLogStmt -> WHEN ( ID . RISING ) stmt
Rule 90    seqLogStmt -> WHEN ( ID . FALLING ) stmt
Rule 91    elifStmt -> ELIF ( exp ) stmt elifStmt
Rule 92    elifStmt -> empty
Rule 93    elseStmt -> ELSE stmt
Rule 94    ifStmt -> IF ( exp ) stmt elifStmt elseStmt
Rule 95    forStmt -> FOR ( varDecl ; exp ; exp ) stmt
Rule 96    forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
Rule 97    exp -> lOrExp
Rule 98    lVal -> ID array_exp_repeat1
Rule 99    lVal -> ID array_exp_repeat2
Rule 100   lVal -> { ID array_exp_repeat1 lVal_repeat }
Rule 101   lVal -> { ID array_exp_repeat2 lVal_repeat }
Rule 102   lVal -> MUX ( exp , exp , exp )
Rule 103   lVal -> lVal . ID
Rule 104   primaryExp -> ( exp )
Rule 105   primaryExp -> lVal
Rule 106   primaryExp -> number
Rule 107   lVal_repeat -> empty
Rule 108   lVal_repeat -> , lVal lVal_repeat
Rule 109   array_exp_repeat1 -> empty
Rule 110   array_exp_repeat1 -> [ exp ] array_exp_repeat1
Rule 111   array_exp_repeat2 -> empty
Rule 112   array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2
Rule 113   number -> INTEGER_CONST
Rule 114   number -> FLOAT_CONST
Rule 115   number -> circuit_const
Rule 116   circuit_const -> exp BIT_WIDTH_NUMBER
Rule 117   unaryExp -> primaryExp
Rule 118   unaryExp -> ID ( )
Rule 119   unaryExp -> ID ( funcRParams )
Rule 120   unaryExp -> SIGNAL ( unaryExp )
Rule 121   unaryExp -> unaryOp unaryExp
Rule 122   unaryOp -> ADD
Rule 123   unaryOp -> SUB
Rule 124   unaryOp -> NOT
Rule 125   unaryOp -> NOTL
Rule 126   exp_repeat -> empty
Rule 127   exp_repeat -> , exp exp_repeat
Rule 128   funcRParams -> exp
Rule 129   funcRParams -> exp exp_repeat
Rule 130   mulExp -> unaryExp
Rule 131   mulExp -> mulExp MUL unaryExp
Rule 132   mulExp -> mulExp DIV unaryExp
Rule 133   mulExp -> mulExp MOD unaryExp
Rule 134   mulExp -> mulExp POWER unaryExp
Rule 135   addExp -> mulExp
Rule 136   addExp -> addExp ADD mulExp
Rule 137   addExp -> addExp SUB mulExp
Rule 138   shiftExp -> addExp
Rule 139   shiftExp -> shiftExp SLL addExp
Rule 140   shiftExp -> shiftExp SRL addExp
Rule 141   shiftExp -> shiftExp SRA addExp
Rule 142   relExp -> shiftExp
Rule 143   relExp -> relExp LT addExp
Rule 144   relExp -> relExp GT addExp
Rule 145   relExp -> relExp GE addExp
Rule 146   relExp -> relExp LE addExp
Rule 147   eqExp -> relExp
Rule 148   eqExp -> eqExp LT eqExp
Rule 149   eqExp -> eqExp GT eqExp
Rule 150   eqExp -> eqExp GE eqExp
Rule 151   eqExp -> eqExp LE eqExp
Rule 152   eqExp -> eqExp EQUAL eqExp
Rule 153   eqExp -> eqExp NEQ eqExp
Rule 154   redExp -> eqExp
Rule 155   redExp -> AND eqExp
Rule 156   redExp -> OR eqExp
Rule 157   redExp -> NOT eqExp
Rule 158   redExp -> XOR eqExp
Rule 159   redExp -> XNOR eqExp
Rule 160   lAndExp -> redExp
Rule 161   lAndExp -> lAndExp LAND redExp
Rule 162   lOrExp -> lAndExp
Rule 163   lOrExp -> lOrExp LOR lAndExp
Rule 164   port_def -> INPUT
Rule 165   port_def -> OUTPUT
Rule 166   port_def -> INOUT
Rule 167   constExp -> exp

Terminals, with rules where they appear

(                    : 38 42 56 57 70 73 88 89 90 91 94 95 96 102 104 118 119 120
)                    : 38 42 56 57 73 88 89 90 91 94 95 96 102 104 118 119 120
,                    : 15 30 34 44 47 52 59 62 67 69 72 102 102 108 127
.                    : 39 40 41 89 90 103
;                    : 16 35 50 53 79 80 81 87 95 95 96 96
ADD                  : 122 136
AND                  : 155
ASSIGN               : 28 37 55 79
BIT_WIDTH_NUMBER     : 116
BUNDLE               : 73
CLOCK                : 19
COLON                : 96 112
CONNECT              : 80
CONST                : 16
DIV                  : 132
ELIF                 : 91
ELSE                 : 93
EQUAL                : 152
FALLING              : 90
FLOAT                : 23
FLOAT_CONST          : 114
FOR                  : 95 96
GE                   : 145 150
GENERATE             : 96
GT                   : 144 149
ID                   : 28 36 37 38 38 42 42 48 49 54 55 56 57 64 65 67 69 70 70 72 73 73 88 89 90 96 98 99 100 101 103 118 119
IF                   : 94
IN                   : 39
INOUT                : 41 166
INPUT                : 164
INT                  : 22
INTEGER_CONST        : 113
LAND                 : 161
LE                   : 146 151
LOR                  : 163
LT                   : 143 148
MOD                  : 133
MODULE               : 70
MUL                  : 131
MUX                  : 102
NEQ                  : 153
NOT                  : 124 157
NOTL                 : 125
OR                   : 156
OUT                  : 40
OUTPUT               : 165
PARA                 : 67
POWER                : 134
REG                  : 17
RETURN               : 87
RISING               : 89
SIGNAL               : 120
SLL                  : 139
SRA                  : 141
SRL                  : 140
SUB                  : 123 137
WHEN                 : 88 89 90
WIRE                 : 18
XNOR                 : 159
XOR                  : 158
[                    : 21 27 110 112
]                    : 21 27 110 112
error                : 
{                    : 32 76 100 101
}                    : 32 76 100 101

Nonterminals, with rules where they appear

R_port_def           : 42
addExp               : 136 137 138 139 140 141 143 144 145 146
array                : 27 28 36 37 49 54 55 64 65
array_exp_repeat1    : 98 100 110
array_exp_repeat2    : 99 101 112
block                : 56 57 83
blockItem            : 75
block_repeat         : 75 76
bundle               : 8 72
bundleDecl           : 13
bundleDecl_repeat    : 47 48
bundleDef            : 47 48
bundle_repeat        : 72 73
cirDecl              : 11
cirDecl_repeat       : 52 53
cirDef               : 52 53
cir_basic_type       : 20 21
cir_funcFParam       : 59 60
cir_funcFParams      : 56
cir_funcFParams_repeat : 59 60
cir_function         : 5
cir_type             : 25 53 56 72 73
circuit_const        : 115
compUnit             : 3 3 0
constDecl            : 9
constDecl_repeat     : 15 16
constDef             : 15 16
constExp             : 27 31
constInitVal         : 28 30 32
constInitVal_repeat  : 30 32
decl                 : 4 77
elifStmt             : 91 94
elseStmt             : 94
empty                : 2 14 26 29 33 43 46 51 58 61 66 68 71 74 92 107 109 111 126
eqExp                : 148 148 149 149 150 150 151 151 152 152 153 153 154 155 156 157 158 159
exp                  : 21 50 79 80 82 87 91 94 95 95 96 96 102 102 102 104 110 112 112 116 127 128 129 167
exp_repeat           : 127 129
forStmt              : 86
funcFParam           : 62 63
funcFParams          : 57
funcFParams_repeat   : 62 63
funcRParams          : 119
function             : 6
ifStmt               : 85
initVal              : 37 55
lAndExp              : 161 162 163
lOrExp               : 97 163
lVal                 : 79 80 103 105 108
lVal_repeat          : 100 101 108
modDecl              : 12
module               : 7
module_R_params      : 38
module_R_params_repeat : 44 45
module_para_para     : 67 70
mulExp               : 131 132 133 134 135 136 137
number               : 106
p_module_R_params_item : 44 45
p_module_para_port   : 69 70
port_def             : 69 70
primaryExp           : 117
redExp               : 160 161
relExp               : 143 144 145 146 147
seqLogStmt           : 84
shiftExp             : 139 140 141 142
stmt                 : 78 88 89 90 91 93 94 95 96
type_def             : 64
unaryExp             : 120 121 130 131 132 133 134
unaryOp              : 121
val_type             : 16 24 35 57 65
varDecl              : 10 95 96
varDef               : 34 35
varDef_repeat        : 34 35

Parsing method: LALR

state 0

    (0) S' -> . compUnit
    (2) compUnit -> . empty
    (3) compUnit -> . compUnit compUnit
    (4) compUnit -> . decl
    (5) compUnit -> . cir_function
    (6) compUnit -> . function
    (7) compUnit -> . module
    (8) compUnit -> . bundle
    (1) empty -> .
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (56) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (57) function -> . val_type ID ( funcFParams ) block
    (70) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port
    (73) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (53) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (38) modDecl -> . ID ID ( module_R_params )
    (48) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK

  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    $end            reduce using rule 1 (empty -> .)
    MODULE          shift and go to state 16
    BUNDLE          shift and go to state 17
    CONST           shift and go to state 18
    ID              shift and go to state 14
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24

  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]

    compUnit                       shift and go to state 1
    empty                          shift and go to state 2
    decl                           shift and go to state 3
    cir_function                   shift and go to state 4
    function                       shift and go to state 5
    module                         shift and go to state 6
    bundle                         shift and go to state 7
    constDecl                      shift and go to state 8
    varDecl                        shift and go to state 9
    cirDecl                        shift and go to state 10
    modDecl                        shift and go to state 11
    bundleDecl                     shift and go to state 12
    cir_type                       shift and go to state 13
    val_type                       shift and go to state 15
    cir_basic_type                 shift and go to state 19

state 1

    (0) S' -> compUnit .
    (3) compUnit -> compUnit . compUnit
    (2) compUnit -> . empty
    (3) compUnit -> . compUnit compUnit
    (4) compUnit -> . decl
    (5) compUnit -> . cir_function
    (6) compUnit -> . function
    (7) compUnit -> . module
    (8) compUnit -> . bundle
    (1) empty -> .
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (56) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (57) function -> . val_type ID ( funcFParams ) block
    (70) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port
    (73) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (53) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (38) modDecl -> . ID ID ( module_R_params )
    (48) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK

  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    MODULE          shift and go to state 16
    BUNDLE          shift and go to state 17
    CONST           shift and go to state 18
    ID              shift and go to state 14
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24

  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]
  ! $end            [ reduce using rule 1 (empty -> .) ]

    compUnit                       shift and go to state 25
    empty                          shift and go to state 2
    decl                           shift and go to state 3
    cir_function                   shift and go to state 4
    function                       shift and go to state 5
    module                         shift and go to state 6
    bundle                         shift and go to state 7
    constDecl                      shift and go to state 8
    varDecl                        shift and go to state 9
    cirDecl                        shift and go to state 10
    modDecl                        shift and go to state 11
    bundleDecl                     shift and go to state 12
    cir_type                       shift and go to state 13
    val_type                       shift and go to state 15
    cir_basic_type                 shift and go to state 19

state 2

    (2) compUnit -> empty .

    MODULE          reduce using rule 2 (compUnit -> empty .)
    BUNDLE          reduce using rule 2 (compUnit -> empty .)
    CONST           reduce using rule 2 (compUnit -> empty .)
    ID              reduce using rule 2 (compUnit -> empty .)
    INT             reduce using rule 2 (compUnit -> empty .)
    FLOAT           reduce using rule 2 (compUnit -> empty .)
    REG             reduce using rule 2 (compUnit -> empty .)
    WIRE            reduce using rule 2 (compUnit -> empty .)
    CLOCK           reduce using rule 2 (compUnit -> empty .)
    $end            reduce using rule 2 (compUnit -> empty .)


state 3

    (4) compUnit -> decl .

    MODULE          reduce using rule 4 (compUnit -> decl .)
    BUNDLE          reduce using rule 4 (compUnit -> decl .)
    CONST           reduce using rule 4 (compUnit -> decl .)
    ID              reduce using rule 4 (compUnit -> decl .)
    INT             reduce using rule 4 (compUnit -> decl .)
    FLOAT           reduce using rule 4 (compUnit -> decl .)
    REG             reduce using rule 4 (compUnit -> decl .)
    WIRE            reduce using rule 4 (compUnit -> decl .)
    CLOCK           reduce using rule 4 (compUnit -> decl .)
    $end            reduce using rule 4 (compUnit -> decl .)


state 4

    (5) compUnit -> cir_function .

    MODULE          reduce using rule 5 (compUnit -> cir_function .)
    BUNDLE          reduce using rule 5 (compUnit -> cir_function .)
    CONST           reduce using rule 5 (compUnit -> cir_function .)
    ID              reduce using rule 5 (compUnit -> cir_function .)
    INT             reduce using rule 5 (compUnit -> cir_function .)
    FLOAT           reduce using rule 5 (compUnit -> cir_function .)
    REG             reduce using rule 5 (compUnit -> cir_function .)
    WIRE            reduce using rule 5 (compUnit -> cir_function .)
    CLOCK           reduce using rule 5 (compUnit -> cir_function .)
    $end            reduce using rule 5 (compUnit -> cir_function .)


state 5

    (6) compUnit -> function .

    MODULE          reduce using rule 6 (compUnit -> function .)
    BUNDLE          reduce using rule 6 (compUnit -> function .)
    CONST           reduce using rule 6 (compUnit -> function .)
    ID              reduce using rule 6 (compUnit -> function .)
    INT             reduce using rule 6 (compUnit -> function .)
    FLOAT           reduce using rule 6 (compUnit -> function .)
    REG             reduce using rule 6 (compUnit -> function .)
    WIRE            reduce using rule 6 (compUnit -> function .)
    CLOCK           reduce using rule 6 (compUnit -> function .)
    $end            reduce using rule 6 (compUnit -> function .)


state 6

    (7) compUnit -> module .

    MODULE          reduce using rule 7 (compUnit -> module .)
    BUNDLE          reduce using rule 7 (compUnit -> module .)
    CONST           reduce using rule 7 (compUnit -> module .)
    ID              reduce using rule 7 (compUnit -> module .)
    INT             reduce using rule 7 (compUnit -> module .)
    FLOAT           reduce using rule 7 (compUnit -> module .)
    REG             reduce using rule 7 (compUnit -> module .)
    WIRE            reduce using rule 7 (compUnit -> module .)
    CLOCK           reduce using rule 7 (compUnit -> module .)
    $end            reduce using rule 7 (compUnit -> module .)


state 7

    (8) compUnit -> bundle .

    MODULE          reduce using rule 8 (compUnit -> bundle .)
    BUNDLE          reduce using rule 8 (compUnit -> bundle .)
    CONST           reduce using rule 8 (compUnit -> bundle .)
    ID              reduce using rule 8 (compUnit -> bundle .)
    INT             reduce using rule 8 (compUnit -> bundle .)
    FLOAT           reduce using rule 8 (compUnit -> bundle .)
    REG             reduce using rule 8 (compUnit -> bundle .)
    WIRE            reduce using rule 8 (compUnit -> bundle .)
    CLOCK           reduce using rule 8 (compUnit -> bundle .)
    $end            reduce using rule 8 (compUnit -> bundle .)


state 8

    (9) decl -> constDecl .

    MODULE          reduce using rule 9 (decl -> constDecl .)
    BUNDLE          reduce using rule 9 (decl -> constDecl .)
    CONST           reduce using rule 9 (decl -> constDecl .)
    ID              reduce using rule 9 (decl -> constDecl .)
    INT             reduce using rule 9 (decl -> constDecl .)
    FLOAT           reduce using rule 9 (decl -> constDecl .)
    REG             reduce using rule 9 (decl -> constDecl .)
    WIRE            reduce using rule 9 (decl -> constDecl .)
    CLOCK           reduce using rule 9 (decl -> constDecl .)
    $end            reduce using rule 9 (decl -> constDecl .)
    ;               reduce using rule 9 (decl -> constDecl .)
    RETURN          reduce using rule 9 (decl -> constDecl .)
    {               reduce using rule 9 (decl -> constDecl .)
    MUX             reduce using rule 9 (decl -> constDecl .)
    WHEN            reduce using rule 9 (decl -> constDecl .)
    IF              reduce using rule 9 (decl -> constDecl .)
    FOR             reduce using rule 9 (decl -> constDecl .)
    GENERATE        reduce using rule 9 (decl -> constDecl .)
    AND             reduce using rule 9 (decl -> constDecl .)
    OR              reduce using rule 9 (decl -> constDecl .)
    NOT             reduce using rule 9 (decl -> constDecl .)
    XOR             reduce using rule 9 (decl -> constDecl .)
    XNOR            reduce using rule 9 (decl -> constDecl .)
    SIGNAL          reduce using rule 9 (decl -> constDecl .)
    (               reduce using rule 9 (decl -> constDecl .)
    ADD             reduce using rule 9 (decl -> constDecl .)
    SUB             reduce using rule 9 (decl -> constDecl .)
    NOTL            reduce using rule 9 (decl -> constDecl .)
    INTEGER_CONST   reduce using rule 9 (decl -> constDecl .)
    FLOAT_CONST     reduce using rule 9 (decl -> constDecl .)
    }               reduce using rule 9 (decl -> constDecl .)


state 9

    (10) decl -> varDecl .

    MODULE          reduce using rule 10 (decl -> varDecl .)
    BUNDLE          reduce using rule 10 (decl -> varDecl .)
    CONST           reduce using rule 10 (decl -> varDecl .)
    ID              reduce using rule 10 (decl -> varDecl .)
    INT             reduce using rule 10 (decl -> varDecl .)
    FLOAT           reduce using rule 10 (decl -> varDecl .)
    REG             reduce using rule 10 (decl -> varDecl .)
    WIRE            reduce using rule 10 (decl -> varDecl .)
    CLOCK           reduce using rule 10 (decl -> varDecl .)
    $end            reduce using rule 10 (decl -> varDecl .)
    ;               reduce using rule 10 (decl -> varDecl .)
    RETURN          reduce using rule 10 (decl -> varDecl .)
    {               reduce using rule 10 (decl -> varDecl .)
    MUX             reduce using rule 10 (decl -> varDecl .)
    WHEN            reduce using rule 10 (decl -> varDecl .)
    IF              reduce using rule 10 (decl -> varDecl .)
    FOR             reduce using rule 10 (decl -> varDecl .)
    GENERATE        reduce using rule 10 (decl -> varDecl .)
    AND             reduce using rule 10 (decl -> varDecl .)
    OR              reduce using rule 10 (decl -> varDecl .)
    NOT             reduce using rule 10 (decl -> varDecl .)
    XOR             reduce using rule 10 (decl -> varDecl .)
    XNOR            reduce using rule 10 (decl -> varDecl .)
    SIGNAL          reduce using rule 10 (decl -> varDecl .)
    (               reduce using rule 10 (decl -> varDecl .)
    ADD             reduce using rule 10 (decl -> varDecl .)
    SUB             reduce using rule 10 (decl -> varDecl .)
    NOTL            reduce using rule 10 (decl -> varDecl .)
    INTEGER_CONST   reduce using rule 10 (decl -> varDecl .)
    FLOAT_CONST     reduce using rule 10 (decl -> varDecl .)
    }               reduce using rule 10 (decl -> varDecl .)


state 10

    (11) decl -> cirDecl .

    MODULE          reduce using rule 11 (decl -> cirDecl .)
    BUNDLE          reduce using rule 11 (decl -> cirDecl .)
    CONST           reduce using rule 11 (decl -> cirDecl .)
    ID              reduce using rule 11 (decl -> cirDecl .)
    INT             reduce using rule 11 (decl -> cirDecl .)
    FLOAT           reduce using rule 11 (decl -> cirDecl .)
    REG             reduce using rule 11 (decl -> cirDecl .)
    WIRE            reduce using rule 11 (decl -> cirDecl .)
    CLOCK           reduce using rule 11 (decl -> cirDecl .)
    $end            reduce using rule 11 (decl -> cirDecl .)
    ;               reduce using rule 11 (decl -> cirDecl .)
    RETURN          reduce using rule 11 (decl -> cirDecl .)
    {               reduce using rule 11 (decl -> cirDecl .)
    MUX             reduce using rule 11 (decl -> cirDecl .)
    WHEN            reduce using rule 11 (decl -> cirDecl .)
    IF              reduce using rule 11 (decl -> cirDecl .)
    FOR             reduce using rule 11 (decl -> cirDecl .)
    GENERATE        reduce using rule 11 (decl -> cirDecl .)
    AND             reduce using rule 11 (decl -> cirDecl .)
    OR              reduce using rule 11 (decl -> cirDecl .)
    NOT             reduce using rule 11 (decl -> cirDecl .)
    XOR             reduce using rule 11 (decl -> cirDecl .)
    XNOR            reduce using rule 11 (decl -> cirDecl .)
    SIGNAL          reduce using rule 11 (decl -> cirDecl .)
    (               reduce using rule 11 (decl -> cirDecl .)
    ADD             reduce using rule 11 (decl -> cirDecl .)
    SUB             reduce using rule 11 (decl -> cirDecl .)
    NOTL            reduce using rule 11 (decl -> cirDecl .)
    INTEGER_CONST   reduce using rule 11 (decl -> cirDecl .)
    FLOAT_CONST     reduce using rule 11 (decl -> cirDecl .)
    }               reduce using rule 11 (decl -> cirDecl .)


state 11

    (12) decl -> modDecl .

    MODULE          reduce using rule 12 (decl -> modDecl .)
    BUNDLE          reduce using rule 12 (decl -> modDecl .)
    CONST           reduce using rule 12 (decl -> modDecl .)
    ID              reduce using rule 12 (decl -> modDecl .)
    INT             reduce using rule 12 (decl -> modDecl .)
    FLOAT           reduce using rule 12 (decl -> modDecl .)
    REG             reduce using rule 12 (decl -> modDecl .)
    WIRE            reduce using rule 12 (decl -> modDecl .)
    CLOCK           reduce using rule 12 (decl -> modDecl .)
    $end            reduce using rule 12 (decl -> modDecl .)
    ;               reduce using rule 12 (decl -> modDecl .)
    RETURN          reduce using rule 12 (decl -> modDecl .)
    {               reduce using rule 12 (decl -> modDecl .)
    MUX             reduce using rule 12 (decl -> modDecl .)
    WHEN            reduce using rule 12 (decl -> modDecl .)
    IF              reduce using rule 12 (decl -> modDecl .)
    FOR             reduce using rule 12 (decl -> modDecl .)
    GENERATE        reduce using rule 12 (decl -> modDecl .)
    AND             reduce using rule 12 (decl -> modDecl .)
    OR              reduce using rule 12 (decl -> modDecl .)
    NOT             reduce using rule 12 (decl -> modDecl .)
    XOR             reduce using rule 12 (decl -> modDecl .)
    XNOR            reduce using rule 12 (decl -> modDecl .)
    SIGNAL          reduce using rule 12 (decl -> modDecl .)
    (               reduce using rule 12 (decl -> modDecl .)
    ADD             reduce using rule 12 (decl -> modDecl .)
    SUB             reduce using rule 12 (decl -> modDecl .)
    NOTL            reduce using rule 12 (decl -> modDecl .)
    INTEGER_CONST   reduce using rule 12 (decl -> modDecl .)
    FLOAT_CONST     reduce using rule 12 (decl -> modDecl .)
    }               reduce using rule 12 (decl -> modDecl .)


state 12

    (13) decl -> bundleDecl .

    MODULE          reduce using rule 13 (decl -> bundleDecl .)
    BUNDLE          reduce using rule 13 (decl -> bundleDecl .)
    CONST           reduce using rule 13 (decl -> bundleDecl .)
    ID              reduce using rule 13 (decl -> bundleDecl .)
    INT             reduce using rule 13 (decl -> bundleDecl .)
    FLOAT           reduce using rule 13 (decl -> bundleDecl .)
    REG             reduce using rule 13 (decl -> bundleDecl .)
    WIRE            reduce using rule 13 (decl -> bundleDecl .)
    CLOCK           reduce using rule 13 (decl -> bundleDecl .)
    $end            reduce using rule 13 (decl -> bundleDecl .)
    ;               reduce using rule 13 (decl -> bundleDecl .)
    RETURN          reduce using rule 13 (decl -> bundleDecl .)
    {               reduce using rule 13 (decl -> bundleDecl .)
    MUX             reduce using rule 13 (decl -> bundleDecl .)
    WHEN            reduce using rule 13 (decl -> bundleDecl .)
    IF              reduce using rule 13 (decl -> bundleDecl .)
    FOR             reduce using rule 13 (decl -> bundleDecl .)
    GENERATE        reduce using rule 13 (decl -> bundleDecl .)
    AND             reduce using rule 13 (decl -> bundleDecl .)
    OR              reduce using rule 13 (decl -> bundleDecl .)
    NOT             reduce using rule 13 (decl -> bundleDecl .)
    XOR             reduce using rule 13 (decl -> bundleDecl .)
    XNOR            reduce using rule 13 (decl -> bundleDecl .)
    SIGNAL          reduce using rule 13 (decl -> bundleDecl .)
    (               reduce using rule 13 (decl -> bundleDecl .)
    ADD             reduce using rule 13 (decl -> bundleDecl .)
    SUB             reduce using rule 13 (decl -> bundleDecl .)
    NOTL            reduce using rule 13 (decl -> bundleDecl .)
    INTEGER_CONST   reduce using rule 13 (decl -> bundleDecl .)
    FLOAT_CONST     reduce using rule 13 (decl -> bundleDecl .)
    }               reduce using rule 13 (decl -> bundleDecl .)


state 13

    (56) cir_function -> cir_type . ID ( cir_funcFParams ) block
    (53) cirDecl -> cir_type . cirDef cirDecl_repeat ;
    (54) cirDef -> . ID array
    (55) cirDef -> . ID array ASSIGN initVal

    ID              shift and go to state 26

    cirDef                         shift and go to state 27

state 14

    (38) modDecl -> ID . ID ( module_R_params )
    (48) bundleDecl -> ID . bundleDef bundleDecl_repeat
    (49) bundleDef -> . ID array

    ID              shift and go to state 28

    bundleDef                      shift and go to state 29

state 15

    (57) function -> val_type . ID ( funcFParams ) block
    (35) varDecl -> val_type . varDef varDef_repeat ;
    (36) varDef -> . ID array
    (37) varDef -> . ID array ASSIGN initVal

    ID              shift and go to state 30

    varDef                         shift and go to state 31

state 16

    (70) module -> MODULE . ID ( module_para_para port_def ID p_module_para_port

    ID              shift and go to state 32


state 17

    (73) bundle -> BUNDLE . ID ( cir_type ID bundle_repeat )

    ID              shift and go to state 33


state 18

    (16) constDecl -> CONST . val_type constDef constDecl_repeat ;
    (22) val_type -> . INT
    (23) val_type -> . FLOAT

    INT             shift and go to state 20
    FLOAT           shift and go to state 21

    val_type                       shift and go to state 34

state 19

    (20) cir_type -> cir_basic_type .
    (21) cir_type -> cir_basic_type . [ exp ]

    ID              reduce using rule 20 (cir_type -> cir_basic_type .)
    [               shift and go to state 35


state 20

    (22) val_type -> INT .

    ID              reduce using rule 22 (val_type -> INT .)


state 21

    (23) val_type -> FLOAT .

    ID              reduce using rule 23 (val_type -> FLOAT .)


state 22

    (17) cir_basic_type -> REG .

    [               reduce using rule 17 (cir_basic_type -> REG .)
    ID              reduce using rule 17 (cir_basic_type -> REG .)


state 23

    (18) cir_basic_type -> WIRE .

    [               reduce using rule 18 (cir_basic_type -> WIRE .)
    ID              reduce using rule 18 (cir_basic_type -> WIRE .)


state 24

    (19) cir_basic_type -> CLOCK .

    [               reduce using rule 19 (cir_basic_type -> CLOCK .)
    ID              reduce using rule 19 (cir_basic_type -> CLOCK .)


state 25

    (3) compUnit -> compUnit compUnit .
    (3) compUnit -> compUnit . compUnit
    (2) compUnit -> . empty
    (3) compUnit -> . compUnit compUnit
    (4) compUnit -> . decl
    (5) compUnit -> . cir_function
    (6) compUnit -> . function
    (7) compUnit -> . module
    (8) compUnit -> . bundle
    (1) empty -> .
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (56) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (57) function -> . val_type ID ( funcFParams ) block
    (70) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port
    (73) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (53) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (38) modDecl -> . ID ID ( module_R_params )
    (48) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK

  ! reduce/reduce conflict for MODULE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for BUNDLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CONST resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for ID resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for INT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for FLOAT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for REG resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for WIRE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CLOCK resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for $end resolved using rule 1 (empty -> .)
  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    $end            reduce using rule 1 (empty -> .)
    MODULE          shift and go to state 16
    BUNDLE          shift and go to state 17
    CONST           shift and go to state 18
    ID              shift and go to state 14
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24

  ! MODULE          [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! BUNDLE          [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! CONST           [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! ID              [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! INT             [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! FLOAT           [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! REG             [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! WIRE            [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! CLOCK           [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! $end            [ reduce using rule 3 (compUnit -> compUnit compUnit .) ]
  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]

    compUnit                       shift and go to state 25
    empty                          shift and go to state 2
    decl                           shift and go to state 3
    cir_function                   shift and go to state 4
    function                       shift and go to state 5
    module                         shift and go to state 6
    bundle                         shift and go to state 7
    constDecl                      shift and go to state 8
    varDecl                        shift and go to state 9
    cirDecl                        shift and go to state 10
    modDecl                        shift and go to state 11
    bundleDecl                     shift and go to state 12
    cir_type                       shift and go to state 13
    val_type                       shift and go to state 15
    cir_basic_type                 shift and go to state 19

state 26

    (56) cir_function -> cir_type ID . ( cir_funcFParams ) block
    (54) cirDef -> ID . array
    (55) cirDef -> ID . array ASSIGN initVal
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

    (               shift and go to state 36
    [               shift and go to state 39
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)

    array                          shift and go to state 37
    empty                          shift and go to state 38

state 27

    (53) cirDecl -> cir_type cirDef . cirDecl_repeat ;
    (51) cirDecl_repeat -> . empty
    (52) cirDecl_repeat -> . , cirDef cirDecl_repeat
    (1) empty -> .

    ,               shift and go to state 42
    ;               reduce using rule 1 (empty -> .)

    cirDecl_repeat                 shift and go to state 40
    empty                          shift and go to state 41

state 28

    (38) modDecl -> ID ID . ( module_R_params )
    (49) bundleDef -> ID . array
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 43
    [               shift and go to state 39
    ,               reduce using rule 1 (empty -> .)
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

  ! (               [ reduce using rule 1 (empty -> .) ]

    array                          shift and go to state 44
    empty                          shift and go to state 38

state 29

    (48) bundleDecl -> ID bundleDef . bundleDecl_repeat
    (46) bundleDecl_repeat -> . empty
    (47) bundleDecl_repeat -> . , bundleDef bundleDecl_repeat
    (1) empty -> .

    ,               shift and go to state 47
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    bundleDecl_repeat              shift and go to state 45
    empty                          shift and go to state 46

state 30

    (57) function -> val_type ID . ( funcFParams ) block
    (36) varDef -> ID . array
    (37) varDef -> ID . array ASSIGN initVal
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

    (               shift and go to state 48
    [               shift and go to state 39
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)

    array                          shift and go to state 49
    empty                          shift and go to state 38

state 31

    (35) varDecl -> val_type varDef . varDef_repeat ;
    (33) varDef_repeat -> . empty
    (34) varDef_repeat -> . , varDef varDef_repeat
    (1) empty -> .

    ,               shift and go to state 52
    ;               reduce using rule 1 (empty -> .)

    varDef_repeat                  shift and go to state 50
    empty                          shift and go to state 51

state 32

    (70) module -> MODULE ID . ( module_para_para port_def ID p_module_para_port

    (               shift and go to state 53


state 33

    (73) bundle -> BUNDLE ID . ( cir_type ID bundle_repeat )

    (               shift and go to state 54


state 34

    (16) constDecl -> CONST val_type . constDef constDecl_repeat ;
    (28) constDef -> . ID array ASSIGN constInitVal

    ID              shift and go to state 56

    constDef                       shift and go to state 55

state 35

    (21) cir_type -> cir_basic_type [ . exp ]
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 57
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 36

    (56) cir_function -> cir_type ID ( . cir_funcFParams ) block
    (60) cir_funcFParams -> . cir_funcFParam cir_funcFParams_repeat
    (64) cir_funcFParam -> . type_def ID array
    (24) type_def -> . val_type
    (25) type_def -> . cir_type
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24

    cir_type                       shift and go to state 87
    cir_funcFParams                shift and go to state 88
    cir_funcFParam                 shift and go to state 89
    type_def                       shift and go to state 90
    val_type                       shift and go to state 91
    cir_basic_type                 shift and go to state 19

state 37

    (54) cirDef -> ID array .
    (55) cirDef -> ID array . ASSIGN initVal

    ,               reduce using rule 54 (cirDef -> ID array .)
    ;               reduce using rule 54 (cirDef -> ID array .)
    ASSIGN          shift and go to state 92


state 38

    (26) array -> empty .

    ASSIGN          reduce using rule 26 (array -> empty .)
    ,               reduce using rule 26 (array -> empty .)
    ;               reduce using rule 26 (array -> empty .)
    MODULE          reduce using rule 26 (array -> empty .)
    BUNDLE          reduce using rule 26 (array -> empty .)
    CONST           reduce using rule 26 (array -> empty .)
    ID              reduce using rule 26 (array -> empty .)
    INT             reduce using rule 26 (array -> empty .)
    FLOAT           reduce using rule 26 (array -> empty .)
    REG             reduce using rule 26 (array -> empty .)
    WIRE            reduce using rule 26 (array -> empty .)
    CLOCK           reduce using rule 26 (array -> empty .)
    $end            reduce using rule 26 (array -> empty .)
    RETURN          reduce using rule 26 (array -> empty .)
    {               reduce using rule 26 (array -> empty .)
    MUX             reduce using rule 26 (array -> empty .)
    WHEN            reduce using rule 26 (array -> empty .)
    IF              reduce using rule 26 (array -> empty .)
    FOR             reduce using rule 26 (array -> empty .)
    GENERATE        reduce using rule 26 (array -> empty .)
    AND             reduce using rule 26 (array -> empty .)
    OR              reduce using rule 26 (array -> empty .)
    NOT             reduce using rule 26 (array -> empty .)
    XOR             reduce using rule 26 (array -> empty .)
    XNOR            reduce using rule 26 (array -> empty .)
    SIGNAL          reduce using rule 26 (array -> empty .)
    (               reduce using rule 26 (array -> empty .)
    ADD             reduce using rule 26 (array -> empty .)
    SUB             reduce using rule 26 (array -> empty .)
    NOTL            reduce using rule 26 (array -> empty .)
    INTEGER_CONST   reduce using rule 26 (array -> empty .)
    FLOAT_CONST     reduce using rule 26 (array -> empty .)
    }               reduce using rule 26 (array -> empty .)
    )               reduce using rule 26 (array -> empty .)


state 39

    (27) array -> [ . constExp ] array
    (167) constExp -> . exp
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    constExp                       shift and go to state 93
    exp                            shift and go to state 94
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 40

    (53) cirDecl -> cir_type cirDef cirDecl_repeat . ;

    ;               shift and go to state 95


state 41

    (51) cirDecl_repeat -> empty .

    ;               reduce using rule 51 (cirDecl_repeat -> empty .)


state 42

    (52) cirDecl_repeat -> , . cirDef cirDecl_repeat
    (54) cirDef -> . ID array
    (55) cirDef -> . ID array ASSIGN initVal

    ID              shift and go to state 97

    cirDef                         shift and go to state 96

state 43

    (38) modDecl -> ID ID ( . module_R_params )
    (45) module_R_params -> . p_module_R_params_item module_R_params_repeat
    (42) p_module_R_params_item -> . R_port_def ID ( ID )
    (39) R_port_def -> . IN .
    (40) R_port_def -> . OUT .
    (41) R_port_def -> . INOUT .

    IN              shift and go to state 101
    OUT             shift and go to state 102
    INOUT           shift and go to state 103

    module_R_params                shift and go to state 98
    p_module_R_params_item         shift and go to state 99
    R_port_def                     shift and go to state 100

state 44

    (49) bundleDef -> ID array .

    ,               reduce using rule 49 (bundleDef -> ID array .)
    MODULE          reduce using rule 49 (bundleDef -> ID array .)
    BUNDLE          reduce using rule 49 (bundleDef -> ID array .)
    CONST           reduce using rule 49 (bundleDef -> ID array .)
    ID              reduce using rule 49 (bundleDef -> ID array .)
    INT             reduce using rule 49 (bundleDef -> ID array .)
    FLOAT           reduce using rule 49 (bundleDef -> ID array .)
    REG             reduce using rule 49 (bundleDef -> ID array .)
    WIRE            reduce using rule 49 (bundleDef -> ID array .)
    CLOCK           reduce using rule 49 (bundleDef -> ID array .)
    $end            reduce using rule 49 (bundleDef -> ID array .)
    ;               reduce using rule 49 (bundleDef -> ID array .)
    RETURN          reduce using rule 49 (bundleDef -> ID array .)
    {               reduce using rule 49 (bundleDef -> ID array .)
    MUX             reduce using rule 49 (bundleDef -> ID array .)
    WHEN            reduce using rule 49 (bundleDef -> ID array .)
    IF              reduce using rule 49 (bundleDef -> ID array .)
    FOR             reduce using rule 49 (bundleDef -> ID array .)
    GENERATE        reduce using rule 49 (bundleDef -> ID array .)
    AND             reduce using rule 49 (bundleDef -> ID array .)
    OR              reduce using rule 49 (bundleDef -> ID array .)
    NOT             reduce using rule 49 (bundleDef -> ID array .)
    XOR             reduce using rule 49 (bundleDef -> ID array .)
    XNOR            reduce using rule 49 (bundleDef -> ID array .)
    SIGNAL          reduce using rule 49 (bundleDef -> ID array .)
    (               reduce using rule 49 (bundleDef -> ID array .)
    ADD             reduce using rule 49 (bundleDef -> ID array .)
    SUB             reduce using rule 49 (bundleDef -> ID array .)
    NOTL            reduce using rule 49 (bundleDef -> ID array .)
    INTEGER_CONST   reduce using rule 49 (bundleDef -> ID array .)
    FLOAT_CONST     reduce using rule 49 (bundleDef -> ID array .)
    }               reduce using rule 49 (bundleDef -> ID array .)


state 45

    (48) bundleDecl -> ID bundleDef bundleDecl_repeat .

    MODULE          reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    BUNDLE          reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    CONST           reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    ID              reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    INT             reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    FLOAT           reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    REG             reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    WIRE            reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    CLOCK           reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    $end            reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    ;               reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    RETURN          reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    {               reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    MUX             reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    WHEN            reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    IF              reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    FOR             reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    GENERATE        reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    AND             reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    OR              reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    NOT             reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    XOR             reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    XNOR            reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    SIGNAL          reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    (               reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    ADD             reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    SUB             reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    NOTL            reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    INTEGER_CONST   reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    FLOAT_CONST     reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)
    }               reduce using rule 48 (bundleDecl -> ID bundleDef bundleDecl_repeat .)


state 46

    (46) bundleDecl_repeat -> empty .

    MODULE          reduce using rule 46 (bundleDecl_repeat -> empty .)
    BUNDLE          reduce using rule 46 (bundleDecl_repeat -> empty .)
    CONST           reduce using rule 46 (bundleDecl_repeat -> empty .)
    ID              reduce using rule 46 (bundleDecl_repeat -> empty .)
    INT             reduce using rule 46 (bundleDecl_repeat -> empty .)
    FLOAT           reduce using rule 46 (bundleDecl_repeat -> empty .)
    REG             reduce using rule 46 (bundleDecl_repeat -> empty .)
    WIRE            reduce using rule 46 (bundleDecl_repeat -> empty .)
    CLOCK           reduce using rule 46 (bundleDecl_repeat -> empty .)
    $end            reduce using rule 46 (bundleDecl_repeat -> empty .)
    ;               reduce using rule 46 (bundleDecl_repeat -> empty .)
    RETURN          reduce using rule 46 (bundleDecl_repeat -> empty .)
    {               reduce using rule 46 (bundleDecl_repeat -> empty .)
    MUX             reduce using rule 46 (bundleDecl_repeat -> empty .)
    WHEN            reduce using rule 46 (bundleDecl_repeat -> empty .)
    IF              reduce using rule 46 (bundleDecl_repeat -> empty .)
    FOR             reduce using rule 46 (bundleDecl_repeat -> empty .)
    GENERATE        reduce using rule 46 (bundleDecl_repeat -> empty .)
    AND             reduce using rule 46 (bundleDecl_repeat -> empty .)
    OR              reduce using rule 46 (bundleDecl_repeat -> empty .)
    NOT             reduce using rule 46 (bundleDecl_repeat -> empty .)
    XOR             reduce using rule 46 (bundleDecl_repeat -> empty .)
    XNOR            reduce using rule 46 (bundleDecl_repeat -> empty .)
    SIGNAL          reduce using rule 46 (bundleDecl_repeat -> empty .)
    (               reduce using rule 46 (bundleDecl_repeat -> empty .)
    ADD             reduce using rule 46 (bundleDecl_repeat -> empty .)
    SUB             reduce using rule 46 (bundleDecl_repeat -> empty .)
    NOTL            reduce using rule 46 (bundleDecl_repeat -> empty .)
    INTEGER_CONST   reduce using rule 46 (bundleDecl_repeat -> empty .)
    FLOAT_CONST     reduce using rule 46 (bundleDecl_repeat -> empty .)
    }               reduce using rule 46 (bundleDecl_repeat -> empty .)


state 47

    (47) bundleDecl_repeat -> , . bundleDef bundleDecl_repeat
    (49) bundleDef -> . ID array

    ID              shift and go to state 105

    bundleDef                      shift and go to state 104

state 48

    (57) function -> val_type ID ( . funcFParams ) block
    (63) funcFParams -> . funcFParam funcFParams_repeat
    (65) funcFParam -> . val_type ID array
    (22) val_type -> . INT
    (23) val_type -> . FLOAT

    INT             shift and go to state 20
    FLOAT           shift and go to state 21

    val_type                       shift and go to state 106
    funcFParams                    shift and go to state 107
    funcFParam                     shift and go to state 108

state 49

    (36) varDef -> ID array .
    (37) varDef -> ID array . ASSIGN initVal

    ,               reduce using rule 36 (varDef -> ID array .)
    ;               reduce using rule 36 (varDef -> ID array .)
    ASSIGN          shift and go to state 109


state 50

    (35) varDecl -> val_type varDef varDef_repeat . ;

    ;               shift and go to state 110


state 51

    (33) varDef_repeat -> empty .

    ;               reduce using rule 33 (varDef_repeat -> empty .)


state 52

    (34) varDef_repeat -> , . varDef varDef_repeat
    (36) varDef -> . ID array
    (37) varDef -> . ID array ASSIGN initVal

    ID              shift and go to state 112

    varDef                         shift and go to state 111

state 53

    (70) module -> MODULE ID ( . module_para_para port_def ID p_module_para_port
    (66) module_para_para -> . empty
    (67) module_para_para -> . PARA ID , module_para_para
    (1) empty -> .

    PARA            shift and go to state 115
    INPUT           reduce using rule 1 (empty -> .)
    OUTPUT          reduce using rule 1 (empty -> .)
    INOUT           reduce using rule 1 (empty -> .)

    module_para_para               shift and go to state 113
    empty                          shift and go to state 114

state 54

    (73) bundle -> BUNDLE ID ( . cir_type ID bundle_repeat )
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK

    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24

    cir_type                       shift and go to state 116
    cir_basic_type                 shift and go to state 19

state 55

    (16) constDecl -> CONST val_type constDef . constDecl_repeat ;
    (14) constDecl_repeat -> . empty
    (15) constDecl_repeat -> . , constDef constDecl_repeat
    (1) empty -> .

    ,               shift and go to state 119
    ;               reduce using rule 1 (empty -> .)

    constDecl_repeat               shift and go to state 117
    empty                          shift and go to state 118

state 56

    (28) constDef -> ID . array ASSIGN constInitVal
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 39
    ASSIGN          reduce using rule 1 (empty -> .)

    array                          shift and go to state 120
    empty                          shift and go to state 38

state 57

    (21) cir_type -> cir_basic_type [ exp . ]
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               shift and go to state 121
    BIT_WIDTH_NUMBER shift and go to state 122


state 58

    (97) exp -> lOrExp .
    (163) lOrExp -> lOrExp . LOR lAndExp

    ]               reduce using rule 97 (exp -> lOrExp .)
    BIT_WIDTH_NUMBER reduce using rule 97 (exp -> lOrExp .)
    )               reduce using rule 97 (exp -> lOrExp .)
    ;               reduce using rule 97 (exp -> lOrExp .)
    ,               reduce using rule 97 (exp -> lOrExp .)
    COLON           reduce using rule 97 (exp -> lOrExp .)
    RETURN          reduce using rule 97 (exp -> lOrExp .)
    CONST           reduce using rule 97 (exp -> lOrExp .)
    ID              reduce using rule 97 (exp -> lOrExp .)
    {               reduce using rule 97 (exp -> lOrExp .)
    MUX             reduce using rule 97 (exp -> lOrExp .)
    WHEN            reduce using rule 97 (exp -> lOrExp .)
    IF              reduce using rule 97 (exp -> lOrExp .)
    FOR             reduce using rule 97 (exp -> lOrExp .)
    GENERATE        reduce using rule 97 (exp -> lOrExp .)
    INT             reduce using rule 97 (exp -> lOrExp .)
    FLOAT           reduce using rule 97 (exp -> lOrExp .)
    REG             reduce using rule 97 (exp -> lOrExp .)
    WIRE            reduce using rule 97 (exp -> lOrExp .)
    CLOCK           reduce using rule 97 (exp -> lOrExp .)
    AND             reduce using rule 97 (exp -> lOrExp .)
    OR              reduce using rule 97 (exp -> lOrExp .)
    NOT             reduce using rule 97 (exp -> lOrExp .)
    XOR             reduce using rule 97 (exp -> lOrExp .)
    XNOR            reduce using rule 97 (exp -> lOrExp .)
    SIGNAL          reduce using rule 97 (exp -> lOrExp .)
    (               reduce using rule 97 (exp -> lOrExp .)
    ADD             reduce using rule 97 (exp -> lOrExp .)
    SUB             reduce using rule 97 (exp -> lOrExp .)
    NOTL            reduce using rule 97 (exp -> lOrExp .)
    INTEGER_CONST   reduce using rule 97 (exp -> lOrExp .)
    FLOAT_CONST     reduce using rule 97 (exp -> lOrExp .)
    }               reduce using rule 97 (exp -> lOrExp .)
    ELIF            reduce using rule 97 (exp -> lOrExp .)
    ELSE            reduce using rule 97 (exp -> lOrExp .)
    LOR             shift and go to state 123


state 59

    (162) lOrExp -> lAndExp .
    (161) lAndExp -> lAndExp . LAND redExp

    LOR             reduce using rule 162 (lOrExp -> lAndExp .)
    ]               reduce using rule 162 (lOrExp -> lAndExp .)
    BIT_WIDTH_NUMBER reduce using rule 162 (lOrExp -> lAndExp .)
    )               reduce using rule 162 (lOrExp -> lAndExp .)
    ;               reduce using rule 162 (lOrExp -> lAndExp .)
    ,               reduce using rule 162 (lOrExp -> lAndExp .)
    COLON           reduce using rule 162 (lOrExp -> lAndExp .)
    RETURN          reduce using rule 162 (lOrExp -> lAndExp .)
    CONST           reduce using rule 162 (lOrExp -> lAndExp .)
    ID              reduce using rule 162 (lOrExp -> lAndExp .)
    {               reduce using rule 162 (lOrExp -> lAndExp .)
    MUX             reduce using rule 162 (lOrExp -> lAndExp .)
    WHEN            reduce using rule 162 (lOrExp -> lAndExp .)
    IF              reduce using rule 162 (lOrExp -> lAndExp .)
    FOR             reduce using rule 162 (lOrExp -> lAndExp .)
    GENERATE        reduce using rule 162 (lOrExp -> lAndExp .)
    INT             reduce using rule 162 (lOrExp -> lAndExp .)
    FLOAT           reduce using rule 162 (lOrExp -> lAndExp .)
    REG             reduce using rule 162 (lOrExp -> lAndExp .)
    WIRE            reduce using rule 162 (lOrExp -> lAndExp .)
    CLOCK           reduce using rule 162 (lOrExp -> lAndExp .)
    AND             reduce using rule 162 (lOrExp -> lAndExp .)
    OR              reduce using rule 162 (lOrExp -> lAndExp .)
    NOT             reduce using rule 162 (lOrExp -> lAndExp .)
    XOR             reduce using rule 162 (lOrExp -> lAndExp .)
    XNOR            reduce using rule 162 (lOrExp -> lAndExp .)
    SIGNAL          reduce using rule 162 (lOrExp -> lAndExp .)
    (               reduce using rule 162 (lOrExp -> lAndExp .)
    ADD             reduce using rule 162 (lOrExp -> lAndExp .)
    SUB             reduce using rule 162 (lOrExp -> lAndExp .)
    NOTL            reduce using rule 162 (lOrExp -> lAndExp .)
    INTEGER_CONST   reduce using rule 162 (lOrExp -> lAndExp .)
    FLOAT_CONST     reduce using rule 162 (lOrExp -> lAndExp .)
    }               reduce using rule 162 (lOrExp -> lAndExp .)
    ELIF            reduce using rule 162 (lOrExp -> lAndExp .)
    ELSE            reduce using rule 162 (lOrExp -> lAndExp .)
    LAND            shift and go to state 124


state 60

    (160) lAndExp -> redExp .

    LAND            reduce using rule 160 (lAndExp -> redExp .)
    LOR             reduce using rule 160 (lAndExp -> redExp .)
    ]               reduce using rule 160 (lAndExp -> redExp .)
    BIT_WIDTH_NUMBER reduce using rule 160 (lAndExp -> redExp .)
    )               reduce using rule 160 (lAndExp -> redExp .)
    ;               reduce using rule 160 (lAndExp -> redExp .)
    ,               reduce using rule 160 (lAndExp -> redExp .)
    COLON           reduce using rule 160 (lAndExp -> redExp .)
    RETURN          reduce using rule 160 (lAndExp -> redExp .)
    CONST           reduce using rule 160 (lAndExp -> redExp .)
    ID              reduce using rule 160 (lAndExp -> redExp .)
    {               reduce using rule 160 (lAndExp -> redExp .)
    MUX             reduce using rule 160 (lAndExp -> redExp .)
    WHEN            reduce using rule 160 (lAndExp -> redExp .)
    IF              reduce using rule 160 (lAndExp -> redExp .)
    FOR             reduce using rule 160 (lAndExp -> redExp .)
    GENERATE        reduce using rule 160 (lAndExp -> redExp .)
    INT             reduce using rule 160 (lAndExp -> redExp .)
    FLOAT           reduce using rule 160 (lAndExp -> redExp .)
    REG             reduce using rule 160 (lAndExp -> redExp .)
    WIRE            reduce using rule 160 (lAndExp -> redExp .)
    CLOCK           reduce using rule 160 (lAndExp -> redExp .)
    AND             reduce using rule 160 (lAndExp -> redExp .)
    OR              reduce using rule 160 (lAndExp -> redExp .)
    NOT             reduce using rule 160 (lAndExp -> redExp .)
    XOR             reduce using rule 160 (lAndExp -> redExp .)
    XNOR            reduce using rule 160 (lAndExp -> redExp .)
    SIGNAL          reduce using rule 160 (lAndExp -> redExp .)
    (               reduce using rule 160 (lAndExp -> redExp .)
    ADD             reduce using rule 160 (lAndExp -> redExp .)
    SUB             reduce using rule 160 (lAndExp -> redExp .)
    NOTL            reduce using rule 160 (lAndExp -> redExp .)
    INTEGER_CONST   reduce using rule 160 (lAndExp -> redExp .)
    FLOAT_CONST     reduce using rule 160 (lAndExp -> redExp .)
    }               reduce using rule 160 (lAndExp -> redExp .)
    ELIF            reduce using rule 160 (lAndExp -> redExp .)
    ELSE            reduce using rule 160 (lAndExp -> redExp .)


state 61

    (154) redExp -> eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp

    LAND            reduce using rule 154 (redExp -> eqExp .)
    LOR             reduce using rule 154 (redExp -> eqExp .)
    ]               reduce using rule 154 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 154 (redExp -> eqExp .)
    )               reduce using rule 154 (redExp -> eqExp .)
    ;               reduce using rule 154 (redExp -> eqExp .)
    ,               reduce using rule 154 (redExp -> eqExp .)
    COLON           reduce using rule 154 (redExp -> eqExp .)
    RETURN          reduce using rule 154 (redExp -> eqExp .)
    CONST           reduce using rule 154 (redExp -> eqExp .)
    ID              reduce using rule 154 (redExp -> eqExp .)
    {               reduce using rule 154 (redExp -> eqExp .)
    MUX             reduce using rule 154 (redExp -> eqExp .)
    WHEN            reduce using rule 154 (redExp -> eqExp .)
    IF              reduce using rule 154 (redExp -> eqExp .)
    FOR             reduce using rule 154 (redExp -> eqExp .)
    GENERATE        reduce using rule 154 (redExp -> eqExp .)
    INT             reduce using rule 154 (redExp -> eqExp .)
    FLOAT           reduce using rule 154 (redExp -> eqExp .)
    REG             reduce using rule 154 (redExp -> eqExp .)
    WIRE            reduce using rule 154 (redExp -> eqExp .)
    CLOCK           reduce using rule 154 (redExp -> eqExp .)
    AND             reduce using rule 154 (redExp -> eqExp .)
    OR              reduce using rule 154 (redExp -> eqExp .)
    NOT             reduce using rule 154 (redExp -> eqExp .)
    XOR             reduce using rule 154 (redExp -> eqExp .)
    XNOR            reduce using rule 154 (redExp -> eqExp .)
    SIGNAL          reduce using rule 154 (redExp -> eqExp .)
    (               reduce using rule 154 (redExp -> eqExp .)
    ADD             reduce using rule 154 (redExp -> eqExp .)
    SUB             reduce using rule 154 (redExp -> eqExp .)
    NOTL            reduce using rule 154 (redExp -> eqExp .)
    INTEGER_CONST   reduce using rule 154 (redExp -> eqExp .)
    FLOAT_CONST     reduce using rule 154 (redExp -> eqExp .)
    }               reduce using rule 154 (redExp -> eqExp .)
    ELIF            reduce using rule 154 (redExp -> eqExp .)
    ELSE            reduce using rule 154 (redExp -> eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130


state 62

    (155) redExp -> AND . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 131
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 63

    (156) redExp -> OR . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 134
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 64

    (157) redExp -> NOT . eqExp
    (124) unaryOp -> NOT .
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SIGNAL resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NOTL resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for MUX resolved as shift
  ! shift/reduce conflict for INTEGER_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for XNOR resolved as shift
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

  ! ID              [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! SIGNAL          [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! (               [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! ADD             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! SUB             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! NOT             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! NOTL            [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! {               [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! MUX             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! INTEGER_CONST   [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! FLOAT_CONST     [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! AND             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! OR              [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! XOR             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! XNOR            [ reduce using rule 124 (unaryOp -> NOT .) ]

    eqExp                          shift and go to state 135
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 65

    (158) redExp -> XOR . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 136
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 66

    (159) redExp -> XNOR . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 137
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 67

    (147) eqExp -> relExp .
    (143) relExp -> relExp . LT addExp
    (144) relExp -> relExp . GT addExp
    (145) relExp -> relExp . GE addExp
    (146) relExp -> relExp . LE addExp

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
    EQUAL           reduce using rule 147 (eqExp -> relExp .)
    NEQ             reduce using rule 147 (eqExp -> relExp .)
    LAND            reduce using rule 147 (eqExp -> relExp .)
    LOR             reduce using rule 147 (eqExp -> relExp .)
    ]               reduce using rule 147 (eqExp -> relExp .)
    BIT_WIDTH_NUMBER reduce using rule 147 (eqExp -> relExp .)
    )               reduce using rule 147 (eqExp -> relExp .)
    ;               reduce using rule 147 (eqExp -> relExp .)
    ,               reduce using rule 147 (eqExp -> relExp .)
    COLON           reduce using rule 147 (eqExp -> relExp .)
    RETURN          reduce using rule 147 (eqExp -> relExp .)
    CONST           reduce using rule 147 (eqExp -> relExp .)
    ID              reduce using rule 147 (eqExp -> relExp .)
    {               reduce using rule 147 (eqExp -> relExp .)
    MUX             reduce using rule 147 (eqExp -> relExp .)
    WHEN            reduce using rule 147 (eqExp -> relExp .)
    IF              reduce using rule 147 (eqExp -> relExp .)
    FOR             reduce using rule 147 (eqExp -> relExp .)
    GENERATE        reduce using rule 147 (eqExp -> relExp .)
    INT             reduce using rule 147 (eqExp -> relExp .)
    FLOAT           reduce using rule 147 (eqExp -> relExp .)
    REG             reduce using rule 147 (eqExp -> relExp .)
    WIRE            reduce using rule 147 (eqExp -> relExp .)
    CLOCK           reduce using rule 147 (eqExp -> relExp .)
    AND             reduce using rule 147 (eqExp -> relExp .)
    OR              reduce using rule 147 (eqExp -> relExp .)
    NOT             reduce using rule 147 (eqExp -> relExp .)
    XOR             reduce using rule 147 (eqExp -> relExp .)
    XNOR            reduce using rule 147 (eqExp -> relExp .)
    SIGNAL          reduce using rule 147 (eqExp -> relExp .)
    (               reduce using rule 147 (eqExp -> relExp .)
    ADD             reduce using rule 147 (eqExp -> relExp .)
    SUB             reduce using rule 147 (eqExp -> relExp .)
    NOTL            reduce using rule 147 (eqExp -> relExp .)
    INTEGER_CONST   reduce using rule 147 (eqExp -> relExp .)
    FLOAT_CONST     reduce using rule 147 (eqExp -> relExp .)
    }               reduce using rule 147 (eqExp -> relExp .)
    ELIF            reduce using rule 147 (eqExp -> relExp .)
    ELSE            reduce using rule 147 (eqExp -> relExp .)
    LT              shift and go to state 138
    GT              shift and go to state 139
    GE              shift and go to state 140
    LE              shift and go to state 141

  ! LT              [ reduce using rule 147 (eqExp -> relExp .) ]
  ! GT              [ reduce using rule 147 (eqExp -> relExp .) ]
  ! GE              [ reduce using rule 147 (eqExp -> relExp .) ]
  ! LE              [ reduce using rule 147 (eqExp -> relExp .) ]


state 68

    (142) relExp -> shiftExp .
    (139) shiftExp -> shiftExp . SLL addExp
    (140) shiftExp -> shiftExp . SRL addExp
    (141) shiftExp -> shiftExp . SRA addExp

    LT              reduce using rule 142 (relExp -> shiftExp .)
    GT              reduce using rule 142 (relExp -> shiftExp .)
    GE              reduce using rule 142 (relExp -> shiftExp .)
    LE              reduce using rule 142 (relExp -> shiftExp .)
    EQUAL           reduce using rule 142 (relExp -> shiftExp .)
    NEQ             reduce using rule 142 (relExp -> shiftExp .)
    LAND            reduce using rule 142 (relExp -> shiftExp .)
    LOR             reduce using rule 142 (relExp -> shiftExp .)
    ]               reduce using rule 142 (relExp -> shiftExp .)
    BIT_WIDTH_NUMBER reduce using rule 142 (relExp -> shiftExp .)
    )               reduce using rule 142 (relExp -> shiftExp .)
    ;               reduce using rule 142 (relExp -> shiftExp .)
    ,               reduce using rule 142 (relExp -> shiftExp .)
    COLON           reduce using rule 142 (relExp -> shiftExp .)
    RETURN          reduce using rule 142 (relExp -> shiftExp .)
    CONST           reduce using rule 142 (relExp -> shiftExp .)
    ID              reduce using rule 142 (relExp -> shiftExp .)
    {               reduce using rule 142 (relExp -> shiftExp .)
    MUX             reduce using rule 142 (relExp -> shiftExp .)
    WHEN            reduce using rule 142 (relExp -> shiftExp .)
    IF              reduce using rule 142 (relExp -> shiftExp .)
    FOR             reduce using rule 142 (relExp -> shiftExp .)
    GENERATE        reduce using rule 142 (relExp -> shiftExp .)
    INT             reduce using rule 142 (relExp -> shiftExp .)
    FLOAT           reduce using rule 142 (relExp -> shiftExp .)
    REG             reduce using rule 142 (relExp -> shiftExp .)
    WIRE            reduce using rule 142 (relExp -> shiftExp .)
    CLOCK           reduce using rule 142 (relExp -> shiftExp .)
    AND             reduce using rule 142 (relExp -> shiftExp .)
    OR              reduce using rule 142 (relExp -> shiftExp .)
    NOT             reduce using rule 142 (relExp -> shiftExp .)
    XOR             reduce using rule 142 (relExp -> shiftExp .)
    XNOR            reduce using rule 142 (relExp -> shiftExp .)
    SIGNAL          reduce using rule 142 (relExp -> shiftExp .)
    (               reduce using rule 142 (relExp -> shiftExp .)
    ADD             reduce using rule 142 (relExp -> shiftExp .)
    SUB             reduce using rule 142 (relExp -> shiftExp .)
    NOTL            reduce using rule 142 (relExp -> shiftExp .)
    INTEGER_CONST   reduce using rule 142 (relExp -> shiftExp .)
    FLOAT_CONST     reduce using rule 142 (relExp -> shiftExp .)
    }               reduce using rule 142 (relExp -> shiftExp .)
    ELIF            reduce using rule 142 (relExp -> shiftExp .)
    ELSE            reduce using rule 142 (relExp -> shiftExp .)
    SLL             shift and go to state 142
    SRL             shift and go to state 143
    SRA             shift and go to state 144


state 69

    (138) shiftExp -> addExp .
    (136) addExp -> addExp . ADD mulExp
    (137) addExp -> addExp . SUB mulExp

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
    SLL             reduce using rule 138 (shiftExp -> addExp .)
    SRL             reduce using rule 138 (shiftExp -> addExp .)
    SRA             reduce using rule 138 (shiftExp -> addExp .)
    LT              reduce using rule 138 (shiftExp -> addExp .)
    GT              reduce using rule 138 (shiftExp -> addExp .)
    GE              reduce using rule 138 (shiftExp -> addExp .)
    LE              reduce using rule 138 (shiftExp -> addExp .)
    EQUAL           reduce using rule 138 (shiftExp -> addExp .)
    NEQ             reduce using rule 138 (shiftExp -> addExp .)
    LAND            reduce using rule 138 (shiftExp -> addExp .)
    LOR             reduce using rule 138 (shiftExp -> addExp .)
    ]               reduce using rule 138 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 138 (shiftExp -> addExp .)
    )               reduce using rule 138 (shiftExp -> addExp .)
    ;               reduce using rule 138 (shiftExp -> addExp .)
    ,               reduce using rule 138 (shiftExp -> addExp .)
    COLON           reduce using rule 138 (shiftExp -> addExp .)
    RETURN          reduce using rule 138 (shiftExp -> addExp .)
    CONST           reduce using rule 138 (shiftExp -> addExp .)
    ID              reduce using rule 138 (shiftExp -> addExp .)
    {               reduce using rule 138 (shiftExp -> addExp .)
    MUX             reduce using rule 138 (shiftExp -> addExp .)
    WHEN            reduce using rule 138 (shiftExp -> addExp .)
    IF              reduce using rule 138 (shiftExp -> addExp .)
    FOR             reduce using rule 138 (shiftExp -> addExp .)
    GENERATE        reduce using rule 138 (shiftExp -> addExp .)
    INT             reduce using rule 138 (shiftExp -> addExp .)
    FLOAT           reduce using rule 138 (shiftExp -> addExp .)
    REG             reduce using rule 138 (shiftExp -> addExp .)
    WIRE            reduce using rule 138 (shiftExp -> addExp .)
    CLOCK           reduce using rule 138 (shiftExp -> addExp .)
    AND             reduce using rule 138 (shiftExp -> addExp .)
    OR              reduce using rule 138 (shiftExp -> addExp .)
    NOT             reduce using rule 138 (shiftExp -> addExp .)
    XOR             reduce using rule 138 (shiftExp -> addExp .)
    XNOR            reduce using rule 138 (shiftExp -> addExp .)
    SIGNAL          reduce using rule 138 (shiftExp -> addExp .)
    (               reduce using rule 138 (shiftExp -> addExp .)
    NOTL            reduce using rule 138 (shiftExp -> addExp .)
    INTEGER_CONST   reduce using rule 138 (shiftExp -> addExp .)
    FLOAT_CONST     reduce using rule 138 (shiftExp -> addExp .)
    }               reduce using rule 138 (shiftExp -> addExp .)
    ELIF            reduce using rule 138 (shiftExp -> addExp .)
    ELSE            reduce using rule 138 (shiftExp -> addExp .)
    ADD             shift and go to state 145
    SUB             shift and go to state 146

  ! ADD             [ reduce using rule 138 (shiftExp -> addExp .) ]
  ! SUB             [ reduce using rule 138 (shiftExp -> addExp .) ]


state 70

    (135) addExp -> mulExp .
    (131) mulExp -> mulExp . MUL unaryExp
    (132) mulExp -> mulExp . DIV unaryExp
    (133) mulExp -> mulExp . MOD unaryExp
    (134) mulExp -> mulExp . POWER unaryExp

    ADD             reduce using rule 135 (addExp -> mulExp .)
    SUB             reduce using rule 135 (addExp -> mulExp .)
    SLL             reduce using rule 135 (addExp -> mulExp .)
    SRL             reduce using rule 135 (addExp -> mulExp .)
    SRA             reduce using rule 135 (addExp -> mulExp .)
    LT              reduce using rule 135 (addExp -> mulExp .)
    GT              reduce using rule 135 (addExp -> mulExp .)
    GE              reduce using rule 135 (addExp -> mulExp .)
    LE              reduce using rule 135 (addExp -> mulExp .)
    EQUAL           reduce using rule 135 (addExp -> mulExp .)
    NEQ             reduce using rule 135 (addExp -> mulExp .)
    LAND            reduce using rule 135 (addExp -> mulExp .)
    LOR             reduce using rule 135 (addExp -> mulExp .)
    ]               reduce using rule 135 (addExp -> mulExp .)
    BIT_WIDTH_NUMBER reduce using rule 135 (addExp -> mulExp .)
    )               reduce using rule 135 (addExp -> mulExp .)
    ;               reduce using rule 135 (addExp -> mulExp .)
    ,               reduce using rule 135 (addExp -> mulExp .)
    COLON           reduce using rule 135 (addExp -> mulExp .)
    RETURN          reduce using rule 135 (addExp -> mulExp .)
    CONST           reduce using rule 135 (addExp -> mulExp .)
    ID              reduce using rule 135 (addExp -> mulExp .)
    {               reduce using rule 135 (addExp -> mulExp .)
    MUX             reduce using rule 135 (addExp -> mulExp .)
    WHEN            reduce using rule 135 (addExp -> mulExp .)
    IF              reduce using rule 135 (addExp -> mulExp .)
    FOR             reduce using rule 135 (addExp -> mulExp .)
    GENERATE        reduce using rule 135 (addExp -> mulExp .)
    INT             reduce using rule 135 (addExp -> mulExp .)
    FLOAT           reduce using rule 135 (addExp -> mulExp .)
    REG             reduce using rule 135 (addExp -> mulExp .)
    WIRE            reduce using rule 135 (addExp -> mulExp .)
    CLOCK           reduce using rule 135 (addExp -> mulExp .)
    AND             reduce using rule 135 (addExp -> mulExp .)
    OR              reduce using rule 135 (addExp -> mulExp .)
    NOT             reduce using rule 135 (addExp -> mulExp .)
    XOR             reduce using rule 135 (addExp -> mulExp .)
    XNOR            reduce using rule 135 (addExp -> mulExp .)
    SIGNAL          reduce using rule 135 (addExp -> mulExp .)
    (               reduce using rule 135 (addExp -> mulExp .)
    NOTL            reduce using rule 135 (addExp -> mulExp .)
    INTEGER_CONST   reduce using rule 135 (addExp -> mulExp .)
    FLOAT_CONST     reduce using rule 135 (addExp -> mulExp .)
    }               reduce using rule 135 (addExp -> mulExp .)
    ELIF            reduce using rule 135 (addExp -> mulExp .)
    ELSE            reduce using rule 135 (addExp -> mulExp .)
    MUL             shift and go to state 147
    DIV             shift and go to state 148
    MOD             shift and go to state 149
    POWER           shift and go to state 150


state 71

    (122) unaryOp -> ADD .

    ID              reduce using rule 122 (unaryOp -> ADD .)
    SIGNAL          reduce using rule 122 (unaryOp -> ADD .)
    (               reduce using rule 122 (unaryOp -> ADD .)
    ADD             reduce using rule 122 (unaryOp -> ADD .)
    SUB             reduce using rule 122 (unaryOp -> ADD .)
    NOT             reduce using rule 122 (unaryOp -> ADD .)
    NOTL            reduce using rule 122 (unaryOp -> ADD .)
    {               reduce using rule 122 (unaryOp -> ADD .)
    MUX             reduce using rule 122 (unaryOp -> ADD .)
    INTEGER_CONST   reduce using rule 122 (unaryOp -> ADD .)
    FLOAT_CONST     reduce using rule 122 (unaryOp -> ADD .)
    AND             reduce using rule 122 (unaryOp -> ADD .)
    OR              reduce using rule 122 (unaryOp -> ADD .)
    XOR             reduce using rule 122 (unaryOp -> ADD .)
    XNOR            reduce using rule 122 (unaryOp -> ADD .)


state 72

    (123) unaryOp -> SUB .

    ID              reduce using rule 123 (unaryOp -> SUB .)
    SIGNAL          reduce using rule 123 (unaryOp -> SUB .)
    (               reduce using rule 123 (unaryOp -> SUB .)
    ADD             reduce using rule 123 (unaryOp -> SUB .)
    SUB             reduce using rule 123 (unaryOp -> SUB .)
    NOT             reduce using rule 123 (unaryOp -> SUB .)
    NOTL            reduce using rule 123 (unaryOp -> SUB .)
    {               reduce using rule 123 (unaryOp -> SUB .)
    MUX             reduce using rule 123 (unaryOp -> SUB .)
    INTEGER_CONST   reduce using rule 123 (unaryOp -> SUB .)
    FLOAT_CONST     reduce using rule 123 (unaryOp -> SUB .)
    AND             reduce using rule 123 (unaryOp -> SUB .)
    OR              reduce using rule 123 (unaryOp -> SUB .)
    XOR             reduce using rule 123 (unaryOp -> SUB .)
    XNOR            reduce using rule 123 (unaryOp -> SUB .)


state 73

    (130) mulExp -> unaryExp .

    MUL             reduce using rule 130 (mulExp -> unaryExp .)
    DIV             reduce using rule 130 (mulExp -> unaryExp .)
    MOD             reduce using rule 130 (mulExp -> unaryExp .)
    POWER           reduce using rule 130 (mulExp -> unaryExp .)
    ADD             reduce using rule 130 (mulExp -> unaryExp .)
    SUB             reduce using rule 130 (mulExp -> unaryExp .)
    SLL             reduce using rule 130 (mulExp -> unaryExp .)
    SRL             reduce using rule 130 (mulExp -> unaryExp .)
    SRA             reduce using rule 130 (mulExp -> unaryExp .)
    LT              reduce using rule 130 (mulExp -> unaryExp .)
    GT              reduce using rule 130 (mulExp -> unaryExp .)
    GE              reduce using rule 130 (mulExp -> unaryExp .)
    LE              reduce using rule 130 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 130 (mulExp -> unaryExp .)
    NEQ             reduce using rule 130 (mulExp -> unaryExp .)
    LAND            reduce using rule 130 (mulExp -> unaryExp .)
    LOR             reduce using rule 130 (mulExp -> unaryExp .)
    ]               reduce using rule 130 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 130 (mulExp -> unaryExp .)
    )               reduce using rule 130 (mulExp -> unaryExp .)
    ;               reduce using rule 130 (mulExp -> unaryExp .)
    ,               reduce using rule 130 (mulExp -> unaryExp .)
    COLON           reduce using rule 130 (mulExp -> unaryExp .)
    RETURN          reduce using rule 130 (mulExp -> unaryExp .)
    CONST           reduce using rule 130 (mulExp -> unaryExp .)
    ID              reduce using rule 130 (mulExp -> unaryExp .)
    {               reduce using rule 130 (mulExp -> unaryExp .)
    MUX             reduce using rule 130 (mulExp -> unaryExp .)
    WHEN            reduce using rule 130 (mulExp -> unaryExp .)
    IF              reduce using rule 130 (mulExp -> unaryExp .)
    FOR             reduce using rule 130 (mulExp -> unaryExp .)
    GENERATE        reduce using rule 130 (mulExp -> unaryExp .)
    INT             reduce using rule 130 (mulExp -> unaryExp .)
    FLOAT           reduce using rule 130 (mulExp -> unaryExp .)
    REG             reduce using rule 130 (mulExp -> unaryExp .)
    WIRE            reduce using rule 130 (mulExp -> unaryExp .)
    CLOCK           reduce using rule 130 (mulExp -> unaryExp .)
    AND             reduce using rule 130 (mulExp -> unaryExp .)
    OR              reduce using rule 130 (mulExp -> unaryExp .)
    NOT             reduce using rule 130 (mulExp -> unaryExp .)
    XOR             reduce using rule 130 (mulExp -> unaryExp .)
    XNOR            reduce using rule 130 (mulExp -> unaryExp .)
    SIGNAL          reduce using rule 130 (mulExp -> unaryExp .)
    (               reduce using rule 130 (mulExp -> unaryExp .)
    NOTL            reduce using rule 130 (mulExp -> unaryExp .)
    INTEGER_CONST   reduce using rule 130 (mulExp -> unaryExp .)
    FLOAT_CONST     reduce using rule 130 (mulExp -> unaryExp .)
    }               reduce using rule 130 (mulExp -> unaryExp .)
    ELIF            reduce using rule 130 (mulExp -> unaryExp .)
    ELSE            reduce using rule 130 (mulExp -> unaryExp .)


state 74

    (117) unaryExp -> primaryExp .

    MUL             reduce using rule 117 (unaryExp -> primaryExp .)
    DIV             reduce using rule 117 (unaryExp -> primaryExp .)
    MOD             reduce using rule 117 (unaryExp -> primaryExp .)
    POWER           reduce using rule 117 (unaryExp -> primaryExp .)
    ADD             reduce using rule 117 (unaryExp -> primaryExp .)
    SUB             reduce using rule 117 (unaryExp -> primaryExp .)
    SLL             reduce using rule 117 (unaryExp -> primaryExp .)
    SRL             reduce using rule 117 (unaryExp -> primaryExp .)
    SRA             reduce using rule 117 (unaryExp -> primaryExp .)
    LT              reduce using rule 117 (unaryExp -> primaryExp .)
    GT              reduce using rule 117 (unaryExp -> primaryExp .)
    GE              reduce using rule 117 (unaryExp -> primaryExp .)
    LE              reduce using rule 117 (unaryExp -> primaryExp .)
    EQUAL           reduce using rule 117 (unaryExp -> primaryExp .)
    NEQ             reduce using rule 117 (unaryExp -> primaryExp .)
    LAND            reduce using rule 117 (unaryExp -> primaryExp .)
    LOR             reduce using rule 117 (unaryExp -> primaryExp .)
    ]               reduce using rule 117 (unaryExp -> primaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 117 (unaryExp -> primaryExp .)
    )               reduce using rule 117 (unaryExp -> primaryExp .)
    ;               reduce using rule 117 (unaryExp -> primaryExp .)
    ,               reduce using rule 117 (unaryExp -> primaryExp .)
    COLON           reduce using rule 117 (unaryExp -> primaryExp .)
    RETURN          reduce using rule 117 (unaryExp -> primaryExp .)
    CONST           reduce using rule 117 (unaryExp -> primaryExp .)
    ID              reduce using rule 117 (unaryExp -> primaryExp .)
    {               reduce using rule 117 (unaryExp -> primaryExp .)
    MUX             reduce using rule 117 (unaryExp -> primaryExp .)
    WHEN            reduce using rule 117 (unaryExp -> primaryExp .)
    IF              reduce using rule 117 (unaryExp -> primaryExp .)
    FOR             reduce using rule 117 (unaryExp -> primaryExp .)
    GENERATE        reduce using rule 117 (unaryExp -> primaryExp .)
    INT             reduce using rule 117 (unaryExp -> primaryExp .)
    FLOAT           reduce using rule 117 (unaryExp -> primaryExp .)
    REG             reduce using rule 117 (unaryExp -> primaryExp .)
    WIRE            reduce using rule 117 (unaryExp -> primaryExp .)
    CLOCK           reduce using rule 117 (unaryExp -> primaryExp .)
    AND             reduce using rule 117 (unaryExp -> primaryExp .)
    OR              reduce using rule 117 (unaryExp -> primaryExp .)
    NOT             reduce using rule 117 (unaryExp -> primaryExp .)
    XOR             reduce using rule 117 (unaryExp -> primaryExp .)
    XNOR            reduce using rule 117 (unaryExp -> primaryExp .)
    SIGNAL          reduce using rule 117 (unaryExp -> primaryExp .)
    (               reduce using rule 117 (unaryExp -> primaryExp .)
    NOTL            reduce using rule 117 (unaryExp -> primaryExp .)
    INTEGER_CONST   reduce using rule 117 (unaryExp -> primaryExp .)
    FLOAT_CONST     reduce using rule 117 (unaryExp -> primaryExp .)
    }               reduce using rule 117 (unaryExp -> primaryExp .)
    ELIF            reduce using rule 117 (unaryExp -> primaryExp .)
    ELSE            reduce using rule 117 (unaryExp -> primaryExp .)


state 75

    (118) unaryExp -> ID . ( )
    (119) unaryExp -> ID . ( funcRParams )
    (98) lVal -> ID . array_exp_repeat1
    (99) lVal -> ID . array_exp_repeat2
    (109) array_exp_repeat1 -> . empty
    (110) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (111) array_exp_repeat2 -> . empty
    (112) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 151
    [               shift and go to state 155
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    ]               reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    COLON           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ELIF            reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

  ! (               [ reduce using rule 1 (empty -> .) ]

    array_exp_repeat1              shift and go to state 152
    array_exp_repeat2              shift and go to state 153
    empty                          shift and go to state 154

state 76

    (104) primaryExp -> ( . exp )
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 156
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 77

    (120) unaryExp -> SIGNAL . ( unaryExp )

    (               shift and go to state 157


state 78

    (121) unaryExp -> unaryOp . unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    unaryOp                        shift and go to state 78
    unaryExp                       shift and go to state 158
    primaryExp                     shift and go to state 74
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70

state 79

    (105) primaryExp -> lVal .
    (103) lVal -> lVal . . ID

    MUL             reduce using rule 105 (primaryExp -> lVal .)
    DIV             reduce using rule 105 (primaryExp -> lVal .)
    MOD             reduce using rule 105 (primaryExp -> lVal .)
    POWER           reduce using rule 105 (primaryExp -> lVal .)
    ADD             reduce using rule 105 (primaryExp -> lVal .)
    SUB             reduce using rule 105 (primaryExp -> lVal .)
    SLL             reduce using rule 105 (primaryExp -> lVal .)
    SRL             reduce using rule 105 (primaryExp -> lVal .)
    SRA             reduce using rule 105 (primaryExp -> lVal .)
    LT              reduce using rule 105 (primaryExp -> lVal .)
    GT              reduce using rule 105 (primaryExp -> lVal .)
    GE              reduce using rule 105 (primaryExp -> lVal .)
    LE              reduce using rule 105 (primaryExp -> lVal .)
    EQUAL           reduce using rule 105 (primaryExp -> lVal .)
    NEQ             reduce using rule 105 (primaryExp -> lVal .)
    LAND            reduce using rule 105 (primaryExp -> lVal .)
    LOR             reduce using rule 105 (primaryExp -> lVal .)
    ]               reduce using rule 105 (primaryExp -> lVal .)
    BIT_WIDTH_NUMBER reduce using rule 105 (primaryExp -> lVal .)
    )               reduce using rule 105 (primaryExp -> lVal .)
    ;               reduce using rule 105 (primaryExp -> lVal .)
    ,               reduce using rule 105 (primaryExp -> lVal .)
    COLON           reduce using rule 105 (primaryExp -> lVal .)
    RETURN          reduce using rule 105 (primaryExp -> lVal .)
    CONST           reduce using rule 105 (primaryExp -> lVal .)
    ID              reduce using rule 105 (primaryExp -> lVal .)
    {               reduce using rule 105 (primaryExp -> lVal .)
    MUX             reduce using rule 105 (primaryExp -> lVal .)
    WHEN            reduce using rule 105 (primaryExp -> lVal .)
    IF              reduce using rule 105 (primaryExp -> lVal .)
    FOR             reduce using rule 105 (primaryExp -> lVal .)
    GENERATE        reduce using rule 105 (primaryExp -> lVal .)
    INT             reduce using rule 105 (primaryExp -> lVal .)
    FLOAT           reduce using rule 105 (primaryExp -> lVal .)
    REG             reduce using rule 105 (primaryExp -> lVal .)
    WIRE            reduce using rule 105 (primaryExp -> lVal .)
    CLOCK           reduce using rule 105 (primaryExp -> lVal .)
    AND             reduce using rule 105 (primaryExp -> lVal .)
    OR              reduce using rule 105 (primaryExp -> lVal .)
    NOT             reduce using rule 105 (primaryExp -> lVal .)
    XOR             reduce using rule 105 (primaryExp -> lVal .)
    XNOR            reduce using rule 105 (primaryExp -> lVal .)
    SIGNAL          reduce using rule 105 (primaryExp -> lVal .)
    (               reduce using rule 105 (primaryExp -> lVal .)
    NOTL            reduce using rule 105 (primaryExp -> lVal .)
    INTEGER_CONST   reduce using rule 105 (primaryExp -> lVal .)
    FLOAT_CONST     reduce using rule 105 (primaryExp -> lVal .)
    }               reduce using rule 105 (primaryExp -> lVal .)
    ELIF            reduce using rule 105 (primaryExp -> lVal .)
    ELSE            reduce using rule 105 (primaryExp -> lVal .)
    .               shift and go to state 159


state 80

    (106) primaryExp -> number .

    MUL             reduce using rule 106 (primaryExp -> number .)
    DIV             reduce using rule 106 (primaryExp -> number .)
    MOD             reduce using rule 106 (primaryExp -> number .)
    POWER           reduce using rule 106 (primaryExp -> number .)
    ADD             reduce using rule 106 (primaryExp -> number .)
    SUB             reduce using rule 106 (primaryExp -> number .)
    SLL             reduce using rule 106 (primaryExp -> number .)
    SRL             reduce using rule 106 (primaryExp -> number .)
    SRA             reduce using rule 106 (primaryExp -> number .)
    LT              reduce using rule 106 (primaryExp -> number .)
    GT              reduce using rule 106 (primaryExp -> number .)
    GE              reduce using rule 106 (primaryExp -> number .)
    LE              reduce using rule 106 (primaryExp -> number .)
    EQUAL           reduce using rule 106 (primaryExp -> number .)
    NEQ             reduce using rule 106 (primaryExp -> number .)
    LAND            reduce using rule 106 (primaryExp -> number .)
    LOR             reduce using rule 106 (primaryExp -> number .)
    ]               reduce using rule 106 (primaryExp -> number .)
    BIT_WIDTH_NUMBER reduce using rule 106 (primaryExp -> number .)
    )               reduce using rule 106 (primaryExp -> number .)
    ;               reduce using rule 106 (primaryExp -> number .)
    ,               reduce using rule 106 (primaryExp -> number .)
    COLON           reduce using rule 106 (primaryExp -> number .)
    RETURN          reduce using rule 106 (primaryExp -> number .)
    CONST           reduce using rule 106 (primaryExp -> number .)
    ID              reduce using rule 106 (primaryExp -> number .)
    {               reduce using rule 106 (primaryExp -> number .)
    MUX             reduce using rule 106 (primaryExp -> number .)
    WHEN            reduce using rule 106 (primaryExp -> number .)
    IF              reduce using rule 106 (primaryExp -> number .)
    FOR             reduce using rule 106 (primaryExp -> number .)
    GENERATE        reduce using rule 106 (primaryExp -> number .)
    INT             reduce using rule 106 (primaryExp -> number .)
    FLOAT           reduce using rule 106 (primaryExp -> number .)
    REG             reduce using rule 106 (primaryExp -> number .)
    WIRE            reduce using rule 106 (primaryExp -> number .)
    CLOCK           reduce using rule 106 (primaryExp -> number .)
    AND             reduce using rule 106 (primaryExp -> number .)
    OR              reduce using rule 106 (primaryExp -> number .)
    NOT             reduce using rule 106 (primaryExp -> number .)
    XOR             reduce using rule 106 (primaryExp -> number .)
    XNOR            reduce using rule 106 (primaryExp -> number .)
    SIGNAL          reduce using rule 106 (primaryExp -> number .)
    (               reduce using rule 106 (primaryExp -> number .)
    NOTL            reduce using rule 106 (primaryExp -> number .)
    INTEGER_CONST   reduce using rule 106 (primaryExp -> number .)
    FLOAT_CONST     reduce using rule 106 (primaryExp -> number .)
    }               reduce using rule 106 (primaryExp -> number .)
    ELIF            reduce using rule 106 (primaryExp -> number .)
    ELSE            reduce using rule 106 (primaryExp -> number .)


state 81

    (125) unaryOp -> NOTL .

    ID              reduce using rule 125 (unaryOp -> NOTL .)
    SIGNAL          reduce using rule 125 (unaryOp -> NOTL .)
    (               reduce using rule 125 (unaryOp -> NOTL .)
    ADD             reduce using rule 125 (unaryOp -> NOTL .)
    SUB             reduce using rule 125 (unaryOp -> NOTL .)
    NOT             reduce using rule 125 (unaryOp -> NOTL .)
    NOTL            reduce using rule 125 (unaryOp -> NOTL .)
    {               reduce using rule 125 (unaryOp -> NOTL .)
    MUX             reduce using rule 125 (unaryOp -> NOTL .)
    INTEGER_CONST   reduce using rule 125 (unaryOp -> NOTL .)
    FLOAT_CONST     reduce using rule 125 (unaryOp -> NOTL .)
    AND             reduce using rule 125 (unaryOp -> NOTL .)
    OR              reduce using rule 125 (unaryOp -> NOTL .)
    XOR             reduce using rule 125 (unaryOp -> NOTL .)
    XNOR            reduce using rule 125 (unaryOp -> NOTL .)


state 82

    (100) lVal -> { . ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> { . ID array_exp_repeat2 lVal_repeat }

    ID              shift and go to state 160


state 83

    (102) lVal -> MUX . ( exp , exp , exp )

    (               shift and go to state 161


state 84

    (113) number -> INTEGER_CONST .

    MUL             reduce using rule 113 (number -> INTEGER_CONST .)
    DIV             reduce using rule 113 (number -> INTEGER_CONST .)
    MOD             reduce using rule 113 (number -> INTEGER_CONST .)
    POWER           reduce using rule 113 (number -> INTEGER_CONST .)
    ADD             reduce using rule 113 (number -> INTEGER_CONST .)
    SUB             reduce using rule 113 (number -> INTEGER_CONST .)
    SLL             reduce using rule 113 (number -> INTEGER_CONST .)
    SRL             reduce using rule 113 (number -> INTEGER_CONST .)
    SRA             reduce using rule 113 (number -> INTEGER_CONST .)
    LT              reduce using rule 113 (number -> INTEGER_CONST .)
    GT              reduce using rule 113 (number -> INTEGER_CONST .)
    GE              reduce using rule 113 (number -> INTEGER_CONST .)
    LE              reduce using rule 113 (number -> INTEGER_CONST .)
    EQUAL           reduce using rule 113 (number -> INTEGER_CONST .)
    NEQ             reduce using rule 113 (number -> INTEGER_CONST .)
    LAND            reduce using rule 113 (number -> INTEGER_CONST .)
    LOR             reduce using rule 113 (number -> INTEGER_CONST .)
    ]               reduce using rule 113 (number -> INTEGER_CONST .)
    BIT_WIDTH_NUMBER reduce using rule 113 (number -> INTEGER_CONST .)
    )               reduce using rule 113 (number -> INTEGER_CONST .)
    ;               reduce using rule 113 (number -> INTEGER_CONST .)
    ,               reduce using rule 113 (number -> INTEGER_CONST .)
    COLON           reduce using rule 113 (number -> INTEGER_CONST .)
    RETURN          reduce using rule 113 (number -> INTEGER_CONST .)
    CONST           reduce using rule 113 (number -> INTEGER_CONST .)
    ID              reduce using rule 113 (number -> INTEGER_CONST .)
    {               reduce using rule 113 (number -> INTEGER_CONST .)
    MUX             reduce using rule 113 (number -> INTEGER_CONST .)
    WHEN            reduce using rule 113 (number -> INTEGER_CONST .)
    IF              reduce using rule 113 (number -> INTEGER_CONST .)
    FOR             reduce using rule 113 (number -> INTEGER_CONST .)
    GENERATE        reduce using rule 113 (number -> INTEGER_CONST .)
    INT             reduce using rule 113 (number -> INTEGER_CONST .)
    FLOAT           reduce using rule 113 (number -> INTEGER_CONST .)
    REG             reduce using rule 113 (number -> INTEGER_CONST .)
    WIRE            reduce using rule 113 (number -> INTEGER_CONST .)
    CLOCK           reduce using rule 113 (number -> INTEGER_CONST .)
    AND             reduce using rule 113 (number -> INTEGER_CONST .)
    OR              reduce using rule 113 (number -> INTEGER_CONST .)
    NOT             reduce using rule 113 (number -> INTEGER_CONST .)
    XOR             reduce using rule 113 (number -> INTEGER_CONST .)
    XNOR            reduce using rule 113 (number -> INTEGER_CONST .)
    SIGNAL          reduce using rule 113 (number -> INTEGER_CONST .)
    (               reduce using rule 113 (number -> INTEGER_CONST .)
    NOTL            reduce using rule 113 (number -> INTEGER_CONST .)
    INTEGER_CONST   reduce using rule 113 (number -> INTEGER_CONST .)
    FLOAT_CONST     reduce using rule 113 (number -> INTEGER_CONST .)
    }               reduce using rule 113 (number -> INTEGER_CONST .)
    ELIF            reduce using rule 113 (number -> INTEGER_CONST .)
    ELSE            reduce using rule 113 (number -> INTEGER_CONST .)


state 85

    (114) number -> FLOAT_CONST .

    MUL             reduce using rule 114 (number -> FLOAT_CONST .)
    DIV             reduce using rule 114 (number -> FLOAT_CONST .)
    MOD             reduce using rule 114 (number -> FLOAT_CONST .)
    POWER           reduce using rule 114 (number -> FLOAT_CONST .)
    ADD             reduce using rule 114 (number -> FLOAT_CONST .)
    SUB             reduce using rule 114 (number -> FLOAT_CONST .)
    SLL             reduce using rule 114 (number -> FLOAT_CONST .)
    SRL             reduce using rule 114 (number -> FLOAT_CONST .)
    SRA             reduce using rule 114 (number -> FLOAT_CONST .)
    LT              reduce using rule 114 (number -> FLOAT_CONST .)
    GT              reduce using rule 114 (number -> FLOAT_CONST .)
    GE              reduce using rule 114 (number -> FLOAT_CONST .)
    LE              reduce using rule 114 (number -> FLOAT_CONST .)
    EQUAL           reduce using rule 114 (number -> FLOAT_CONST .)
    NEQ             reduce using rule 114 (number -> FLOAT_CONST .)
    LAND            reduce using rule 114 (number -> FLOAT_CONST .)
    LOR             reduce using rule 114 (number -> FLOAT_CONST .)
    ]               reduce using rule 114 (number -> FLOAT_CONST .)
    BIT_WIDTH_NUMBER reduce using rule 114 (number -> FLOAT_CONST .)
    )               reduce using rule 114 (number -> FLOAT_CONST .)
    ;               reduce using rule 114 (number -> FLOAT_CONST .)
    ,               reduce using rule 114 (number -> FLOAT_CONST .)
    COLON           reduce using rule 114 (number -> FLOAT_CONST .)
    RETURN          reduce using rule 114 (number -> FLOAT_CONST .)
    CONST           reduce using rule 114 (number -> FLOAT_CONST .)
    ID              reduce using rule 114 (number -> FLOAT_CONST .)
    {               reduce using rule 114 (number -> FLOAT_CONST .)
    MUX             reduce using rule 114 (number -> FLOAT_CONST .)
    WHEN            reduce using rule 114 (number -> FLOAT_CONST .)
    IF              reduce using rule 114 (number -> FLOAT_CONST .)
    FOR             reduce using rule 114 (number -> FLOAT_CONST .)
    GENERATE        reduce using rule 114 (number -> FLOAT_CONST .)
    INT             reduce using rule 114 (number -> FLOAT_CONST .)
    FLOAT           reduce using rule 114 (number -> FLOAT_CONST .)
    REG             reduce using rule 114 (number -> FLOAT_CONST .)
    WIRE            reduce using rule 114 (number -> FLOAT_CONST .)
    CLOCK           reduce using rule 114 (number -> FLOAT_CONST .)
    AND             reduce using rule 114 (number -> FLOAT_CONST .)
    OR              reduce using rule 114 (number -> FLOAT_CONST .)
    NOT             reduce using rule 114 (number -> FLOAT_CONST .)
    XOR             reduce using rule 114 (number -> FLOAT_CONST .)
    XNOR            reduce using rule 114 (number -> FLOAT_CONST .)
    SIGNAL          reduce using rule 114 (number -> FLOAT_CONST .)
    (               reduce using rule 114 (number -> FLOAT_CONST .)
    NOTL            reduce using rule 114 (number -> FLOAT_CONST .)
    INTEGER_CONST   reduce using rule 114 (number -> FLOAT_CONST .)
    FLOAT_CONST     reduce using rule 114 (number -> FLOAT_CONST .)
    }               reduce using rule 114 (number -> FLOAT_CONST .)
    ELIF            reduce using rule 114 (number -> FLOAT_CONST .)
    ELSE            reduce using rule 114 (number -> FLOAT_CONST .)


state 86

    (115) number -> circuit_const .

    MUL             reduce using rule 115 (number -> circuit_const .)
    DIV             reduce using rule 115 (number -> circuit_const .)
    MOD             reduce using rule 115 (number -> circuit_const .)
    POWER           reduce using rule 115 (number -> circuit_const .)
    ADD             reduce using rule 115 (number -> circuit_const .)
    SUB             reduce using rule 115 (number -> circuit_const .)
    SLL             reduce using rule 115 (number -> circuit_const .)
    SRL             reduce using rule 115 (number -> circuit_const .)
    SRA             reduce using rule 115 (number -> circuit_const .)
    LT              reduce using rule 115 (number -> circuit_const .)
    GT              reduce using rule 115 (number -> circuit_const .)
    GE              reduce using rule 115 (number -> circuit_const .)
    LE              reduce using rule 115 (number -> circuit_const .)
    EQUAL           reduce using rule 115 (number -> circuit_const .)
    NEQ             reduce using rule 115 (number -> circuit_const .)
    LAND            reduce using rule 115 (number -> circuit_const .)
    LOR             reduce using rule 115 (number -> circuit_const .)
    ]               reduce using rule 115 (number -> circuit_const .)
    BIT_WIDTH_NUMBER reduce using rule 115 (number -> circuit_const .)
    )               reduce using rule 115 (number -> circuit_const .)
    ;               reduce using rule 115 (number -> circuit_const .)
    ,               reduce using rule 115 (number -> circuit_const .)
    COLON           reduce using rule 115 (number -> circuit_const .)
    RETURN          reduce using rule 115 (number -> circuit_const .)
    CONST           reduce using rule 115 (number -> circuit_const .)
    ID              reduce using rule 115 (number -> circuit_const .)
    {               reduce using rule 115 (number -> circuit_const .)
    MUX             reduce using rule 115 (number -> circuit_const .)
    WHEN            reduce using rule 115 (number -> circuit_const .)
    IF              reduce using rule 115 (number -> circuit_const .)
    FOR             reduce using rule 115 (number -> circuit_const .)
    GENERATE        reduce using rule 115 (number -> circuit_const .)
    INT             reduce using rule 115 (number -> circuit_const .)
    FLOAT           reduce using rule 115 (number -> circuit_const .)
    REG             reduce using rule 115 (number -> circuit_const .)
    WIRE            reduce using rule 115 (number -> circuit_const .)
    CLOCK           reduce using rule 115 (number -> circuit_const .)
    AND             reduce using rule 115 (number -> circuit_const .)
    OR              reduce using rule 115 (number -> circuit_const .)
    NOT             reduce using rule 115 (number -> circuit_const .)
    XOR             reduce using rule 115 (number -> circuit_const .)
    XNOR            reduce using rule 115 (number -> circuit_const .)
    SIGNAL          reduce using rule 115 (number -> circuit_const .)
    (               reduce using rule 115 (number -> circuit_const .)
    NOTL            reduce using rule 115 (number -> circuit_const .)
    INTEGER_CONST   reduce using rule 115 (number -> circuit_const .)
    FLOAT_CONST     reduce using rule 115 (number -> circuit_const .)
    }               reduce using rule 115 (number -> circuit_const .)
    ELIF            reduce using rule 115 (number -> circuit_const .)
    ELSE            reduce using rule 115 (number -> circuit_const .)


state 87

    (25) type_def -> cir_type .

    ID              reduce using rule 25 (type_def -> cir_type .)


state 88

    (56) cir_function -> cir_type ID ( cir_funcFParams . ) block

    )               shift and go to state 162


state 89

    (60) cir_funcFParams -> cir_funcFParam . cir_funcFParams_repeat
    (58) cir_funcFParams_repeat -> . empty
    (59) cir_funcFParams_repeat -> . , cir_funcFParam cir_funcFParams_repeat
    (1) empty -> .

    ,               shift and go to state 165
    )               reduce using rule 1 (empty -> .)

    cir_funcFParams_repeat         shift and go to state 163
    empty                          shift and go to state 164

state 90

    (64) cir_funcFParam -> type_def . ID array

    ID              shift and go to state 166


state 91

    (24) type_def -> val_type .

    ID              reduce using rule 24 (type_def -> val_type .)


state 92

    (55) cirDef -> ID array ASSIGN . initVal
    (50) initVal -> . exp ;
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    initVal                        shift and go to state 167
    exp                            shift and go to state 168
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 93

    (27) array -> [ constExp . ] array

    ]               shift and go to state 169


state 94

    (167) constExp -> exp .
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               reduce using rule 167 (constExp -> exp .)
    ,               reduce using rule 167 (constExp -> exp .)
    ;               reduce using rule 167 (constExp -> exp .)
    }               reduce using rule 167 (constExp -> exp .)
    BIT_WIDTH_NUMBER shift and go to state 122


state 95

    (53) cirDecl -> cir_type cirDef cirDecl_repeat ; .

    MODULE          reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    BUNDLE          reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    CONST           reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    ID              reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    INT             reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    FLOAT           reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    REG             reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    WIRE            reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    CLOCK           reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    $end            reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    ;               reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    RETURN          reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    {               reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    MUX             reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    WHEN            reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    IF              reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    FOR             reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    GENERATE        reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    AND             reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    OR              reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    NOT             reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    XOR             reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    XNOR            reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    SIGNAL          reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    (               reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    ADD             reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    SUB             reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    NOTL            reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    INTEGER_CONST   reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    FLOAT_CONST     reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)
    }               reduce using rule 53 (cirDecl -> cir_type cirDef cirDecl_repeat ; .)


state 96

    (52) cirDecl_repeat -> , cirDef . cirDecl_repeat
    (51) cirDecl_repeat -> . empty
    (52) cirDecl_repeat -> . , cirDef cirDecl_repeat
    (1) empty -> .

    ,               shift and go to state 42
    ;               reduce using rule 1 (empty -> .)

    cirDecl_repeat                 shift and go to state 170
    empty                          shift and go to state 41

state 97

    (54) cirDef -> ID . array
    (55) cirDef -> ID . array ASSIGN initVal
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 39
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)

    array                          shift and go to state 37
    empty                          shift and go to state 38

state 98

    (38) modDecl -> ID ID ( module_R_params . )

    )               shift and go to state 171


state 99

    (45) module_R_params -> p_module_R_params_item . module_R_params_repeat
    (43) module_R_params_repeat -> . empty
    (44) module_R_params_repeat -> . , p_module_R_params_item module_R_params_repeat
    (1) empty -> .

    ,               shift and go to state 174
    )               reduce using rule 1 (empty -> .)

    module_R_params_repeat         shift and go to state 172
    empty                          shift and go to state 173

state 100

    (42) p_module_R_params_item -> R_port_def . ID ( ID )

    ID              shift and go to state 175


state 101

    (39) R_port_def -> IN . .

    .               shift and go to state 176


state 102

    (40) R_port_def -> OUT . .

    .               shift and go to state 177


state 103

    (41) R_port_def -> INOUT . .

    .               shift and go to state 178


state 104

    (47) bundleDecl_repeat -> , bundleDef . bundleDecl_repeat
    (46) bundleDecl_repeat -> . empty
    (47) bundleDecl_repeat -> . , bundleDef bundleDecl_repeat
    (1) empty -> .

    ,               shift and go to state 47
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    bundleDecl_repeat              shift and go to state 179
    empty                          shift and go to state 46

state 105

    (49) bundleDef -> ID . array
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 39
    ,               reduce using rule 1 (empty -> .)
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    array                          shift and go to state 44
    empty                          shift and go to state 38

state 106

    (65) funcFParam -> val_type . ID array

    ID              shift and go to state 180


state 107

    (57) function -> val_type ID ( funcFParams . ) block

    )               shift and go to state 181


state 108

    (63) funcFParams -> funcFParam . funcFParams_repeat
    (61) funcFParams_repeat -> . empty
    (62) funcFParams_repeat -> . , funcFParam funcFParams_repeat
    (1) empty -> .

    ,               shift and go to state 184
    )               reduce using rule 1 (empty -> .)

    funcFParams_repeat             shift and go to state 182
    empty                          shift and go to state 183

state 109

    (37) varDef -> ID array ASSIGN . initVal
    (50) initVal -> . exp ;
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    initVal                        shift and go to state 185
    exp                            shift and go to state 168
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 110

    (35) varDecl -> val_type varDef varDef_repeat ; .

    MODULE          reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    BUNDLE          reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    CONST           reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    ID              reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    INT             reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    FLOAT           reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    REG             reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    WIRE            reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    CLOCK           reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    $end            reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    ;               reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    RETURN          reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    {               reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    MUX             reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    WHEN            reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    IF              reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    FOR             reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    GENERATE        reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    AND             reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    OR              reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    NOT             reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    XOR             reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    XNOR            reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    SIGNAL          reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    (               reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    ADD             reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    SUB             reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    NOTL            reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    INTEGER_CONST   reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    FLOAT_CONST     reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)
    }               reduce using rule 35 (varDecl -> val_type varDef varDef_repeat ; .)


state 111

    (34) varDef_repeat -> , varDef . varDef_repeat
    (33) varDef_repeat -> . empty
    (34) varDef_repeat -> . , varDef varDef_repeat
    (1) empty -> .

    ,               shift and go to state 52
    ;               reduce using rule 1 (empty -> .)

    varDef_repeat                  shift and go to state 186
    empty                          shift and go to state 51

state 112

    (36) varDef -> ID . array
    (37) varDef -> ID . array ASSIGN initVal
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 39
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)

    array                          shift and go to state 49
    empty                          shift and go to state 38

state 113

    (70) module -> MODULE ID ( module_para_para . port_def ID p_module_para_port
    (164) port_def -> . INPUT
    (165) port_def -> . OUTPUT
    (166) port_def -> . INOUT

    INPUT           shift and go to state 188
    OUTPUT          shift and go to state 189
    INOUT           shift and go to state 190

    port_def                       shift and go to state 187

state 114

    (66) module_para_para -> empty .

    INPUT           reduce using rule 66 (module_para_para -> empty .)
    OUTPUT          reduce using rule 66 (module_para_para -> empty .)
    INOUT           reduce using rule 66 (module_para_para -> empty .)


state 115

    (67) module_para_para -> PARA . ID , module_para_para

    ID              shift and go to state 191


state 116

    (73) bundle -> BUNDLE ID ( cir_type . ID bundle_repeat )

    ID              shift and go to state 192


state 117

    (16) constDecl -> CONST val_type constDef constDecl_repeat . ;

    ;               shift and go to state 193


state 118

    (14) constDecl_repeat -> empty .

    ;               reduce using rule 14 (constDecl_repeat -> empty .)


state 119

    (15) constDecl_repeat -> , . constDef constDecl_repeat
    (28) constDef -> . ID array ASSIGN constInitVal

    ID              shift and go to state 56

    constDef                       shift and go to state 194

state 120

    (28) constDef -> ID array . ASSIGN constInitVal

    ASSIGN          shift and go to state 195


state 121

    (21) cir_type -> cir_basic_type [ exp ] .

    ID              reduce using rule 21 (cir_type -> cir_basic_type [ exp ] .)


state 122

    (116) circuit_const -> exp BIT_WIDTH_NUMBER .

    MUL             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    DIV             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    MOD             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    POWER           reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ADD             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SUB             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SLL             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SRL             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SRA             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    LT              reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    GT              reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    GE              reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    LE              reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    EQUAL           reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    NEQ             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    LAND            reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    LOR             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ]               reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    BIT_WIDTH_NUMBER reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    )               reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ;               reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ,               reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    COLON           reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    RETURN          reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    CONST           reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ID              reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    {               reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    MUX             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    WHEN            reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    IF              reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    FOR             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    GENERATE        reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    INT             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    FLOAT           reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    REG             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    WIRE            reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    CLOCK           reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    AND             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    OR              reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    NOT             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    XOR             reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    XNOR            reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    SIGNAL          reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    (               reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    NOTL            reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    INTEGER_CONST   reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    FLOAT_CONST     reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    }               reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ELIF            reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)
    ELSE            reduce using rule 116 (circuit_const -> exp BIT_WIDTH_NUMBER .)


state 123

    (163) lOrExp -> lOrExp LOR . lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 196
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 124

    (161) lAndExp -> lAndExp LAND . redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 197
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58

state 125

    (148) eqExp -> eqExp LT . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 198
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 126

    (149) eqExp -> eqExp GT . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 199
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 127

    (150) eqExp -> eqExp GE . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 200
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 128

    (151) eqExp -> eqExp LE . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 201
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 129

    (152) eqExp -> eqExp EQUAL . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 202
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 130

    (153) eqExp -> eqExp NEQ . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    eqExp                          shift and go to state 203
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 131

    (155) redExp -> AND eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! reduce/reduce conflict for LAND resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 154 (redExp -> eqExp .)
    ]               reduce using rule 155 (redExp -> AND eqExp .)
    )               reduce using rule 155 (redExp -> AND eqExp .)
    ;               reduce using rule 155 (redExp -> AND eqExp .)
    ,               reduce using rule 155 (redExp -> AND eqExp .)
    COLON           reduce using rule 155 (redExp -> AND eqExp .)
    RETURN          reduce using rule 155 (redExp -> AND eqExp .)
    CONST           reduce using rule 155 (redExp -> AND eqExp .)
    ID              reduce using rule 155 (redExp -> AND eqExp .)
    {               reduce using rule 155 (redExp -> AND eqExp .)
    MUX             reduce using rule 155 (redExp -> AND eqExp .)
    WHEN            reduce using rule 155 (redExp -> AND eqExp .)
    IF              reduce using rule 155 (redExp -> AND eqExp .)
    FOR             reduce using rule 155 (redExp -> AND eqExp .)
    GENERATE        reduce using rule 155 (redExp -> AND eqExp .)
    INT             reduce using rule 155 (redExp -> AND eqExp .)
    FLOAT           reduce using rule 155 (redExp -> AND eqExp .)
    REG             reduce using rule 155 (redExp -> AND eqExp .)
    WIRE            reduce using rule 155 (redExp -> AND eqExp .)
    CLOCK           reduce using rule 155 (redExp -> AND eqExp .)
    AND             reduce using rule 155 (redExp -> AND eqExp .)
    OR              reduce using rule 155 (redExp -> AND eqExp .)
    NOT             reduce using rule 155 (redExp -> AND eqExp .)
    XOR             reduce using rule 155 (redExp -> AND eqExp .)
    XNOR            reduce using rule 155 (redExp -> AND eqExp .)
    SIGNAL          reduce using rule 155 (redExp -> AND eqExp .)
    (               reduce using rule 155 (redExp -> AND eqExp .)
    ADD             reduce using rule 155 (redExp -> AND eqExp .)
    SUB             reduce using rule 155 (redExp -> AND eqExp .)
    NOTL            reduce using rule 155 (redExp -> AND eqExp .)
    INTEGER_CONST   reduce using rule 155 (redExp -> AND eqExp .)
    FLOAT_CONST     reduce using rule 155 (redExp -> AND eqExp .)
    }               reduce using rule 155 (redExp -> AND eqExp .)
    ELIF            reduce using rule 155 (redExp -> AND eqExp .)
    ELSE            reduce using rule 155 (redExp -> AND eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130
    LAND            reduce using rule 154 (redExp -> eqExp .)
    LOR             reduce using rule 154 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 154 (redExp -> eqExp .)

  ! LAND            [ reduce using rule 155 (redExp -> AND eqExp .) ]
  ! LOR             [ reduce using rule 155 (redExp -> AND eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 155 (redExp -> AND eqExp .) ]


state 132

    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    BIT_WIDTH_NUMBER shift and go to state 122


state 133

    (124) unaryOp -> NOT .
    (157) redExp -> NOT . eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SIGNAL resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NOTL resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for MUX resolved as shift
  ! shift/reduce conflict for INTEGER_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for XNOR resolved as shift
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

  ! ID              [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! SIGNAL          [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! (               [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! ADD             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! SUB             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! NOT             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! NOTL            [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! {               [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! MUX             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! INTEGER_CONST   [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! FLOAT_CONST     [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! AND             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! OR              [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! XOR             [ reduce using rule 124 (unaryOp -> NOT .) ]
  ! XNOR            [ reduce using rule 124 (unaryOp -> NOT .) ]

    eqExp                          shift and go to state 135
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60

state 134

    (156) redExp -> OR eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! reduce/reduce conflict for LAND resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 154 (redExp -> eqExp .)
    ]               reduce using rule 156 (redExp -> OR eqExp .)
    )               reduce using rule 156 (redExp -> OR eqExp .)
    ;               reduce using rule 156 (redExp -> OR eqExp .)
    ,               reduce using rule 156 (redExp -> OR eqExp .)
    COLON           reduce using rule 156 (redExp -> OR eqExp .)
    RETURN          reduce using rule 156 (redExp -> OR eqExp .)
    CONST           reduce using rule 156 (redExp -> OR eqExp .)
    ID              reduce using rule 156 (redExp -> OR eqExp .)
    {               reduce using rule 156 (redExp -> OR eqExp .)
    MUX             reduce using rule 156 (redExp -> OR eqExp .)
    WHEN            reduce using rule 156 (redExp -> OR eqExp .)
    IF              reduce using rule 156 (redExp -> OR eqExp .)
    FOR             reduce using rule 156 (redExp -> OR eqExp .)
    GENERATE        reduce using rule 156 (redExp -> OR eqExp .)
    INT             reduce using rule 156 (redExp -> OR eqExp .)
    FLOAT           reduce using rule 156 (redExp -> OR eqExp .)
    REG             reduce using rule 156 (redExp -> OR eqExp .)
    WIRE            reduce using rule 156 (redExp -> OR eqExp .)
    CLOCK           reduce using rule 156 (redExp -> OR eqExp .)
    AND             reduce using rule 156 (redExp -> OR eqExp .)
    OR              reduce using rule 156 (redExp -> OR eqExp .)
    NOT             reduce using rule 156 (redExp -> OR eqExp .)
    XOR             reduce using rule 156 (redExp -> OR eqExp .)
    XNOR            reduce using rule 156 (redExp -> OR eqExp .)
    SIGNAL          reduce using rule 156 (redExp -> OR eqExp .)
    (               reduce using rule 156 (redExp -> OR eqExp .)
    ADD             reduce using rule 156 (redExp -> OR eqExp .)
    SUB             reduce using rule 156 (redExp -> OR eqExp .)
    NOTL            reduce using rule 156 (redExp -> OR eqExp .)
    INTEGER_CONST   reduce using rule 156 (redExp -> OR eqExp .)
    FLOAT_CONST     reduce using rule 156 (redExp -> OR eqExp .)
    }               reduce using rule 156 (redExp -> OR eqExp .)
    ELIF            reduce using rule 156 (redExp -> OR eqExp .)
    ELSE            reduce using rule 156 (redExp -> OR eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130
    LAND            reduce using rule 154 (redExp -> eqExp .)
    LOR             reduce using rule 154 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 154 (redExp -> eqExp .)

  ! LAND            [ reduce using rule 156 (redExp -> OR eqExp .) ]
  ! LOR             [ reduce using rule 156 (redExp -> OR eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 156 (redExp -> OR eqExp .) ]


state 135

    (157) redExp -> NOT eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! reduce/reduce conflict for LAND resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 154 (redExp -> eqExp .)
    ]               reduce using rule 157 (redExp -> NOT eqExp .)
    )               reduce using rule 157 (redExp -> NOT eqExp .)
    ;               reduce using rule 157 (redExp -> NOT eqExp .)
    ,               reduce using rule 157 (redExp -> NOT eqExp .)
    COLON           reduce using rule 157 (redExp -> NOT eqExp .)
    RETURN          reduce using rule 157 (redExp -> NOT eqExp .)
    CONST           reduce using rule 157 (redExp -> NOT eqExp .)
    ID              reduce using rule 157 (redExp -> NOT eqExp .)
    {               reduce using rule 157 (redExp -> NOT eqExp .)
    MUX             reduce using rule 157 (redExp -> NOT eqExp .)
    WHEN            reduce using rule 157 (redExp -> NOT eqExp .)
    IF              reduce using rule 157 (redExp -> NOT eqExp .)
    FOR             reduce using rule 157 (redExp -> NOT eqExp .)
    GENERATE        reduce using rule 157 (redExp -> NOT eqExp .)
    INT             reduce using rule 157 (redExp -> NOT eqExp .)
    FLOAT           reduce using rule 157 (redExp -> NOT eqExp .)
    REG             reduce using rule 157 (redExp -> NOT eqExp .)
    WIRE            reduce using rule 157 (redExp -> NOT eqExp .)
    CLOCK           reduce using rule 157 (redExp -> NOT eqExp .)
    AND             reduce using rule 157 (redExp -> NOT eqExp .)
    OR              reduce using rule 157 (redExp -> NOT eqExp .)
    NOT             reduce using rule 157 (redExp -> NOT eqExp .)
    XOR             reduce using rule 157 (redExp -> NOT eqExp .)
    XNOR            reduce using rule 157 (redExp -> NOT eqExp .)
    SIGNAL          reduce using rule 157 (redExp -> NOT eqExp .)
    (               reduce using rule 157 (redExp -> NOT eqExp .)
    ADD             reduce using rule 157 (redExp -> NOT eqExp .)
    SUB             reduce using rule 157 (redExp -> NOT eqExp .)
    NOTL            reduce using rule 157 (redExp -> NOT eqExp .)
    INTEGER_CONST   reduce using rule 157 (redExp -> NOT eqExp .)
    FLOAT_CONST     reduce using rule 157 (redExp -> NOT eqExp .)
    }               reduce using rule 157 (redExp -> NOT eqExp .)
    ELIF            reduce using rule 157 (redExp -> NOT eqExp .)
    ELSE            reduce using rule 157 (redExp -> NOT eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130
    LAND            reduce using rule 154 (redExp -> eqExp .)
    LOR             reduce using rule 154 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 154 (redExp -> eqExp .)

  ! LAND            [ reduce using rule 157 (redExp -> NOT eqExp .) ]
  ! LOR             [ reduce using rule 157 (redExp -> NOT eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 157 (redExp -> NOT eqExp .) ]


state 136

    (158) redExp -> XOR eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! reduce/reduce conflict for LAND resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 154 (redExp -> eqExp .)
    ]               reduce using rule 158 (redExp -> XOR eqExp .)
    )               reduce using rule 158 (redExp -> XOR eqExp .)
    ;               reduce using rule 158 (redExp -> XOR eqExp .)
    ,               reduce using rule 158 (redExp -> XOR eqExp .)
    COLON           reduce using rule 158 (redExp -> XOR eqExp .)
    RETURN          reduce using rule 158 (redExp -> XOR eqExp .)
    CONST           reduce using rule 158 (redExp -> XOR eqExp .)
    ID              reduce using rule 158 (redExp -> XOR eqExp .)
    {               reduce using rule 158 (redExp -> XOR eqExp .)
    MUX             reduce using rule 158 (redExp -> XOR eqExp .)
    WHEN            reduce using rule 158 (redExp -> XOR eqExp .)
    IF              reduce using rule 158 (redExp -> XOR eqExp .)
    FOR             reduce using rule 158 (redExp -> XOR eqExp .)
    GENERATE        reduce using rule 158 (redExp -> XOR eqExp .)
    INT             reduce using rule 158 (redExp -> XOR eqExp .)
    FLOAT           reduce using rule 158 (redExp -> XOR eqExp .)
    REG             reduce using rule 158 (redExp -> XOR eqExp .)
    WIRE            reduce using rule 158 (redExp -> XOR eqExp .)
    CLOCK           reduce using rule 158 (redExp -> XOR eqExp .)
    AND             reduce using rule 158 (redExp -> XOR eqExp .)
    OR              reduce using rule 158 (redExp -> XOR eqExp .)
    NOT             reduce using rule 158 (redExp -> XOR eqExp .)
    XOR             reduce using rule 158 (redExp -> XOR eqExp .)
    XNOR            reduce using rule 158 (redExp -> XOR eqExp .)
    SIGNAL          reduce using rule 158 (redExp -> XOR eqExp .)
    (               reduce using rule 158 (redExp -> XOR eqExp .)
    ADD             reduce using rule 158 (redExp -> XOR eqExp .)
    SUB             reduce using rule 158 (redExp -> XOR eqExp .)
    NOTL            reduce using rule 158 (redExp -> XOR eqExp .)
    INTEGER_CONST   reduce using rule 158 (redExp -> XOR eqExp .)
    FLOAT_CONST     reduce using rule 158 (redExp -> XOR eqExp .)
    }               reduce using rule 158 (redExp -> XOR eqExp .)
    ELIF            reduce using rule 158 (redExp -> XOR eqExp .)
    ELSE            reduce using rule 158 (redExp -> XOR eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130
    LAND            reduce using rule 154 (redExp -> eqExp .)
    LOR             reduce using rule 154 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 154 (redExp -> eqExp .)

  ! LAND            [ reduce using rule 158 (redExp -> XOR eqExp .) ]
  ! LOR             [ reduce using rule 158 (redExp -> XOR eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 158 (redExp -> XOR eqExp .) ]


state 137

    (159) redExp -> XNOR eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! reduce/reduce conflict for LAND resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 154 (redExp -> eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 154 (redExp -> eqExp .)
    ]               reduce using rule 159 (redExp -> XNOR eqExp .)
    )               reduce using rule 159 (redExp -> XNOR eqExp .)
    ;               reduce using rule 159 (redExp -> XNOR eqExp .)
    ,               reduce using rule 159 (redExp -> XNOR eqExp .)
    COLON           reduce using rule 159 (redExp -> XNOR eqExp .)
    RETURN          reduce using rule 159 (redExp -> XNOR eqExp .)
    CONST           reduce using rule 159 (redExp -> XNOR eqExp .)
    ID              reduce using rule 159 (redExp -> XNOR eqExp .)
    {               reduce using rule 159 (redExp -> XNOR eqExp .)
    MUX             reduce using rule 159 (redExp -> XNOR eqExp .)
    WHEN            reduce using rule 159 (redExp -> XNOR eqExp .)
    IF              reduce using rule 159 (redExp -> XNOR eqExp .)
    FOR             reduce using rule 159 (redExp -> XNOR eqExp .)
    GENERATE        reduce using rule 159 (redExp -> XNOR eqExp .)
    INT             reduce using rule 159 (redExp -> XNOR eqExp .)
    FLOAT           reduce using rule 159 (redExp -> XNOR eqExp .)
    REG             reduce using rule 159 (redExp -> XNOR eqExp .)
    WIRE            reduce using rule 159 (redExp -> XNOR eqExp .)
    CLOCK           reduce using rule 159 (redExp -> XNOR eqExp .)
    AND             reduce using rule 159 (redExp -> XNOR eqExp .)
    OR              reduce using rule 159 (redExp -> XNOR eqExp .)
    NOT             reduce using rule 159 (redExp -> XNOR eqExp .)
    XOR             reduce using rule 159 (redExp -> XNOR eqExp .)
    XNOR            reduce using rule 159 (redExp -> XNOR eqExp .)
    SIGNAL          reduce using rule 159 (redExp -> XNOR eqExp .)
    (               reduce using rule 159 (redExp -> XNOR eqExp .)
    ADD             reduce using rule 159 (redExp -> XNOR eqExp .)
    SUB             reduce using rule 159 (redExp -> XNOR eqExp .)
    NOTL            reduce using rule 159 (redExp -> XNOR eqExp .)
    INTEGER_CONST   reduce using rule 159 (redExp -> XNOR eqExp .)
    FLOAT_CONST     reduce using rule 159 (redExp -> XNOR eqExp .)
    }               reduce using rule 159 (redExp -> XNOR eqExp .)
    ELIF            reduce using rule 159 (redExp -> XNOR eqExp .)
    ELSE            reduce using rule 159 (redExp -> XNOR eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130
    LAND            reduce using rule 154 (redExp -> eqExp .)
    LOR             reduce using rule 154 (redExp -> eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 154 (redExp -> eqExp .)

  ! LAND            [ reduce using rule 159 (redExp -> XNOR eqExp .) ]
  ! LOR             [ reduce using rule 159 (redExp -> XNOR eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 159 (redExp -> XNOR eqExp .) ]


state 138

    (143) relExp -> relExp LT . addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    relExp                         shift and go to state 67
    addExp                         shift and go to state 204
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    shiftExp                       shift and go to state 68

state 139

    (144) relExp -> relExp GT . addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    relExp                         shift and go to state 67
    addExp                         shift and go to state 205
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    shiftExp                       shift and go to state 68

state 140

    (145) relExp -> relExp GE . addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    relExp                         shift and go to state 67
    addExp                         shift and go to state 206
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    shiftExp                       shift and go to state 68

state 141

    (146) relExp -> relExp LE . addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    relExp                         shift and go to state 67
    addExp                         shift and go to state 207
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    shiftExp                       shift and go to state 68

state 142

    (139) shiftExp -> shiftExp SLL . addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 208
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67

state 143

    (140) shiftExp -> shiftExp SRL . addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 209
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67

state 144

    (141) shiftExp -> shiftExp SRA . addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 210
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67

state 145

    (136) addExp -> addExp ADD . mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    addExp                         shift and go to state 69
    mulExp                         shift and go to state 211
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68

state 146

    (137) addExp -> addExp SUB . mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    addExp                         shift and go to state 69
    mulExp                         shift and go to state 212
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68

state 147

    (131) mulExp -> mulExp MUL . unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 213
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69

state 148

    (132) mulExp -> mulExp DIV . unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 214
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69

state 149

    (133) mulExp -> mulExp MOD . unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 215
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69

state 150

    (134) mulExp -> mulExp POWER . unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 216
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69

state 151

    (118) unaryExp -> ID ( . )
    (119) unaryExp -> ID ( . funcRParams )
    (128) funcRParams -> . exp
    (129) funcRParams -> . exp exp_repeat
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    )               shift and go to state 217
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    funcRParams                    shift and go to state 218
    exp                            shift and go to state 219
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 152

    (98) lVal -> ID array_exp_repeat1 .

    .               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    MUL             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    DIV             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    MOD             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    POWER           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ADD             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SUB             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SLL             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SRL             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SRA             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    LT              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    GT              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    GE              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    LE              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    EQUAL           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    NEQ             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    LAND            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    LOR             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ]               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    BIT_WIDTH_NUMBER reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    )               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ;               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ,               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    COLON           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    RETURN          reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    CONST           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ID              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    {               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    MUX             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    WHEN            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    IF              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    FOR             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    GENERATE        reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    INT             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    FLOAT           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    REG             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    WIRE            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    CLOCK           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    AND             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    OR              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    NOT             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    XOR             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    XNOR            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SIGNAL          reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    (               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    NOTL            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    INTEGER_CONST   reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    FLOAT_CONST     reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    }               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ELIF            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ELSE            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ASSIGN          reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    CONNECT         reduce using rule 98 (lVal -> ID array_exp_repeat1 .)


state 153

    (99) lVal -> ID array_exp_repeat2 .

    .               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    MUL             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    DIV             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    MOD             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    POWER           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ADD             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SUB             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SLL             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SRL             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SRA             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    LT              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    GT              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    GE              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    LE              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    EQUAL           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    NEQ             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    LAND            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    LOR             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ]               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    BIT_WIDTH_NUMBER reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    )               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ;               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ,               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    COLON           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    RETURN          reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    CONST           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ID              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    {               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    MUX             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    WHEN            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    IF              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    FOR             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    GENERATE        reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    INT             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    FLOAT           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    REG             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    WIRE            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    CLOCK           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    AND             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    OR              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    NOT             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    XOR             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    XNOR            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SIGNAL          reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    (               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    NOTL            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    INTEGER_CONST   reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    FLOAT_CONST     reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    }               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ELIF            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ELSE            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ASSIGN          reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    CONNECT         reduce using rule 99 (lVal -> ID array_exp_repeat2 .)


state 154

    (109) array_exp_repeat1 -> empty .
    (111) array_exp_repeat2 -> empty .

  ! reduce/reduce conflict for . resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for MUL resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for DIV resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for MOD resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for POWER resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ADD resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SUB resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SLL resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SRL resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SRA resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for LT resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for GT resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for GE resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for LE resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for EQUAL resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for NEQ resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for LAND resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for LOR resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ] resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ) resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ; resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for , resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for COLON resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for CONST resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for { resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for MUX resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for WHEN resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for GENERATE resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for REG resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for WIRE resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for CLOCK resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for AND resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for OR resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for XOR resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for XNOR resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for SIGNAL resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ( resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for NOTL resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for INTEGER_CONST resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for FLOAT_CONST resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for } resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ELIF resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for ASSIGN resolved using rule 109 (array_exp_repeat1 -> empty .)
  ! reduce/reduce conflict for CONNECT resolved using rule 109 (array_exp_repeat1 -> empty .)
    .               reduce using rule 109 (array_exp_repeat1 -> empty .)
    MUL             reduce using rule 109 (array_exp_repeat1 -> empty .)
    DIV             reduce using rule 109 (array_exp_repeat1 -> empty .)
    MOD             reduce using rule 109 (array_exp_repeat1 -> empty .)
    POWER           reduce using rule 109 (array_exp_repeat1 -> empty .)
    ADD             reduce using rule 109 (array_exp_repeat1 -> empty .)
    SUB             reduce using rule 109 (array_exp_repeat1 -> empty .)
    SLL             reduce using rule 109 (array_exp_repeat1 -> empty .)
    SRL             reduce using rule 109 (array_exp_repeat1 -> empty .)
    SRA             reduce using rule 109 (array_exp_repeat1 -> empty .)
    LT              reduce using rule 109 (array_exp_repeat1 -> empty .)
    GT              reduce using rule 109 (array_exp_repeat1 -> empty .)
    GE              reduce using rule 109 (array_exp_repeat1 -> empty .)
    LE              reduce using rule 109 (array_exp_repeat1 -> empty .)
    EQUAL           reduce using rule 109 (array_exp_repeat1 -> empty .)
    NEQ             reduce using rule 109 (array_exp_repeat1 -> empty .)
    LAND            reduce using rule 109 (array_exp_repeat1 -> empty .)
    LOR             reduce using rule 109 (array_exp_repeat1 -> empty .)
    ]               reduce using rule 109 (array_exp_repeat1 -> empty .)
    BIT_WIDTH_NUMBER reduce using rule 109 (array_exp_repeat1 -> empty .)
    )               reduce using rule 109 (array_exp_repeat1 -> empty .)
    ;               reduce using rule 109 (array_exp_repeat1 -> empty .)
    ,               reduce using rule 109 (array_exp_repeat1 -> empty .)
    COLON           reduce using rule 109 (array_exp_repeat1 -> empty .)
    RETURN          reduce using rule 109 (array_exp_repeat1 -> empty .)
    CONST           reduce using rule 109 (array_exp_repeat1 -> empty .)
    ID              reduce using rule 109 (array_exp_repeat1 -> empty .)
    {               reduce using rule 109 (array_exp_repeat1 -> empty .)
    MUX             reduce using rule 109 (array_exp_repeat1 -> empty .)
    WHEN            reduce using rule 109 (array_exp_repeat1 -> empty .)
    IF              reduce using rule 109 (array_exp_repeat1 -> empty .)
    FOR             reduce using rule 109 (array_exp_repeat1 -> empty .)
    GENERATE        reduce using rule 109 (array_exp_repeat1 -> empty .)
    INT             reduce using rule 109 (array_exp_repeat1 -> empty .)
    FLOAT           reduce using rule 109 (array_exp_repeat1 -> empty .)
    REG             reduce using rule 109 (array_exp_repeat1 -> empty .)
    WIRE            reduce using rule 109 (array_exp_repeat1 -> empty .)
    CLOCK           reduce using rule 109 (array_exp_repeat1 -> empty .)
    AND             reduce using rule 109 (array_exp_repeat1 -> empty .)
    OR              reduce using rule 109 (array_exp_repeat1 -> empty .)
    NOT             reduce using rule 109 (array_exp_repeat1 -> empty .)
    XOR             reduce using rule 109 (array_exp_repeat1 -> empty .)
    XNOR            reduce using rule 109 (array_exp_repeat1 -> empty .)
    SIGNAL          reduce using rule 109 (array_exp_repeat1 -> empty .)
    (               reduce using rule 109 (array_exp_repeat1 -> empty .)
    NOTL            reduce using rule 109 (array_exp_repeat1 -> empty .)
    INTEGER_CONST   reduce using rule 109 (array_exp_repeat1 -> empty .)
    FLOAT_CONST     reduce using rule 109 (array_exp_repeat1 -> empty .)
    }               reduce using rule 109 (array_exp_repeat1 -> empty .)
    ELIF            reduce using rule 109 (array_exp_repeat1 -> empty .)
    ELSE            reduce using rule 109 (array_exp_repeat1 -> empty .)
    ASSIGN          reduce using rule 109 (array_exp_repeat1 -> empty .)
    CONNECT         reduce using rule 109 (array_exp_repeat1 -> empty .)

  ! .               [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! MUL             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! DIV             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! MOD             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! POWER           [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! ADD             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! SUB             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! SLL             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! SRL             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! SRA             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! LT              [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! GT              [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! GE              [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! LE              [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! EQUAL           [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! NEQ             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! LAND            [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! LOR             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! ]               [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! )               [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! ;               [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! ,               [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! COLON           [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! RETURN          [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! CONST           [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! ID              [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! {               [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! MUX             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! WHEN            [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! IF              [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! FOR             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! GENERATE        [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! INT             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! FLOAT           [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! REG             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! WIRE            [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! CLOCK           [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! AND             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! OR              [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! NOT             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! XOR             [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! XNOR            [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! SIGNAL          [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! (               [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! NOTL            [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! INTEGER_CONST   [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! FLOAT_CONST     [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! }               [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! ELIF            [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! ELSE            [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! ASSIGN          [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]
  ! CONNECT         [ reduce using rule 111 (array_exp_repeat2 -> empty .) ]


state 155

    (110) array_exp_repeat1 -> [ . exp ] array_exp_repeat1
    (112) array_exp_repeat2 -> [ . exp COLON exp ] array_exp_repeat2
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 220
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 156

    (104) primaryExp -> ( exp . )
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 221
    BIT_WIDTH_NUMBER shift and go to state 122


state 157

    (120) unaryExp -> SIGNAL ( . unaryExp )
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp

    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOT             shift and go to state 133
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85
    AND             shift and go to state 62
    OR              shift and go to state 63
    XOR             shift and go to state 65
    XNOR            shift and go to state 66

    unaryExp                       shift and go to state 222
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    exp                            shift and go to state 132
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70

state 158

    (121) unaryExp -> unaryOp unaryExp .
    (130) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 121 (unaryExp -> unaryOp unaryExp .)
    MUL             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    DIV             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    MOD             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    POWER           reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    ADD             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    SUB             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    SLL             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    SRL             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    SRA             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    LT              reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    GT              reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    GE              reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    LE              reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    EQUAL           reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    NEQ             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    LAND            reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    LOR             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    ]               reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    )               reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    ;               reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    ,               reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    COLON           reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    RETURN          reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    CONST           reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    ID              reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    {               reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    MUX             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    WHEN            reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    IF              reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    FOR             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    GENERATE        reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    INT             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    FLOAT           reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    REG             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    WIRE            reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    CLOCK           reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    AND             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    OR              reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    NOT             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    XOR             reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    XNOR            reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    SIGNAL          reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    (               reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    NOTL            reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    INTEGER_CONST   reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    FLOAT_CONST     reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    }               reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    ELIF            reduce using rule 121 (unaryExp -> unaryOp unaryExp .)
    ELSE            reduce using rule 121 (unaryExp -> unaryOp unaryExp .)

  ! MUL             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! DIV             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! MOD             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! POWER           [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! ADD             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! SUB             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! SLL             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! SRL             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! SRA             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! LT              [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! GT              [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! GE              [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! LE              [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! EQUAL           [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! NEQ             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! LAND            [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! LOR             [ reduce using rule 130 (mulExp -> unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 130 (mulExp -> unaryExp .) ]


state 159

    (103) lVal -> lVal . . ID

    ID              shift and go to state 223


state 160

    (100) lVal -> { ID . array_exp_repeat1 lVal_repeat }
    (101) lVal -> { ID . array_exp_repeat2 lVal_repeat }
    (109) array_exp_repeat1 -> . empty
    (110) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (111) array_exp_repeat2 -> . empty
    (112) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

    [               shift and go to state 155
    ,               reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    array_exp_repeat1              shift and go to state 224
    array_exp_repeat2              shift and go to state 225
    empty                          shift and go to state 154

state 161

    (102) lVal -> MUX ( . exp , exp , exp )
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 226
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 162

    (56) cir_function -> cir_type ID ( cir_funcFParams ) . block
    (76) block -> . { block_repeat }

    {               shift and go to state 228

    block                          shift and go to state 227

state 163

    (60) cir_funcFParams -> cir_funcFParam cir_funcFParams_repeat .

    )               reduce using rule 60 (cir_funcFParams -> cir_funcFParam cir_funcFParams_repeat .)


state 164

    (58) cir_funcFParams_repeat -> empty .

    )               reduce using rule 58 (cir_funcFParams_repeat -> empty .)


state 165

    (59) cir_funcFParams_repeat -> , . cir_funcFParam cir_funcFParams_repeat
    (64) cir_funcFParam -> . type_def ID array
    (24) type_def -> . val_type
    (25) type_def -> . cir_type
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24

    cir_funcFParam                 shift and go to state 229
    type_def                       shift and go to state 90
    val_type                       shift and go to state 91
    cir_type                       shift and go to state 87
    cir_basic_type                 shift and go to state 19

state 166

    (64) cir_funcFParam -> type_def ID . array
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 39
    ,               reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

    array                          shift and go to state 230
    empty                          shift and go to state 38

state 167

    (55) cirDef -> ID array ASSIGN initVal .

    ,               reduce using rule 55 (cirDef -> ID array ASSIGN initVal .)
    ;               reduce using rule 55 (cirDef -> ID array ASSIGN initVal .)


state 168

    (50) initVal -> exp . ;
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 231
    BIT_WIDTH_NUMBER shift and go to state 122


state 169

    (27) array -> [ constExp ] . array
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 39
    ASSIGN          reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

    array                          shift and go to state 232
    empty                          shift and go to state 38

state 170

    (52) cirDecl_repeat -> , cirDef cirDecl_repeat .

    ;               reduce using rule 52 (cirDecl_repeat -> , cirDef cirDecl_repeat .)


state 171

    (38) modDecl -> ID ID ( module_R_params ) .

    MODULE          reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    BUNDLE          reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    CONST           reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    ID              reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    INT             reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    FLOAT           reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    REG             reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    WIRE            reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    CLOCK           reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    $end            reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    ;               reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    RETURN          reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    {               reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    MUX             reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    WHEN            reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    IF              reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    FOR             reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    GENERATE        reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    AND             reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    OR              reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    NOT             reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    XOR             reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    XNOR            reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    SIGNAL          reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    (               reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    ADD             reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    SUB             reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    NOTL            reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    INTEGER_CONST   reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    FLOAT_CONST     reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)
    }               reduce using rule 38 (modDecl -> ID ID ( module_R_params ) .)


state 172

    (45) module_R_params -> p_module_R_params_item module_R_params_repeat .

    )               reduce using rule 45 (module_R_params -> p_module_R_params_item module_R_params_repeat .)


state 173

    (43) module_R_params_repeat -> empty .

    )               reduce using rule 43 (module_R_params_repeat -> empty .)


state 174

    (44) module_R_params_repeat -> , . p_module_R_params_item module_R_params_repeat
    (42) p_module_R_params_item -> . R_port_def ID ( ID )
    (39) R_port_def -> . IN .
    (40) R_port_def -> . OUT .
    (41) R_port_def -> . INOUT .

    IN              shift and go to state 101
    OUT             shift and go to state 102
    INOUT           shift and go to state 103

    p_module_R_params_item         shift and go to state 233
    R_port_def                     shift and go to state 100

state 175

    (42) p_module_R_params_item -> R_port_def ID . ( ID )

    (               shift and go to state 234


state 176

    (39) R_port_def -> IN . .

    ID              reduce using rule 39 (R_port_def -> IN . .)


state 177

    (40) R_port_def -> OUT . .

    ID              reduce using rule 40 (R_port_def -> OUT . .)


state 178

    (41) R_port_def -> INOUT . .

    ID              reduce using rule 41 (R_port_def -> INOUT . .)


state 179

    (47) bundleDecl_repeat -> , bundleDef bundleDecl_repeat .

    MODULE          reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    BUNDLE          reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    CONST           reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    ID              reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    INT             reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    FLOAT           reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    REG             reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    WIRE            reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    CLOCK           reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    $end            reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    ;               reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    RETURN          reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    {               reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    MUX             reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    WHEN            reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    IF              reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    FOR             reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    GENERATE        reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    AND             reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    OR              reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    NOT             reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    XOR             reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    XNOR            reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    SIGNAL          reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    (               reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    ADD             reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    SUB             reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    NOTL            reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    INTEGER_CONST   reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    FLOAT_CONST     reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)
    }               reduce using rule 47 (bundleDecl_repeat -> , bundleDef bundleDecl_repeat .)


state 180

    (65) funcFParam -> val_type ID . array
    (26) array -> . empty
    (27) array -> . [ constExp ] array
    (1) empty -> .

    [               shift and go to state 39
    ,               reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)

    array                          shift and go to state 235
    empty                          shift and go to state 38

state 181

    (57) function -> val_type ID ( funcFParams ) . block
    (76) block -> . { block_repeat }

    {               shift and go to state 228

    block                          shift and go to state 236

state 182

    (63) funcFParams -> funcFParam funcFParams_repeat .

    )               reduce using rule 63 (funcFParams -> funcFParam funcFParams_repeat .)


state 183

    (61) funcFParams_repeat -> empty .

    )               reduce using rule 61 (funcFParams_repeat -> empty .)


state 184

    (62) funcFParams_repeat -> , . funcFParam funcFParams_repeat
    (65) funcFParam -> . val_type ID array
    (22) val_type -> . INT
    (23) val_type -> . FLOAT

    INT             shift and go to state 20
    FLOAT           shift and go to state 21

    funcFParam                     shift and go to state 237
    val_type                       shift and go to state 106

state 185

    (37) varDef -> ID array ASSIGN initVal .

    ,               reduce using rule 37 (varDef -> ID array ASSIGN initVal .)
    ;               reduce using rule 37 (varDef -> ID array ASSIGN initVal .)


state 186

    (34) varDef_repeat -> , varDef varDef_repeat .

    ;               reduce using rule 34 (varDef_repeat -> , varDef varDef_repeat .)


state 187

    (70) module -> MODULE ID ( module_para_para port_def . ID p_module_para_port

    ID              shift and go to state 238


state 188

    (164) port_def -> INPUT .

    ID              reduce using rule 164 (port_def -> INPUT .)


state 189

    (165) port_def -> OUTPUT .

    ID              reduce using rule 165 (port_def -> OUTPUT .)


state 190

    (166) port_def -> INOUT .

    ID              reduce using rule 166 (port_def -> INOUT .)


state 191

    (67) module_para_para -> PARA ID . , module_para_para

    ,               shift and go to state 239


state 192

    (73) bundle -> BUNDLE ID ( cir_type ID . bundle_repeat )
    (71) bundle_repeat -> . empty
    (72) bundle_repeat -> . , cir_type ID bundle bundle_repeat
    (1) empty -> .

    ,               shift and go to state 242
    )               reduce using rule 1 (empty -> .)

    bundle_repeat                  shift and go to state 240
    empty                          shift and go to state 241

state 193

    (16) constDecl -> CONST val_type constDef constDecl_repeat ; .

    MODULE          reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    BUNDLE          reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    CONST           reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    ID              reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    INT             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    FLOAT           reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    REG             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    WIRE            reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    CLOCK           reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    $end            reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    ;               reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    RETURN          reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    {               reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    MUX             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    WHEN            reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    IF              reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    FOR             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    GENERATE        reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    AND             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    OR              reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    NOT             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    XOR             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    XNOR            reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    SIGNAL          reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    (               reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    ADD             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    SUB             reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    NOTL            reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    INTEGER_CONST   reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    FLOAT_CONST     reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)
    }               reduce using rule 16 (constDecl -> CONST val_type constDef constDecl_repeat ; .)


state 194

    (15) constDecl_repeat -> , constDef . constDecl_repeat
    (14) constDecl_repeat -> . empty
    (15) constDecl_repeat -> . , constDef constDecl_repeat
    (1) empty -> .

    ,               shift and go to state 119
    ;               reduce using rule 1 (empty -> .)

    constDecl_repeat               shift and go to state 243
    empty                          shift and go to state 118

state 195

    (28) constDef -> ID array ASSIGN . constInitVal
    (31) constInitVal -> . constExp
    (32) constInitVal -> . { constInitVal constInitVal_repeat }
    (167) constExp -> . exp
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    {               shift and go to state 246
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    constInitVal                   shift and go to state 244
    constExp                       shift and go to state 245
    exp                            shift and go to state 94
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 196

    (163) lOrExp -> lOrExp LOR lAndExp .
    (161) lAndExp -> lAndExp . LAND redExp
    (162) lOrExp -> lAndExp .

  ! reduce/reduce conflict for LOR resolved using rule 162 (lOrExp -> lAndExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 162 (lOrExp -> lAndExp .)
    ]               reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    )               reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    ;               reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    ,               reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    COLON           reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    RETURN          reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    CONST           reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    ID              reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    {               reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    MUX             reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    WHEN            reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    IF              reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    FOR             reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    GENERATE        reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    INT             reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    FLOAT           reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    REG             reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    WIRE            reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    CLOCK           reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    AND             reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    OR              reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    NOT             reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    XOR             reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    XNOR            reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    SIGNAL          reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    (               reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    ADD             reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    SUB             reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    NOTL            reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    INTEGER_CONST   reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    FLOAT_CONST     reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    }               reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    ELIF            reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    ELSE            reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .)
    LAND            shift and go to state 124
    LOR             reduce using rule 162 (lOrExp -> lAndExp .)
    BIT_WIDTH_NUMBER reduce using rule 162 (lOrExp -> lAndExp .)

  ! LOR             [ reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 163 (lOrExp -> lOrExp LOR lAndExp .) ]


state 197

    (161) lAndExp -> lAndExp LAND redExp .
    (160) lAndExp -> redExp .

  ! reduce/reduce conflict for LAND resolved using rule 160 (lAndExp -> redExp .)
  ! reduce/reduce conflict for LOR resolved using rule 160 (lAndExp -> redExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 160 (lAndExp -> redExp .)
    ]               reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    )               reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    ;               reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    ,               reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    COLON           reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    RETURN          reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    CONST           reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    ID              reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    {               reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    MUX             reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    WHEN            reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    IF              reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    FOR             reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    GENERATE        reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    INT             reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    FLOAT           reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    REG             reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    WIRE            reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    CLOCK           reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    AND             reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    OR              reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    NOT             reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    XOR             reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    XNOR            reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    SIGNAL          reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    (               reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    ADD             reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    SUB             reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    NOTL            reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    INTEGER_CONST   reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    FLOAT_CONST     reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    }               reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    ELIF            reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    ELSE            reduce using rule 161 (lAndExp -> lAndExp LAND redExp .)
    LAND            reduce using rule 160 (lAndExp -> redExp .)
    LOR             reduce using rule 160 (lAndExp -> redExp .)
    BIT_WIDTH_NUMBER reduce using rule 160 (lAndExp -> redExp .)

  ! LAND            [ reduce using rule 161 (lAndExp -> lAndExp LAND redExp .) ]
  ! LOR             [ reduce using rule 161 (lAndExp -> lAndExp LAND redExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 161 (lAndExp -> lAndExp LAND redExp .) ]


state 198

    (148) eqExp -> eqExp LT eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! reduce/reduce conflict for LAND resolved using rule 148 (eqExp -> eqExp LT eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 148 (eqExp -> eqExp LT eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 148 (eqExp -> eqExp LT eqExp .)
    LAND            reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    LOR             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    ]               reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    )               reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    ;               reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    ,               reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    COLON           reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    RETURN          reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    CONST           reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    ID              reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    {               reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    MUX             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    WHEN            reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    IF              reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    FOR             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    GENERATE        reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    INT             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    FLOAT           reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    REG             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    WIRE            reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    CLOCK           reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    AND             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    OR              reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    NOT             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    XOR             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    XNOR            reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    SIGNAL          reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    (               reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    ADD             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    SUB             reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    NOTL            reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    INTEGER_CONST   reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    FLOAT_CONST     reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    }               reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    ELIF            reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    ELSE            reduce using rule 148 (eqExp -> eqExp LT eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130

  ! LT              [ reduce using rule 148 (eqExp -> eqExp LT eqExp .) ]
  ! GT              [ reduce using rule 148 (eqExp -> eqExp LT eqExp .) ]
  ! GE              [ reduce using rule 148 (eqExp -> eqExp LT eqExp .) ]
  ! LE              [ reduce using rule 148 (eqExp -> eqExp LT eqExp .) ]
  ! EQUAL           [ reduce using rule 148 (eqExp -> eqExp LT eqExp .) ]
  ! NEQ             [ reduce using rule 148 (eqExp -> eqExp LT eqExp .) ]
  ! LAND            [ reduce using rule 154 (redExp -> eqExp .) ]
  ! LOR             [ reduce using rule 154 (redExp -> eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 154 (redExp -> eqExp .) ]


state 199

    (149) eqExp -> eqExp GT eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! reduce/reduce conflict for LAND resolved using rule 149 (eqExp -> eqExp GT eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 149 (eqExp -> eqExp GT eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 149 (eqExp -> eqExp GT eqExp .)
    LAND            reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    LOR             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    ]               reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    )               reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    ;               reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    ,               reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    COLON           reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    RETURN          reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    CONST           reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    ID              reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    {               reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    MUX             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    WHEN            reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    IF              reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    FOR             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    GENERATE        reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    INT             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    FLOAT           reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    REG             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    WIRE            reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    CLOCK           reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    AND             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    OR              reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    NOT             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    XOR             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    XNOR            reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    SIGNAL          reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    (               reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    ADD             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    SUB             reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    NOTL            reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    INTEGER_CONST   reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    FLOAT_CONST     reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    }               reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    ELIF            reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    ELSE            reduce using rule 149 (eqExp -> eqExp GT eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130

  ! LT              [ reduce using rule 149 (eqExp -> eqExp GT eqExp .) ]
  ! GT              [ reduce using rule 149 (eqExp -> eqExp GT eqExp .) ]
  ! GE              [ reduce using rule 149 (eqExp -> eqExp GT eqExp .) ]
  ! LE              [ reduce using rule 149 (eqExp -> eqExp GT eqExp .) ]
  ! EQUAL           [ reduce using rule 149 (eqExp -> eqExp GT eqExp .) ]
  ! NEQ             [ reduce using rule 149 (eqExp -> eqExp GT eqExp .) ]
  ! LAND            [ reduce using rule 154 (redExp -> eqExp .) ]
  ! LOR             [ reduce using rule 154 (redExp -> eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 154 (redExp -> eqExp .) ]


state 200

    (150) eqExp -> eqExp GE eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! reduce/reduce conflict for LAND resolved using rule 150 (eqExp -> eqExp GE eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 150 (eqExp -> eqExp GE eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 150 (eqExp -> eqExp GE eqExp .)
    LAND            reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    LOR             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    ]               reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    )               reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    ;               reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    ,               reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    COLON           reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    RETURN          reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    CONST           reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    ID              reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    {               reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    MUX             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    WHEN            reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    IF              reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    FOR             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    GENERATE        reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    INT             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    FLOAT           reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    REG             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    WIRE            reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    CLOCK           reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    AND             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    OR              reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    NOT             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    XOR             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    XNOR            reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    SIGNAL          reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    (               reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    ADD             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    SUB             reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    NOTL            reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    INTEGER_CONST   reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    FLOAT_CONST     reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    }               reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    ELIF            reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    ELSE            reduce using rule 150 (eqExp -> eqExp GE eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130

  ! LT              [ reduce using rule 150 (eqExp -> eqExp GE eqExp .) ]
  ! GT              [ reduce using rule 150 (eqExp -> eqExp GE eqExp .) ]
  ! GE              [ reduce using rule 150 (eqExp -> eqExp GE eqExp .) ]
  ! LE              [ reduce using rule 150 (eqExp -> eqExp GE eqExp .) ]
  ! EQUAL           [ reduce using rule 150 (eqExp -> eqExp GE eqExp .) ]
  ! NEQ             [ reduce using rule 150 (eqExp -> eqExp GE eqExp .) ]
  ! LAND            [ reduce using rule 154 (redExp -> eqExp .) ]
  ! LOR             [ reduce using rule 154 (redExp -> eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 154 (redExp -> eqExp .) ]


state 201

    (151) eqExp -> eqExp LE eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! reduce/reduce conflict for LAND resolved using rule 151 (eqExp -> eqExp LE eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 151 (eqExp -> eqExp LE eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 151 (eqExp -> eqExp LE eqExp .)
    LAND            reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    LOR             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    ]               reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    )               reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    ;               reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    ,               reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    COLON           reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    RETURN          reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    CONST           reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    ID              reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    {               reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    MUX             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    WHEN            reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    IF              reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    FOR             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    GENERATE        reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    INT             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    FLOAT           reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    REG             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    WIRE            reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    CLOCK           reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    AND             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    OR              reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    NOT             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    XOR             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    XNOR            reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    SIGNAL          reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    (               reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    ADD             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    SUB             reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    NOTL            reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    INTEGER_CONST   reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    FLOAT_CONST     reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    }               reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    ELIF            reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    ELSE            reduce using rule 151 (eqExp -> eqExp LE eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130

  ! LT              [ reduce using rule 151 (eqExp -> eqExp LE eqExp .) ]
  ! GT              [ reduce using rule 151 (eqExp -> eqExp LE eqExp .) ]
  ! GE              [ reduce using rule 151 (eqExp -> eqExp LE eqExp .) ]
  ! LE              [ reduce using rule 151 (eqExp -> eqExp LE eqExp .) ]
  ! EQUAL           [ reduce using rule 151 (eqExp -> eqExp LE eqExp .) ]
  ! NEQ             [ reduce using rule 151 (eqExp -> eqExp LE eqExp .) ]
  ! LAND            [ reduce using rule 154 (redExp -> eqExp .) ]
  ! LOR             [ reduce using rule 154 (redExp -> eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 154 (redExp -> eqExp .) ]


state 202

    (152) eqExp -> eqExp EQUAL eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! reduce/reduce conflict for LAND resolved using rule 152 (eqExp -> eqExp EQUAL eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 152 (eqExp -> eqExp EQUAL eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    LAND            reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    LOR             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    ]               reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    )               reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    ;               reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    ,               reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    COLON           reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    RETURN          reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    CONST           reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    ID              reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    {               reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    MUX             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    WHEN            reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    IF              reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    FOR             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    GENERATE        reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    INT             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    FLOAT           reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    REG             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    WIRE            reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    CLOCK           reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    AND             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    OR              reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    NOT             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    XOR             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    XNOR            reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    SIGNAL          reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    (               reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    ADD             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    SUB             reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    NOTL            reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    INTEGER_CONST   reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    FLOAT_CONST     reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    }               reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    ELIF            reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    ELSE            reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130

  ! LT              [ reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .) ]
  ! GT              [ reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .) ]
  ! GE              [ reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .) ]
  ! LE              [ reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .) ]
  ! EQUAL           [ reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .) ]
  ! NEQ             [ reduce using rule 152 (eqExp -> eqExp EQUAL eqExp .) ]
  ! LAND            [ reduce using rule 154 (redExp -> eqExp .) ]
  ! LOR             [ reduce using rule 154 (redExp -> eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 154 (redExp -> eqExp .) ]


state 203

    (153) eqExp -> eqExp NEQ eqExp .
    (148) eqExp -> eqExp . LT eqExp
    (149) eqExp -> eqExp . GT eqExp
    (150) eqExp -> eqExp . GE eqExp
    (151) eqExp -> eqExp . LE eqExp
    (152) eqExp -> eqExp . EQUAL eqExp
    (153) eqExp -> eqExp . NEQ eqExp
    (154) redExp -> eqExp .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! reduce/reduce conflict for LAND resolved using rule 153 (eqExp -> eqExp NEQ eqExp .)
  ! reduce/reduce conflict for LOR resolved using rule 153 (eqExp -> eqExp NEQ eqExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 153 (eqExp -> eqExp NEQ eqExp .)
    LAND            reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    LOR             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    ]               reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    BIT_WIDTH_NUMBER reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    )               reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    ;               reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    ,               reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    COLON           reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    RETURN          reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    CONST           reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    ID              reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    {               reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    MUX             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    WHEN            reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    IF              reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    FOR             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    GENERATE        reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    INT             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    FLOAT           reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    REG             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    WIRE            reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    CLOCK           reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    AND             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    OR              reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    NOT             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    XOR             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    XNOR            reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    SIGNAL          reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    (               reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    ADD             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    SUB             reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    NOTL            reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    INTEGER_CONST   reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    FLOAT_CONST     reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    }               reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    ELIF            reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    ELSE            reduce using rule 153 (eqExp -> eqExp NEQ eqExp .)
    LT              shift and go to state 125
    GT              shift and go to state 126
    GE              shift and go to state 127
    LE              shift and go to state 128
    EQUAL           shift and go to state 129
    NEQ             shift and go to state 130

  ! LT              [ reduce using rule 153 (eqExp -> eqExp NEQ eqExp .) ]
  ! GT              [ reduce using rule 153 (eqExp -> eqExp NEQ eqExp .) ]
  ! GE              [ reduce using rule 153 (eqExp -> eqExp NEQ eqExp .) ]
  ! LE              [ reduce using rule 153 (eqExp -> eqExp NEQ eqExp .) ]
  ! EQUAL           [ reduce using rule 153 (eqExp -> eqExp NEQ eqExp .) ]
  ! NEQ             [ reduce using rule 153 (eqExp -> eqExp NEQ eqExp .) ]
  ! LAND            [ reduce using rule 154 (redExp -> eqExp .) ]
  ! LOR             [ reduce using rule 154 (redExp -> eqExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 154 (redExp -> eqExp .) ]


state 204

    (143) relExp -> relExp LT addExp .
    (136) addExp -> addExp . ADD mulExp
    (137) addExp -> addExp . SUB mulExp
    (138) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 138 (shiftExp -> addExp .)
    ]               reduce using rule 143 (relExp -> relExp LT addExp .)
    )               reduce using rule 143 (relExp -> relExp LT addExp .)
    ;               reduce using rule 143 (relExp -> relExp LT addExp .)
    ,               reduce using rule 143 (relExp -> relExp LT addExp .)
    COLON           reduce using rule 143 (relExp -> relExp LT addExp .)
    RETURN          reduce using rule 143 (relExp -> relExp LT addExp .)
    CONST           reduce using rule 143 (relExp -> relExp LT addExp .)
    ID              reduce using rule 143 (relExp -> relExp LT addExp .)
    {               reduce using rule 143 (relExp -> relExp LT addExp .)
    MUX             reduce using rule 143 (relExp -> relExp LT addExp .)
    WHEN            reduce using rule 143 (relExp -> relExp LT addExp .)
    IF              reduce using rule 143 (relExp -> relExp LT addExp .)
    FOR             reduce using rule 143 (relExp -> relExp LT addExp .)
    GENERATE        reduce using rule 143 (relExp -> relExp LT addExp .)
    INT             reduce using rule 143 (relExp -> relExp LT addExp .)
    FLOAT           reduce using rule 143 (relExp -> relExp LT addExp .)
    REG             reduce using rule 143 (relExp -> relExp LT addExp .)
    WIRE            reduce using rule 143 (relExp -> relExp LT addExp .)
    CLOCK           reduce using rule 143 (relExp -> relExp LT addExp .)
    AND             reduce using rule 143 (relExp -> relExp LT addExp .)
    OR              reduce using rule 143 (relExp -> relExp LT addExp .)
    NOT             reduce using rule 143 (relExp -> relExp LT addExp .)
    XOR             reduce using rule 143 (relExp -> relExp LT addExp .)
    XNOR            reduce using rule 143 (relExp -> relExp LT addExp .)
    SIGNAL          reduce using rule 143 (relExp -> relExp LT addExp .)
    (               reduce using rule 143 (relExp -> relExp LT addExp .)
    NOTL            reduce using rule 143 (relExp -> relExp LT addExp .)
    INTEGER_CONST   reduce using rule 143 (relExp -> relExp LT addExp .)
    FLOAT_CONST     reduce using rule 143 (relExp -> relExp LT addExp .)
    }               reduce using rule 143 (relExp -> relExp LT addExp .)
    ELIF            reduce using rule 143 (relExp -> relExp LT addExp .)
    ELSE            reduce using rule 143 (relExp -> relExp LT addExp .)
    ADD             shift and go to state 145
    SUB             shift and go to state 146
    SLL             reduce using rule 138 (shiftExp -> addExp .)
    SRL             reduce using rule 138 (shiftExp -> addExp .)
    SRA             reduce using rule 138 (shiftExp -> addExp .)
    LT              reduce using rule 138 (shiftExp -> addExp .)
    GT              reduce using rule 138 (shiftExp -> addExp .)
    GE              reduce using rule 138 (shiftExp -> addExp .)
    LE              reduce using rule 138 (shiftExp -> addExp .)
    EQUAL           reduce using rule 138 (shiftExp -> addExp .)
    NEQ             reduce using rule 138 (shiftExp -> addExp .)
    LAND            reduce using rule 138 (shiftExp -> addExp .)
    LOR             reduce using rule 138 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 138 (shiftExp -> addExp .)

  ! LT              [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! GT              [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! GE              [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! LE              [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! EQUAL           [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! NEQ             [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! LAND            [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! LOR             [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! ADD             [ reduce using rule 143 (relExp -> relExp LT addExp .) ]
  ! SUB             [ reduce using rule 143 (relExp -> relExp LT addExp .) ]


state 205

    (144) relExp -> relExp GT addExp .
    (136) addExp -> addExp . ADD mulExp
    (137) addExp -> addExp . SUB mulExp
    (138) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 138 (shiftExp -> addExp .)
    ]               reduce using rule 144 (relExp -> relExp GT addExp .)
    )               reduce using rule 144 (relExp -> relExp GT addExp .)
    ;               reduce using rule 144 (relExp -> relExp GT addExp .)
    ,               reduce using rule 144 (relExp -> relExp GT addExp .)
    COLON           reduce using rule 144 (relExp -> relExp GT addExp .)
    RETURN          reduce using rule 144 (relExp -> relExp GT addExp .)
    CONST           reduce using rule 144 (relExp -> relExp GT addExp .)
    ID              reduce using rule 144 (relExp -> relExp GT addExp .)
    {               reduce using rule 144 (relExp -> relExp GT addExp .)
    MUX             reduce using rule 144 (relExp -> relExp GT addExp .)
    WHEN            reduce using rule 144 (relExp -> relExp GT addExp .)
    IF              reduce using rule 144 (relExp -> relExp GT addExp .)
    FOR             reduce using rule 144 (relExp -> relExp GT addExp .)
    GENERATE        reduce using rule 144 (relExp -> relExp GT addExp .)
    INT             reduce using rule 144 (relExp -> relExp GT addExp .)
    FLOAT           reduce using rule 144 (relExp -> relExp GT addExp .)
    REG             reduce using rule 144 (relExp -> relExp GT addExp .)
    WIRE            reduce using rule 144 (relExp -> relExp GT addExp .)
    CLOCK           reduce using rule 144 (relExp -> relExp GT addExp .)
    AND             reduce using rule 144 (relExp -> relExp GT addExp .)
    OR              reduce using rule 144 (relExp -> relExp GT addExp .)
    NOT             reduce using rule 144 (relExp -> relExp GT addExp .)
    XOR             reduce using rule 144 (relExp -> relExp GT addExp .)
    XNOR            reduce using rule 144 (relExp -> relExp GT addExp .)
    SIGNAL          reduce using rule 144 (relExp -> relExp GT addExp .)
    (               reduce using rule 144 (relExp -> relExp GT addExp .)
    NOTL            reduce using rule 144 (relExp -> relExp GT addExp .)
    INTEGER_CONST   reduce using rule 144 (relExp -> relExp GT addExp .)
    FLOAT_CONST     reduce using rule 144 (relExp -> relExp GT addExp .)
    }               reduce using rule 144 (relExp -> relExp GT addExp .)
    ELIF            reduce using rule 144 (relExp -> relExp GT addExp .)
    ELSE            reduce using rule 144 (relExp -> relExp GT addExp .)
    ADD             shift and go to state 145
    SUB             shift and go to state 146
    SLL             reduce using rule 138 (shiftExp -> addExp .)
    SRL             reduce using rule 138 (shiftExp -> addExp .)
    SRA             reduce using rule 138 (shiftExp -> addExp .)
    LT              reduce using rule 138 (shiftExp -> addExp .)
    GT              reduce using rule 138 (shiftExp -> addExp .)
    GE              reduce using rule 138 (shiftExp -> addExp .)
    LE              reduce using rule 138 (shiftExp -> addExp .)
    EQUAL           reduce using rule 138 (shiftExp -> addExp .)
    NEQ             reduce using rule 138 (shiftExp -> addExp .)
    LAND            reduce using rule 138 (shiftExp -> addExp .)
    LOR             reduce using rule 138 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 138 (shiftExp -> addExp .)

  ! LT              [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! GT              [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! GE              [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! LE              [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! EQUAL           [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! NEQ             [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! LAND            [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! LOR             [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! ADD             [ reduce using rule 144 (relExp -> relExp GT addExp .) ]
  ! SUB             [ reduce using rule 144 (relExp -> relExp GT addExp .) ]


state 206

    (145) relExp -> relExp GE addExp .
    (136) addExp -> addExp . ADD mulExp
    (137) addExp -> addExp . SUB mulExp
    (138) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 138 (shiftExp -> addExp .)
    ]               reduce using rule 145 (relExp -> relExp GE addExp .)
    )               reduce using rule 145 (relExp -> relExp GE addExp .)
    ;               reduce using rule 145 (relExp -> relExp GE addExp .)
    ,               reduce using rule 145 (relExp -> relExp GE addExp .)
    COLON           reduce using rule 145 (relExp -> relExp GE addExp .)
    RETURN          reduce using rule 145 (relExp -> relExp GE addExp .)
    CONST           reduce using rule 145 (relExp -> relExp GE addExp .)
    ID              reduce using rule 145 (relExp -> relExp GE addExp .)
    {               reduce using rule 145 (relExp -> relExp GE addExp .)
    MUX             reduce using rule 145 (relExp -> relExp GE addExp .)
    WHEN            reduce using rule 145 (relExp -> relExp GE addExp .)
    IF              reduce using rule 145 (relExp -> relExp GE addExp .)
    FOR             reduce using rule 145 (relExp -> relExp GE addExp .)
    GENERATE        reduce using rule 145 (relExp -> relExp GE addExp .)
    INT             reduce using rule 145 (relExp -> relExp GE addExp .)
    FLOAT           reduce using rule 145 (relExp -> relExp GE addExp .)
    REG             reduce using rule 145 (relExp -> relExp GE addExp .)
    WIRE            reduce using rule 145 (relExp -> relExp GE addExp .)
    CLOCK           reduce using rule 145 (relExp -> relExp GE addExp .)
    AND             reduce using rule 145 (relExp -> relExp GE addExp .)
    OR              reduce using rule 145 (relExp -> relExp GE addExp .)
    NOT             reduce using rule 145 (relExp -> relExp GE addExp .)
    XOR             reduce using rule 145 (relExp -> relExp GE addExp .)
    XNOR            reduce using rule 145 (relExp -> relExp GE addExp .)
    SIGNAL          reduce using rule 145 (relExp -> relExp GE addExp .)
    (               reduce using rule 145 (relExp -> relExp GE addExp .)
    NOTL            reduce using rule 145 (relExp -> relExp GE addExp .)
    INTEGER_CONST   reduce using rule 145 (relExp -> relExp GE addExp .)
    FLOAT_CONST     reduce using rule 145 (relExp -> relExp GE addExp .)
    }               reduce using rule 145 (relExp -> relExp GE addExp .)
    ELIF            reduce using rule 145 (relExp -> relExp GE addExp .)
    ELSE            reduce using rule 145 (relExp -> relExp GE addExp .)
    ADD             shift and go to state 145
    SUB             shift and go to state 146
    SLL             reduce using rule 138 (shiftExp -> addExp .)
    SRL             reduce using rule 138 (shiftExp -> addExp .)
    SRA             reduce using rule 138 (shiftExp -> addExp .)
    LT              reduce using rule 138 (shiftExp -> addExp .)
    GT              reduce using rule 138 (shiftExp -> addExp .)
    GE              reduce using rule 138 (shiftExp -> addExp .)
    LE              reduce using rule 138 (shiftExp -> addExp .)
    EQUAL           reduce using rule 138 (shiftExp -> addExp .)
    NEQ             reduce using rule 138 (shiftExp -> addExp .)
    LAND            reduce using rule 138 (shiftExp -> addExp .)
    LOR             reduce using rule 138 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 138 (shiftExp -> addExp .)

  ! LT              [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! GT              [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! GE              [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! LE              [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! EQUAL           [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! NEQ             [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! LAND            [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! LOR             [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! ADD             [ reduce using rule 145 (relExp -> relExp GE addExp .) ]
  ! SUB             [ reduce using rule 145 (relExp -> relExp GE addExp .) ]


state 207

    (146) relExp -> relExp LE addExp .
    (136) addExp -> addExp . ADD mulExp
    (137) addExp -> addExp . SUB mulExp
    (138) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for LT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 138 (shiftExp -> addExp .)
    ]               reduce using rule 146 (relExp -> relExp LE addExp .)
    )               reduce using rule 146 (relExp -> relExp LE addExp .)
    ;               reduce using rule 146 (relExp -> relExp LE addExp .)
    ,               reduce using rule 146 (relExp -> relExp LE addExp .)
    COLON           reduce using rule 146 (relExp -> relExp LE addExp .)
    RETURN          reduce using rule 146 (relExp -> relExp LE addExp .)
    CONST           reduce using rule 146 (relExp -> relExp LE addExp .)
    ID              reduce using rule 146 (relExp -> relExp LE addExp .)
    {               reduce using rule 146 (relExp -> relExp LE addExp .)
    MUX             reduce using rule 146 (relExp -> relExp LE addExp .)
    WHEN            reduce using rule 146 (relExp -> relExp LE addExp .)
    IF              reduce using rule 146 (relExp -> relExp LE addExp .)
    FOR             reduce using rule 146 (relExp -> relExp LE addExp .)
    GENERATE        reduce using rule 146 (relExp -> relExp LE addExp .)
    INT             reduce using rule 146 (relExp -> relExp LE addExp .)
    FLOAT           reduce using rule 146 (relExp -> relExp LE addExp .)
    REG             reduce using rule 146 (relExp -> relExp LE addExp .)
    WIRE            reduce using rule 146 (relExp -> relExp LE addExp .)
    CLOCK           reduce using rule 146 (relExp -> relExp LE addExp .)
    AND             reduce using rule 146 (relExp -> relExp LE addExp .)
    OR              reduce using rule 146 (relExp -> relExp LE addExp .)
    NOT             reduce using rule 146 (relExp -> relExp LE addExp .)
    XOR             reduce using rule 146 (relExp -> relExp LE addExp .)
    XNOR            reduce using rule 146 (relExp -> relExp LE addExp .)
    SIGNAL          reduce using rule 146 (relExp -> relExp LE addExp .)
    (               reduce using rule 146 (relExp -> relExp LE addExp .)
    NOTL            reduce using rule 146 (relExp -> relExp LE addExp .)
    INTEGER_CONST   reduce using rule 146 (relExp -> relExp LE addExp .)
    FLOAT_CONST     reduce using rule 146 (relExp -> relExp LE addExp .)
    }               reduce using rule 146 (relExp -> relExp LE addExp .)
    ELIF            reduce using rule 146 (relExp -> relExp LE addExp .)
    ELSE            reduce using rule 146 (relExp -> relExp LE addExp .)
    ADD             shift and go to state 145
    SUB             shift and go to state 146
    SLL             reduce using rule 138 (shiftExp -> addExp .)
    SRL             reduce using rule 138 (shiftExp -> addExp .)
    SRA             reduce using rule 138 (shiftExp -> addExp .)
    LT              reduce using rule 138 (shiftExp -> addExp .)
    GT              reduce using rule 138 (shiftExp -> addExp .)
    GE              reduce using rule 138 (shiftExp -> addExp .)
    LE              reduce using rule 138 (shiftExp -> addExp .)
    EQUAL           reduce using rule 138 (shiftExp -> addExp .)
    NEQ             reduce using rule 138 (shiftExp -> addExp .)
    LAND            reduce using rule 138 (shiftExp -> addExp .)
    LOR             reduce using rule 138 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 138 (shiftExp -> addExp .)

  ! LT              [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! GT              [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! GE              [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! LE              [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! EQUAL           [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! NEQ             [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! LAND            [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! LOR             [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! ADD             [ reduce using rule 146 (relExp -> relExp LE addExp .) ]
  ! SUB             [ reduce using rule 146 (relExp -> relExp LE addExp .) ]


state 208

    (139) shiftExp -> shiftExp SLL addExp .
    (136) addExp -> addExp . ADD mulExp
    (137) addExp -> addExp . SUB mulExp
    (138) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for SLL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRA resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 138 (shiftExp -> addExp .)
    ]               reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    )               reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    ;               reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    ,               reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    COLON           reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    RETURN          reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    CONST           reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    ID              reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    {               reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    MUX             reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    WHEN            reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    IF              reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    FOR             reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    GENERATE        reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    INT             reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    FLOAT           reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    REG             reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    WIRE            reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    CLOCK           reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    AND             reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    OR              reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    NOT             reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    XOR             reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    XNOR            reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    SIGNAL          reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    (               reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    NOTL            reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    INTEGER_CONST   reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    FLOAT_CONST     reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    }               reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    ELIF            reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    ELSE            reduce using rule 139 (shiftExp -> shiftExp SLL addExp .)
    ADD             shift and go to state 145
    SUB             shift and go to state 146
    SLL             reduce using rule 138 (shiftExp -> addExp .)
    SRL             reduce using rule 138 (shiftExp -> addExp .)
    SRA             reduce using rule 138 (shiftExp -> addExp .)
    LT              reduce using rule 138 (shiftExp -> addExp .)
    GT              reduce using rule 138 (shiftExp -> addExp .)
    GE              reduce using rule 138 (shiftExp -> addExp .)
    LE              reduce using rule 138 (shiftExp -> addExp .)
    EQUAL           reduce using rule 138 (shiftExp -> addExp .)
    NEQ             reduce using rule 138 (shiftExp -> addExp .)
    LAND            reduce using rule 138 (shiftExp -> addExp .)
    LOR             reduce using rule 138 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 138 (shiftExp -> addExp .)

  ! SLL             [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! SRL             [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! SRA             [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! LT              [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! GT              [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! GE              [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! LE              [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! EQUAL           [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! NEQ             [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! LAND            [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! LOR             [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! ADD             [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]
  ! SUB             [ reduce using rule 139 (shiftExp -> shiftExp SLL addExp .) ]


state 209

    (140) shiftExp -> shiftExp SRL addExp .
    (136) addExp -> addExp . ADD mulExp
    (137) addExp -> addExp . SUB mulExp
    (138) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for SLL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRA resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 138 (shiftExp -> addExp .)
    ]               reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    )               reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    ;               reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    ,               reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    COLON           reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    RETURN          reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    CONST           reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    ID              reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    {               reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    MUX             reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    WHEN            reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    IF              reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    FOR             reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    GENERATE        reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    INT             reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    FLOAT           reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    REG             reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    WIRE            reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    CLOCK           reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    AND             reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    OR              reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    NOT             reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    XOR             reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    XNOR            reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    SIGNAL          reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    (               reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    NOTL            reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    INTEGER_CONST   reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    FLOAT_CONST     reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    }               reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    ELIF            reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    ELSE            reduce using rule 140 (shiftExp -> shiftExp SRL addExp .)
    ADD             shift and go to state 145
    SUB             shift and go to state 146
    SLL             reduce using rule 138 (shiftExp -> addExp .)
    SRL             reduce using rule 138 (shiftExp -> addExp .)
    SRA             reduce using rule 138 (shiftExp -> addExp .)
    LT              reduce using rule 138 (shiftExp -> addExp .)
    GT              reduce using rule 138 (shiftExp -> addExp .)
    GE              reduce using rule 138 (shiftExp -> addExp .)
    LE              reduce using rule 138 (shiftExp -> addExp .)
    EQUAL           reduce using rule 138 (shiftExp -> addExp .)
    NEQ             reduce using rule 138 (shiftExp -> addExp .)
    LAND            reduce using rule 138 (shiftExp -> addExp .)
    LOR             reduce using rule 138 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 138 (shiftExp -> addExp .)

  ! SLL             [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! SRL             [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! SRA             [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! LT              [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! GT              [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! GE              [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! LE              [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! EQUAL           [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! NEQ             [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! LAND            [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! LOR             [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! ADD             [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]
  ! SUB             [ reduce using rule 140 (shiftExp -> shiftExp SRL addExp .) ]


state 210

    (141) shiftExp -> shiftExp SRA addExp .
    (136) addExp -> addExp . ADD mulExp
    (137) addExp -> addExp . SUB mulExp
    (138) shiftExp -> addExp .

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! reduce/reduce conflict for SLL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for SRA resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GT resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for GE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LE resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LAND resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for LOR resolved using rule 138 (shiftExp -> addExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 138 (shiftExp -> addExp .)
    ]               reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    )               reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    ;               reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    ,               reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    COLON           reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    RETURN          reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    CONST           reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    ID              reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    {               reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    MUX             reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    WHEN            reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    IF              reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    FOR             reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    GENERATE        reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    INT             reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    FLOAT           reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    REG             reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    WIRE            reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    CLOCK           reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    AND             reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    OR              reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    NOT             reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    XOR             reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    XNOR            reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    SIGNAL          reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    (               reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    NOTL            reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    INTEGER_CONST   reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    FLOAT_CONST     reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    }               reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    ELIF            reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    ELSE            reduce using rule 141 (shiftExp -> shiftExp SRA addExp .)
    ADD             shift and go to state 145
    SUB             shift and go to state 146
    SLL             reduce using rule 138 (shiftExp -> addExp .)
    SRL             reduce using rule 138 (shiftExp -> addExp .)
    SRA             reduce using rule 138 (shiftExp -> addExp .)
    LT              reduce using rule 138 (shiftExp -> addExp .)
    GT              reduce using rule 138 (shiftExp -> addExp .)
    GE              reduce using rule 138 (shiftExp -> addExp .)
    LE              reduce using rule 138 (shiftExp -> addExp .)
    EQUAL           reduce using rule 138 (shiftExp -> addExp .)
    NEQ             reduce using rule 138 (shiftExp -> addExp .)
    LAND            reduce using rule 138 (shiftExp -> addExp .)
    LOR             reduce using rule 138 (shiftExp -> addExp .)
    BIT_WIDTH_NUMBER reduce using rule 138 (shiftExp -> addExp .)

  ! SLL             [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! SRL             [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! SRA             [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! LT              [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! GT              [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! GE              [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! LE              [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! EQUAL           [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! NEQ             [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! LAND            [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! LOR             [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! ADD             [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]
  ! SUB             [ reduce using rule 141 (shiftExp -> shiftExp SRA addExp .) ]


state 211

    (136) addExp -> addExp ADD mulExp .
    (131) mulExp -> mulExp . MUL unaryExp
    (132) mulExp -> mulExp . DIV unaryExp
    (133) mulExp -> mulExp . MOD unaryExp
    (134) mulExp -> mulExp . POWER unaryExp
    (135) addExp -> mulExp .

  ! reduce/reduce conflict for ADD resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for SUB resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for SLL resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for SRL resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for SRA resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for LT resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for GT resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for GE resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for LE resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for LAND resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for LOR resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 135 (addExp -> mulExp .)
    ]               reduce using rule 136 (addExp -> addExp ADD mulExp .)
    )               reduce using rule 136 (addExp -> addExp ADD mulExp .)
    ;               reduce using rule 136 (addExp -> addExp ADD mulExp .)
    ,               reduce using rule 136 (addExp -> addExp ADD mulExp .)
    COLON           reduce using rule 136 (addExp -> addExp ADD mulExp .)
    RETURN          reduce using rule 136 (addExp -> addExp ADD mulExp .)
    CONST           reduce using rule 136 (addExp -> addExp ADD mulExp .)
    ID              reduce using rule 136 (addExp -> addExp ADD mulExp .)
    {               reduce using rule 136 (addExp -> addExp ADD mulExp .)
    MUX             reduce using rule 136 (addExp -> addExp ADD mulExp .)
    WHEN            reduce using rule 136 (addExp -> addExp ADD mulExp .)
    IF              reduce using rule 136 (addExp -> addExp ADD mulExp .)
    FOR             reduce using rule 136 (addExp -> addExp ADD mulExp .)
    GENERATE        reduce using rule 136 (addExp -> addExp ADD mulExp .)
    INT             reduce using rule 136 (addExp -> addExp ADD mulExp .)
    FLOAT           reduce using rule 136 (addExp -> addExp ADD mulExp .)
    REG             reduce using rule 136 (addExp -> addExp ADD mulExp .)
    WIRE            reduce using rule 136 (addExp -> addExp ADD mulExp .)
    CLOCK           reduce using rule 136 (addExp -> addExp ADD mulExp .)
    AND             reduce using rule 136 (addExp -> addExp ADD mulExp .)
    OR              reduce using rule 136 (addExp -> addExp ADD mulExp .)
    NOT             reduce using rule 136 (addExp -> addExp ADD mulExp .)
    XOR             reduce using rule 136 (addExp -> addExp ADD mulExp .)
    XNOR            reduce using rule 136 (addExp -> addExp ADD mulExp .)
    SIGNAL          reduce using rule 136 (addExp -> addExp ADD mulExp .)
    (               reduce using rule 136 (addExp -> addExp ADD mulExp .)
    NOTL            reduce using rule 136 (addExp -> addExp ADD mulExp .)
    INTEGER_CONST   reduce using rule 136 (addExp -> addExp ADD mulExp .)
    FLOAT_CONST     reduce using rule 136 (addExp -> addExp ADD mulExp .)
    }               reduce using rule 136 (addExp -> addExp ADD mulExp .)
    ELIF            reduce using rule 136 (addExp -> addExp ADD mulExp .)
    ELSE            reduce using rule 136 (addExp -> addExp ADD mulExp .)
    MUL             shift and go to state 147
    DIV             shift and go to state 148
    MOD             shift and go to state 149
    POWER           shift and go to state 150
    ADD             reduce using rule 135 (addExp -> mulExp .)
    SUB             reduce using rule 135 (addExp -> mulExp .)
    SLL             reduce using rule 135 (addExp -> mulExp .)
    SRL             reduce using rule 135 (addExp -> mulExp .)
    SRA             reduce using rule 135 (addExp -> mulExp .)
    LT              reduce using rule 135 (addExp -> mulExp .)
    GT              reduce using rule 135 (addExp -> mulExp .)
    GE              reduce using rule 135 (addExp -> mulExp .)
    LE              reduce using rule 135 (addExp -> mulExp .)
    EQUAL           reduce using rule 135 (addExp -> mulExp .)
    NEQ             reduce using rule 135 (addExp -> mulExp .)
    LAND            reduce using rule 135 (addExp -> mulExp .)
    LOR             reduce using rule 135 (addExp -> mulExp .)
    BIT_WIDTH_NUMBER reduce using rule 135 (addExp -> mulExp .)

  ! ADD             [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! SUB             [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! SLL             [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! SRL             [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! SRA             [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! LT              [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! GT              [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! GE              [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! LE              [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! EQUAL           [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! NEQ             [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! LAND            [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! LOR             [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 136 (addExp -> addExp ADD mulExp .) ]


state 212

    (137) addExp -> addExp SUB mulExp .
    (131) mulExp -> mulExp . MUL unaryExp
    (132) mulExp -> mulExp . DIV unaryExp
    (133) mulExp -> mulExp . MOD unaryExp
    (134) mulExp -> mulExp . POWER unaryExp
    (135) addExp -> mulExp .

  ! reduce/reduce conflict for ADD resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for SUB resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for SLL resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for SRL resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for SRA resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for LT resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for GT resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for GE resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for LE resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for LAND resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for LOR resolved using rule 135 (addExp -> mulExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 135 (addExp -> mulExp .)
    ]               reduce using rule 137 (addExp -> addExp SUB mulExp .)
    )               reduce using rule 137 (addExp -> addExp SUB mulExp .)
    ;               reduce using rule 137 (addExp -> addExp SUB mulExp .)
    ,               reduce using rule 137 (addExp -> addExp SUB mulExp .)
    COLON           reduce using rule 137 (addExp -> addExp SUB mulExp .)
    RETURN          reduce using rule 137 (addExp -> addExp SUB mulExp .)
    CONST           reduce using rule 137 (addExp -> addExp SUB mulExp .)
    ID              reduce using rule 137 (addExp -> addExp SUB mulExp .)
    {               reduce using rule 137 (addExp -> addExp SUB mulExp .)
    MUX             reduce using rule 137 (addExp -> addExp SUB mulExp .)
    WHEN            reduce using rule 137 (addExp -> addExp SUB mulExp .)
    IF              reduce using rule 137 (addExp -> addExp SUB mulExp .)
    FOR             reduce using rule 137 (addExp -> addExp SUB mulExp .)
    GENERATE        reduce using rule 137 (addExp -> addExp SUB mulExp .)
    INT             reduce using rule 137 (addExp -> addExp SUB mulExp .)
    FLOAT           reduce using rule 137 (addExp -> addExp SUB mulExp .)
    REG             reduce using rule 137 (addExp -> addExp SUB mulExp .)
    WIRE            reduce using rule 137 (addExp -> addExp SUB mulExp .)
    CLOCK           reduce using rule 137 (addExp -> addExp SUB mulExp .)
    AND             reduce using rule 137 (addExp -> addExp SUB mulExp .)
    OR              reduce using rule 137 (addExp -> addExp SUB mulExp .)
    NOT             reduce using rule 137 (addExp -> addExp SUB mulExp .)
    XOR             reduce using rule 137 (addExp -> addExp SUB mulExp .)
    XNOR            reduce using rule 137 (addExp -> addExp SUB mulExp .)
    SIGNAL          reduce using rule 137 (addExp -> addExp SUB mulExp .)
    (               reduce using rule 137 (addExp -> addExp SUB mulExp .)
    NOTL            reduce using rule 137 (addExp -> addExp SUB mulExp .)
    INTEGER_CONST   reduce using rule 137 (addExp -> addExp SUB mulExp .)
    FLOAT_CONST     reduce using rule 137 (addExp -> addExp SUB mulExp .)
    }               reduce using rule 137 (addExp -> addExp SUB mulExp .)
    ELIF            reduce using rule 137 (addExp -> addExp SUB mulExp .)
    ELSE            reduce using rule 137 (addExp -> addExp SUB mulExp .)
    MUL             shift and go to state 147
    DIV             shift and go to state 148
    MOD             shift and go to state 149
    POWER           shift and go to state 150
    ADD             reduce using rule 135 (addExp -> mulExp .)
    SUB             reduce using rule 135 (addExp -> mulExp .)
    SLL             reduce using rule 135 (addExp -> mulExp .)
    SRL             reduce using rule 135 (addExp -> mulExp .)
    SRA             reduce using rule 135 (addExp -> mulExp .)
    LT              reduce using rule 135 (addExp -> mulExp .)
    GT              reduce using rule 135 (addExp -> mulExp .)
    GE              reduce using rule 135 (addExp -> mulExp .)
    LE              reduce using rule 135 (addExp -> mulExp .)
    EQUAL           reduce using rule 135 (addExp -> mulExp .)
    NEQ             reduce using rule 135 (addExp -> mulExp .)
    LAND            reduce using rule 135 (addExp -> mulExp .)
    LOR             reduce using rule 135 (addExp -> mulExp .)
    BIT_WIDTH_NUMBER reduce using rule 135 (addExp -> mulExp .)

  ! ADD             [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! SUB             [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! SLL             [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! SRL             [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! SRA             [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! LT              [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! GT              [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! GE              [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! LE              [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! EQUAL           [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! NEQ             [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! LAND            [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! LOR             [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 137 (addExp -> addExp SUB mulExp .) ]


state 213

    (131) mulExp -> mulExp MUL unaryExp .
    (130) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 130 (mulExp -> unaryExp .)
    ]               reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    )               reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    ;               reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    ,               reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    COLON           reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    RETURN          reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    CONST           reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    ID              reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    {               reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    MUX             reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    WHEN            reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    IF              reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    FOR             reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    GENERATE        reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    INT             reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    FLOAT           reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    REG             reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    WIRE            reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    CLOCK           reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    AND             reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    OR              reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    NOT             reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    XOR             reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    XNOR            reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    SIGNAL          reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    (               reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    NOTL            reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    INTEGER_CONST   reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    FLOAT_CONST     reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    }               reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    ELIF            reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    ELSE            reduce using rule 131 (mulExp -> mulExp MUL unaryExp .)
    MUL             reduce using rule 130 (mulExp -> unaryExp .)
    DIV             reduce using rule 130 (mulExp -> unaryExp .)
    MOD             reduce using rule 130 (mulExp -> unaryExp .)
    POWER           reduce using rule 130 (mulExp -> unaryExp .)
    ADD             reduce using rule 130 (mulExp -> unaryExp .)
    SUB             reduce using rule 130 (mulExp -> unaryExp .)
    SLL             reduce using rule 130 (mulExp -> unaryExp .)
    SRL             reduce using rule 130 (mulExp -> unaryExp .)
    SRA             reduce using rule 130 (mulExp -> unaryExp .)
    LT              reduce using rule 130 (mulExp -> unaryExp .)
    GT              reduce using rule 130 (mulExp -> unaryExp .)
    GE              reduce using rule 130 (mulExp -> unaryExp .)
    LE              reduce using rule 130 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 130 (mulExp -> unaryExp .)
    NEQ             reduce using rule 130 (mulExp -> unaryExp .)
    LAND            reduce using rule 130 (mulExp -> unaryExp .)
    LOR             reduce using rule 130 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 130 (mulExp -> unaryExp .)

  ! MUL             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! DIV             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! MOD             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! POWER           [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! ADD             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! SUB             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! SLL             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! SRL             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! SRA             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! LT              [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! GT              [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! GE              [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! LE              [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! EQUAL           [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! NEQ             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! LAND            [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! LOR             [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 131 (mulExp -> mulExp MUL unaryExp .) ]


state 214

    (132) mulExp -> mulExp DIV unaryExp .
    (130) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 130 (mulExp -> unaryExp .)
    ]               reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    )               reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    ;               reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    ,               reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    COLON           reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    RETURN          reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    CONST           reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    ID              reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    {               reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    MUX             reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    WHEN            reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    IF              reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    FOR             reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    GENERATE        reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    INT             reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    FLOAT           reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    REG             reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    WIRE            reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    CLOCK           reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    AND             reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    OR              reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    NOT             reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    XOR             reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    XNOR            reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    SIGNAL          reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    (               reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    NOTL            reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    INTEGER_CONST   reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    FLOAT_CONST     reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    }               reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    ELIF            reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    ELSE            reduce using rule 132 (mulExp -> mulExp DIV unaryExp .)
    MUL             reduce using rule 130 (mulExp -> unaryExp .)
    DIV             reduce using rule 130 (mulExp -> unaryExp .)
    MOD             reduce using rule 130 (mulExp -> unaryExp .)
    POWER           reduce using rule 130 (mulExp -> unaryExp .)
    ADD             reduce using rule 130 (mulExp -> unaryExp .)
    SUB             reduce using rule 130 (mulExp -> unaryExp .)
    SLL             reduce using rule 130 (mulExp -> unaryExp .)
    SRL             reduce using rule 130 (mulExp -> unaryExp .)
    SRA             reduce using rule 130 (mulExp -> unaryExp .)
    LT              reduce using rule 130 (mulExp -> unaryExp .)
    GT              reduce using rule 130 (mulExp -> unaryExp .)
    GE              reduce using rule 130 (mulExp -> unaryExp .)
    LE              reduce using rule 130 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 130 (mulExp -> unaryExp .)
    NEQ             reduce using rule 130 (mulExp -> unaryExp .)
    LAND            reduce using rule 130 (mulExp -> unaryExp .)
    LOR             reduce using rule 130 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 130 (mulExp -> unaryExp .)

  ! MUL             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! DIV             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! MOD             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! POWER           [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! ADD             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! SUB             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! SLL             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! SRL             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! SRA             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! LT              [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! GT              [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! GE              [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! LE              [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! EQUAL           [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! NEQ             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! LAND            [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! LOR             [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 132 (mulExp -> mulExp DIV unaryExp .) ]


state 215

    (133) mulExp -> mulExp MOD unaryExp .
    (130) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 130 (mulExp -> unaryExp .)
    ]               reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    )               reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    ;               reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    ,               reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    COLON           reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    RETURN          reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    CONST           reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    ID              reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    {               reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    MUX             reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    WHEN            reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    IF              reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    FOR             reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    GENERATE        reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    INT             reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    FLOAT           reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    REG             reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    WIRE            reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    CLOCK           reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    AND             reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    OR              reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    NOT             reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    XOR             reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    XNOR            reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    SIGNAL          reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    (               reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    NOTL            reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    INTEGER_CONST   reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    FLOAT_CONST     reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    }               reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    ELIF            reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    ELSE            reduce using rule 133 (mulExp -> mulExp MOD unaryExp .)
    MUL             reduce using rule 130 (mulExp -> unaryExp .)
    DIV             reduce using rule 130 (mulExp -> unaryExp .)
    MOD             reduce using rule 130 (mulExp -> unaryExp .)
    POWER           reduce using rule 130 (mulExp -> unaryExp .)
    ADD             reduce using rule 130 (mulExp -> unaryExp .)
    SUB             reduce using rule 130 (mulExp -> unaryExp .)
    SLL             reduce using rule 130 (mulExp -> unaryExp .)
    SRL             reduce using rule 130 (mulExp -> unaryExp .)
    SRA             reduce using rule 130 (mulExp -> unaryExp .)
    LT              reduce using rule 130 (mulExp -> unaryExp .)
    GT              reduce using rule 130 (mulExp -> unaryExp .)
    GE              reduce using rule 130 (mulExp -> unaryExp .)
    LE              reduce using rule 130 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 130 (mulExp -> unaryExp .)
    NEQ             reduce using rule 130 (mulExp -> unaryExp .)
    LAND            reduce using rule 130 (mulExp -> unaryExp .)
    LOR             reduce using rule 130 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 130 (mulExp -> unaryExp .)

  ! MUL             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! DIV             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! MOD             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! POWER           [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! ADD             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! SUB             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! SLL             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! SRL             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! SRA             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! LT              [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! GT              [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! GE              [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! LE              [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! EQUAL           [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! NEQ             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! LAND            [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! LOR             [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 133 (mulExp -> mulExp MOD unaryExp .) ]


state 216

    (134) mulExp -> mulExp POWER unaryExp .
    (130) mulExp -> unaryExp .

  ! reduce/reduce conflict for MUL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for DIV resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for MOD resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for POWER resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for ADD resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SUB resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SLL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for SRA resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LT resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GT resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for GE resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LE resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for EQUAL resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for NEQ resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LAND resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for LOR resolved using rule 130 (mulExp -> unaryExp .)
  ! reduce/reduce conflict for BIT_WIDTH_NUMBER resolved using rule 130 (mulExp -> unaryExp .)
    ]               reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    )               reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    ;               reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    ,               reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    COLON           reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    RETURN          reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    CONST           reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    ID              reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    {               reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    MUX             reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    WHEN            reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    IF              reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    FOR             reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    GENERATE        reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    INT             reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    FLOAT           reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    REG             reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    WIRE            reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    CLOCK           reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    AND             reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    OR              reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    NOT             reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    XOR             reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    XNOR            reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    SIGNAL          reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    (               reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    NOTL            reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    INTEGER_CONST   reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    FLOAT_CONST     reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    }               reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    ELIF            reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    ELSE            reduce using rule 134 (mulExp -> mulExp POWER unaryExp .)
    MUL             reduce using rule 130 (mulExp -> unaryExp .)
    DIV             reduce using rule 130 (mulExp -> unaryExp .)
    MOD             reduce using rule 130 (mulExp -> unaryExp .)
    POWER           reduce using rule 130 (mulExp -> unaryExp .)
    ADD             reduce using rule 130 (mulExp -> unaryExp .)
    SUB             reduce using rule 130 (mulExp -> unaryExp .)
    SLL             reduce using rule 130 (mulExp -> unaryExp .)
    SRL             reduce using rule 130 (mulExp -> unaryExp .)
    SRA             reduce using rule 130 (mulExp -> unaryExp .)
    LT              reduce using rule 130 (mulExp -> unaryExp .)
    GT              reduce using rule 130 (mulExp -> unaryExp .)
    GE              reduce using rule 130 (mulExp -> unaryExp .)
    LE              reduce using rule 130 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 130 (mulExp -> unaryExp .)
    NEQ             reduce using rule 130 (mulExp -> unaryExp .)
    LAND            reduce using rule 130 (mulExp -> unaryExp .)
    LOR             reduce using rule 130 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 130 (mulExp -> unaryExp .)

  ! MUL             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! DIV             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! MOD             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! POWER           [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! ADD             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! SUB             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! SLL             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! SRL             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! SRA             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! LT              [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! GT              [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! GE              [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! LE              [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! EQUAL           [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! NEQ             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! LAND            [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! LOR             [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]
  ! BIT_WIDTH_NUMBER [ reduce using rule 134 (mulExp -> mulExp POWER unaryExp .) ]


state 217

    (118) unaryExp -> ID ( ) .

    MUL             reduce using rule 118 (unaryExp -> ID ( ) .)
    DIV             reduce using rule 118 (unaryExp -> ID ( ) .)
    MOD             reduce using rule 118 (unaryExp -> ID ( ) .)
    POWER           reduce using rule 118 (unaryExp -> ID ( ) .)
    ADD             reduce using rule 118 (unaryExp -> ID ( ) .)
    SUB             reduce using rule 118 (unaryExp -> ID ( ) .)
    SLL             reduce using rule 118 (unaryExp -> ID ( ) .)
    SRL             reduce using rule 118 (unaryExp -> ID ( ) .)
    SRA             reduce using rule 118 (unaryExp -> ID ( ) .)
    LT              reduce using rule 118 (unaryExp -> ID ( ) .)
    GT              reduce using rule 118 (unaryExp -> ID ( ) .)
    GE              reduce using rule 118 (unaryExp -> ID ( ) .)
    LE              reduce using rule 118 (unaryExp -> ID ( ) .)
    EQUAL           reduce using rule 118 (unaryExp -> ID ( ) .)
    NEQ             reduce using rule 118 (unaryExp -> ID ( ) .)
    LAND            reduce using rule 118 (unaryExp -> ID ( ) .)
    LOR             reduce using rule 118 (unaryExp -> ID ( ) .)
    ]               reduce using rule 118 (unaryExp -> ID ( ) .)
    BIT_WIDTH_NUMBER reduce using rule 118 (unaryExp -> ID ( ) .)
    )               reduce using rule 118 (unaryExp -> ID ( ) .)
    ;               reduce using rule 118 (unaryExp -> ID ( ) .)
    ,               reduce using rule 118 (unaryExp -> ID ( ) .)
    COLON           reduce using rule 118 (unaryExp -> ID ( ) .)
    RETURN          reduce using rule 118 (unaryExp -> ID ( ) .)
    CONST           reduce using rule 118 (unaryExp -> ID ( ) .)
    ID              reduce using rule 118 (unaryExp -> ID ( ) .)
    {               reduce using rule 118 (unaryExp -> ID ( ) .)
    MUX             reduce using rule 118 (unaryExp -> ID ( ) .)
    WHEN            reduce using rule 118 (unaryExp -> ID ( ) .)
    IF              reduce using rule 118 (unaryExp -> ID ( ) .)
    FOR             reduce using rule 118 (unaryExp -> ID ( ) .)
    GENERATE        reduce using rule 118 (unaryExp -> ID ( ) .)
    INT             reduce using rule 118 (unaryExp -> ID ( ) .)
    FLOAT           reduce using rule 118 (unaryExp -> ID ( ) .)
    REG             reduce using rule 118 (unaryExp -> ID ( ) .)
    WIRE            reduce using rule 118 (unaryExp -> ID ( ) .)
    CLOCK           reduce using rule 118 (unaryExp -> ID ( ) .)
    AND             reduce using rule 118 (unaryExp -> ID ( ) .)
    OR              reduce using rule 118 (unaryExp -> ID ( ) .)
    NOT             reduce using rule 118 (unaryExp -> ID ( ) .)
    XOR             reduce using rule 118 (unaryExp -> ID ( ) .)
    XNOR            reduce using rule 118 (unaryExp -> ID ( ) .)
    SIGNAL          reduce using rule 118 (unaryExp -> ID ( ) .)
    (               reduce using rule 118 (unaryExp -> ID ( ) .)
    NOTL            reduce using rule 118 (unaryExp -> ID ( ) .)
    INTEGER_CONST   reduce using rule 118 (unaryExp -> ID ( ) .)
    FLOAT_CONST     reduce using rule 118 (unaryExp -> ID ( ) .)
    }               reduce using rule 118 (unaryExp -> ID ( ) .)
    ELIF            reduce using rule 118 (unaryExp -> ID ( ) .)
    ELSE            reduce using rule 118 (unaryExp -> ID ( ) .)


state 218

    (119) unaryExp -> ID ( funcRParams . )

    )               shift and go to state 247


state 219

    (128) funcRParams -> exp .
    (129) funcRParams -> exp . exp_repeat
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER
    (126) exp_repeat -> . empty
    (127) exp_repeat -> . , exp exp_repeat
    (1) empty -> .

  ! reduce/reduce conflict for ) resolved using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER shift and go to state 122
    ,               shift and go to state 250
    )               reduce using rule 1 (empty -> .)

  ! )               [ reduce using rule 128 (funcRParams -> exp .) ]

    exp_repeat                     shift and go to state 248
    empty                          shift and go to state 249

state 220

    (110) array_exp_repeat1 -> [ exp . ] array_exp_repeat1
    (112) array_exp_repeat2 -> [ exp . COLON exp ] array_exp_repeat2
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               shift and go to state 251
    COLON           shift and go to state 252
    BIT_WIDTH_NUMBER shift and go to state 122


state 221

    (104) primaryExp -> ( exp ) .

    MUL             reduce using rule 104 (primaryExp -> ( exp ) .)
    DIV             reduce using rule 104 (primaryExp -> ( exp ) .)
    MOD             reduce using rule 104 (primaryExp -> ( exp ) .)
    POWER           reduce using rule 104 (primaryExp -> ( exp ) .)
    ADD             reduce using rule 104 (primaryExp -> ( exp ) .)
    SUB             reduce using rule 104 (primaryExp -> ( exp ) .)
    SLL             reduce using rule 104 (primaryExp -> ( exp ) .)
    SRL             reduce using rule 104 (primaryExp -> ( exp ) .)
    SRA             reduce using rule 104 (primaryExp -> ( exp ) .)
    LT              reduce using rule 104 (primaryExp -> ( exp ) .)
    GT              reduce using rule 104 (primaryExp -> ( exp ) .)
    GE              reduce using rule 104 (primaryExp -> ( exp ) .)
    LE              reduce using rule 104 (primaryExp -> ( exp ) .)
    EQUAL           reduce using rule 104 (primaryExp -> ( exp ) .)
    NEQ             reduce using rule 104 (primaryExp -> ( exp ) .)
    LAND            reduce using rule 104 (primaryExp -> ( exp ) .)
    LOR             reduce using rule 104 (primaryExp -> ( exp ) .)
    ]               reduce using rule 104 (primaryExp -> ( exp ) .)
    BIT_WIDTH_NUMBER reduce using rule 104 (primaryExp -> ( exp ) .)
    )               reduce using rule 104 (primaryExp -> ( exp ) .)
    ;               reduce using rule 104 (primaryExp -> ( exp ) .)
    ,               reduce using rule 104 (primaryExp -> ( exp ) .)
    COLON           reduce using rule 104 (primaryExp -> ( exp ) .)
    RETURN          reduce using rule 104 (primaryExp -> ( exp ) .)
    CONST           reduce using rule 104 (primaryExp -> ( exp ) .)
    ID              reduce using rule 104 (primaryExp -> ( exp ) .)
    {               reduce using rule 104 (primaryExp -> ( exp ) .)
    MUX             reduce using rule 104 (primaryExp -> ( exp ) .)
    WHEN            reduce using rule 104 (primaryExp -> ( exp ) .)
    IF              reduce using rule 104 (primaryExp -> ( exp ) .)
    FOR             reduce using rule 104 (primaryExp -> ( exp ) .)
    GENERATE        reduce using rule 104 (primaryExp -> ( exp ) .)
    INT             reduce using rule 104 (primaryExp -> ( exp ) .)
    FLOAT           reduce using rule 104 (primaryExp -> ( exp ) .)
    REG             reduce using rule 104 (primaryExp -> ( exp ) .)
    WIRE            reduce using rule 104 (primaryExp -> ( exp ) .)
    CLOCK           reduce using rule 104 (primaryExp -> ( exp ) .)
    AND             reduce using rule 104 (primaryExp -> ( exp ) .)
    OR              reduce using rule 104 (primaryExp -> ( exp ) .)
    NOT             reduce using rule 104 (primaryExp -> ( exp ) .)
    XOR             reduce using rule 104 (primaryExp -> ( exp ) .)
    XNOR            reduce using rule 104 (primaryExp -> ( exp ) .)
    SIGNAL          reduce using rule 104 (primaryExp -> ( exp ) .)
    (               reduce using rule 104 (primaryExp -> ( exp ) .)
    NOTL            reduce using rule 104 (primaryExp -> ( exp ) .)
    INTEGER_CONST   reduce using rule 104 (primaryExp -> ( exp ) .)
    FLOAT_CONST     reduce using rule 104 (primaryExp -> ( exp ) .)
    }               reduce using rule 104 (primaryExp -> ( exp ) .)
    ELIF            reduce using rule 104 (primaryExp -> ( exp ) .)
    ELSE            reduce using rule 104 (primaryExp -> ( exp ) .)


state 222

    (120) unaryExp -> SIGNAL ( unaryExp . )
    (130) mulExp -> unaryExp .

    )               shift and go to state 253
    MUL             reduce using rule 130 (mulExp -> unaryExp .)
    DIV             reduce using rule 130 (mulExp -> unaryExp .)
    MOD             reduce using rule 130 (mulExp -> unaryExp .)
    POWER           reduce using rule 130 (mulExp -> unaryExp .)
    ADD             reduce using rule 130 (mulExp -> unaryExp .)
    SUB             reduce using rule 130 (mulExp -> unaryExp .)
    SLL             reduce using rule 130 (mulExp -> unaryExp .)
    SRL             reduce using rule 130 (mulExp -> unaryExp .)
    SRA             reduce using rule 130 (mulExp -> unaryExp .)
    LT              reduce using rule 130 (mulExp -> unaryExp .)
    GT              reduce using rule 130 (mulExp -> unaryExp .)
    GE              reduce using rule 130 (mulExp -> unaryExp .)
    LE              reduce using rule 130 (mulExp -> unaryExp .)
    EQUAL           reduce using rule 130 (mulExp -> unaryExp .)
    NEQ             reduce using rule 130 (mulExp -> unaryExp .)
    LAND            reduce using rule 130 (mulExp -> unaryExp .)
    LOR             reduce using rule 130 (mulExp -> unaryExp .)
    BIT_WIDTH_NUMBER reduce using rule 130 (mulExp -> unaryExp .)


state 223

    (103) lVal -> lVal . ID .

    .               reduce using rule 103 (lVal -> lVal . ID .)
    MUL             reduce using rule 103 (lVal -> lVal . ID .)
    DIV             reduce using rule 103 (lVal -> lVal . ID .)
    MOD             reduce using rule 103 (lVal -> lVal . ID .)
    POWER           reduce using rule 103 (lVal -> lVal . ID .)
    ADD             reduce using rule 103 (lVal -> lVal . ID .)
    SUB             reduce using rule 103 (lVal -> lVal . ID .)
    SLL             reduce using rule 103 (lVal -> lVal . ID .)
    SRL             reduce using rule 103 (lVal -> lVal . ID .)
    SRA             reduce using rule 103 (lVal -> lVal . ID .)
    LT              reduce using rule 103 (lVal -> lVal . ID .)
    GT              reduce using rule 103 (lVal -> lVal . ID .)
    GE              reduce using rule 103 (lVal -> lVal . ID .)
    LE              reduce using rule 103 (lVal -> lVal . ID .)
    EQUAL           reduce using rule 103 (lVal -> lVal . ID .)
    NEQ             reduce using rule 103 (lVal -> lVal . ID .)
    LAND            reduce using rule 103 (lVal -> lVal . ID .)
    LOR             reduce using rule 103 (lVal -> lVal . ID .)
    ]               reduce using rule 103 (lVal -> lVal . ID .)
    BIT_WIDTH_NUMBER reduce using rule 103 (lVal -> lVal . ID .)
    )               reduce using rule 103 (lVal -> lVal . ID .)
    ;               reduce using rule 103 (lVal -> lVal . ID .)
    ,               reduce using rule 103 (lVal -> lVal . ID .)
    COLON           reduce using rule 103 (lVal -> lVal . ID .)
    RETURN          reduce using rule 103 (lVal -> lVal . ID .)
    CONST           reduce using rule 103 (lVal -> lVal . ID .)
    ID              reduce using rule 103 (lVal -> lVal . ID .)
    {               reduce using rule 103 (lVal -> lVal . ID .)
    MUX             reduce using rule 103 (lVal -> lVal . ID .)
    WHEN            reduce using rule 103 (lVal -> lVal . ID .)
    IF              reduce using rule 103 (lVal -> lVal . ID .)
    FOR             reduce using rule 103 (lVal -> lVal . ID .)
    GENERATE        reduce using rule 103 (lVal -> lVal . ID .)
    INT             reduce using rule 103 (lVal -> lVal . ID .)
    FLOAT           reduce using rule 103 (lVal -> lVal . ID .)
    REG             reduce using rule 103 (lVal -> lVal . ID .)
    WIRE            reduce using rule 103 (lVal -> lVal . ID .)
    CLOCK           reduce using rule 103 (lVal -> lVal . ID .)
    AND             reduce using rule 103 (lVal -> lVal . ID .)
    OR              reduce using rule 103 (lVal -> lVal . ID .)
    NOT             reduce using rule 103 (lVal -> lVal . ID .)
    XOR             reduce using rule 103 (lVal -> lVal . ID .)
    XNOR            reduce using rule 103 (lVal -> lVal . ID .)
    SIGNAL          reduce using rule 103 (lVal -> lVal . ID .)
    (               reduce using rule 103 (lVal -> lVal . ID .)
    NOTL            reduce using rule 103 (lVal -> lVal . ID .)
    INTEGER_CONST   reduce using rule 103 (lVal -> lVal . ID .)
    FLOAT_CONST     reduce using rule 103 (lVal -> lVal . ID .)
    }               reduce using rule 103 (lVal -> lVal . ID .)
    ELIF            reduce using rule 103 (lVal -> lVal . ID .)
    ELSE            reduce using rule 103 (lVal -> lVal . ID .)
    ASSIGN          reduce using rule 103 (lVal -> lVal . ID .)
    CONNECT         reduce using rule 103 (lVal -> lVal . ID .)


state 224

    (100) lVal -> { ID array_exp_repeat1 . lVal_repeat }
    (107) lVal_repeat -> . empty
    (108) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

    ,               shift and go to state 256
    }               reduce using rule 1 (empty -> .)

    lVal_repeat                    shift and go to state 254
    empty                          shift and go to state 255

state 225

    (101) lVal -> { ID array_exp_repeat2 . lVal_repeat }
    (107) lVal_repeat -> . empty
    (108) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

    ,               shift and go to state 256
    }               reduce using rule 1 (empty -> .)

    lVal_repeat                    shift and go to state 257
    empty                          shift and go to state 255

state 226

    (102) lVal -> MUX ( exp . , exp , exp )
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ,               shift and go to state 258
    BIT_WIDTH_NUMBER shift and go to state 122


state 227

    (56) cir_function -> cir_type ID ( cir_funcFParams ) block .

    MODULE          reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    BUNDLE          reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    CONST           reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    ID              reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    INT             reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    FLOAT           reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    REG             reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    WIRE            reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    CLOCK           reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)
    $end            reduce using rule 56 (cir_function -> cir_type ID ( cir_funcFParams ) block .)


state 228

    (76) block -> { . block_repeat }
    (74) block_repeat -> . empty
    (75) block_repeat -> . blockItem block_repeat
    (1) empty -> .
    (77) blockItem -> . decl
    (78) blockItem -> . stmt
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (53) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (38) modDecl -> . ID ID ( module_R_params )
    (48) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    }               reduce using rule 1 (empty -> .)
    ;               shift and go to state 267
    RETURN          shift and go to state 272
    CONST           shift and go to state 18
    ID              shift and go to state 275
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    block_repeat                   shift and go to state 260
    empty                          shift and go to state 261
    blockItem                      shift and go to state 262
    decl                           shift and go to state 263
    stmt                           shift and go to state 264
    constDecl                      shift and go to state 8
    varDecl                        shift and go to state 9
    cirDecl                        shift and go to state 10
    modDecl                        shift and go to state 11
    bundleDecl                     shift and go to state 12
    lVal                           shift and go to state 265
    exp                            shift and go to state 266
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    val_type                       shift and go to state 273
    cir_type                       shift and go to state 274
    lOrExp                         shift and go to state 58
    cir_basic_type                 shift and go to state 19
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 229

    (59) cir_funcFParams_repeat -> , cir_funcFParam . cir_funcFParams_repeat
    (58) cir_funcFParams_repeat -> . empty
    (59) cir_funcFParams_repeat -> . , cir_funcFParam cir_funcFParams_repeat
    (1) empty -> .

    ,               shift and go to state 165
    )               reduce using rule 1 (empty -> .)

    cir_funcFParams_repeat         shift and go to state 280
    empty                          shift and go to state 164

state 230

    (64) cir_funcFParam -> type_def ID array .

    ,               reduce using rule 64 (cir_funcFParam -> type_def ID array .)
    )               reduce using rule 64 (cir_funcFParam -> type_def ID array .)


state 231

    (50) initVal -> exp ; .

    ,               reduce using rule 50 (initVal -> exp ; .)
    ;               reduce using rule 50 (initVal -> exp ; .)


state 232

    (27) array -> [ constExp ] array .

    ASSIGN          reduce using rule 27 (array -> [ constExp ] array .)
    ,               reduce using rule 27 (array -> [ constExp ] array .)
    ;               reduce using rule 27 (array -> [ constExp ] array .)
    MODULE          reduce using rule 27 (array -> [ constExp ] array .)
    BUNDLE          reduce using rule 27 (array -> [ constExp ] array .)
    CONST           reduce using rule 27 (array -> [ constExp ] array .)
    ID              reduce using rule 27 (array -> [ constExp ] array .)
    INT             reduce using rule 27 (array -> [ constExp ] array .)
    FLOAT           reduce using rule 27 (array -> [ constExp ] array .)
    REG             reduce using rule 27 (array -> [ constExp ] array .)
    WIRE            reduce using rule 27 (array -> [ constExp ] array .)
    CLOCK           reduce using rule 27 (array -> [ constExp ] array .)
    $end            reduce using rule 27 (array -> [ constExp ] array .)
    RETURN          reduce using rule 27 (array -> [ constExp ] array .)
    {               reduce using rule 27 (array -> [ constExp ] array .)
    MUX             reduce using rule 27 (array -> [ constExp ] array .)
    WHEN            reduce using rule 27 (array -> [ constExp ] array .)
    IF              reduce using rule 27 (array -> [ constExp ] array .)
    FOR             reduce using rule 27 (array -> [ constExp ] array .)
    GENERATE        reduce using rule 27 (array -> [ constExp ] array .)
    AND             reduce using rule 27 (array -> [ constExp ] array .)
    OR              reduce using rule 27 (array -> [ constExp ] array .)
    NOT             reduce using rule 27 (array -> [ constExp ] array .)
    XOR             reduce using rule 27 (array -> [ constExp ] array .)
    XNOR            reduce using rule 27 (array -> [ constExp ] array .)
    SIGNAL          reduce using rule 27 (array -> [ constExp ] array .)
    (               reduce using rule 27 (array -> [ constExp ] array .)
    ADD             reduce using rule 27 (array -> [ constExp ] array .)
    SUB             reduce using rule 27 (array -> [ constExp ] array .)
    NOTL            reduce using rule 27 (array -> [ constExp ] array .)
    INTEGER_CONST   reduce using rule 27 (array -> [ constExp ] array .)
    FLOAT_CONST     reduce using rule 27 (array -> [ constExp ] array .)
    }               reduce using rule 27 (array -> [ constExp ] array .)
    )               reduce using rule 27 (array -> [ constExp ] array .)


state 233

    (44) module_R_params_repeat -> , p_module_R_params_item . module_R_params_repeat
    (43) module_R_params_repeat -> . empty
    (44) module_R_params_repeat -> . , p_module_R_params_item module_R_params_repeat
    (1) empty -> .

    ,               shift and go to state 174
    )               reduce using rule 1 (empty -> .)

    module_R_params_repeat         shift and go to state 281
    empty                          shift and go to state 173

state 234

    (42) p_module_R_params_item -> R_port_def ID ( . ID )

    ID              shift and go to state 282


state 235

    (65) funcFParam -> val_type ID array .

    ,               reduce using rule 65 (funcFParam -> val_type ID array .)
    )               reduce using rule 65 (funcFParam -> val_type ID array .)


state 236

    (57) function -> val_type ID ( funcFParams ) block .

    MODULE          reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)
    BUNDLE          reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)
    CONST           reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)
    ID              reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)
    INT             reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)
    FLOAT           reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)
    REG             reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)
    WIRE            reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)
    CLOCK           reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)
    $end            reduce using rule 57 (function -> val_type ID ( funcFParams ) block .)


state 237

    (62) funcFParams_repeat -> , funcFParam . funcFParams_repeat
    (61) funcFParams_repeat -> . empty
    (62) funcFParams_repeat -> . , funcFParam funcFParams_repeat
    (1) empty -> .

    ,               shift and go to state 184
    )               reduce using rule 1 (empty -> .)

    funcFParams_repeat             shift and go to state 283
    empty                          shift and go to state 183

state 238

    (70) module -> MODULE ID ( module_para_para port_def ID . p_module_para_port
    (68) p_module_para_port -> . empty
    (69) p_module_para_port -> . , port_def ID p_module_para_port
    (1) empty -> .

    ,               shift and go to state 286
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    p_module_para_port             shift and go to state 284
    empty                          shift and go to state 285

state 239

    (67) module_para_para -> PARA ID , . module_para_para
    (66) module_para_para -> . empty
    (67) module_para_para -> . PARA ID , module_para_para
    (1) empty -> .

    PARA            shift and go to state 115
    INPUT           reduce using rule 1 (empty -> .)
    OUTPUT          reduce using rule 1 (empty -> .)
    INOUT           reduce using rule 1 (empty -> .)

    module_para_para               shift and go to state 287
    empty                          shift and go to state 114

state 240

    (73) bundle -> BUNDLE ID ( cir_type ID bundle_repeat . )

    )               shift and go to state 288


state 241

    (71) bundle_repeat -> empty .

    )               reduce using rule 71 (bundle_repeat -> empty .)


state 242

    (72) bundle_repeat -> , . cir_type ID bundle bundle_repeat
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK

    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24

    cir_type                       shift and go to state 289
    cir_basic_type                 shift and go to state 19

state 243

    (15) constDecl_repeat -> , constDef constDecl_repeat .

    ;               reduce using rule 15 (constDecl_repeat -> , constDef constDecl_repeat .)


state 244

    (28) constDef -> ID array ASSIGN constInitVal .

    ,               reduce using rule 28 (constDef -> ID array ASSIGN constInitVal .)
    ;               reduce using rule 28 (constDef -> ID array ASSIGN constInitVal .)


state 245

    (31) constInitVal -> constExp .

    ,               reduce using rule 31 (constInitVal -> constExp .)
    ;               reduce using rule 31 (constInitVal -> constExp .)
    }               reduce using rule 31 (constInitVal -> constExp .)


state 246

    (32) constInitVal -> { . constInitVal constInitVal_repeat }
    (100) lVal -> { . ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> { . ID array_exp_repeat2 lVal_repeat }
    (31) constInitVal -> . constExp
    (32) constInitVal -> . { constInitVal constInitVal_repeat }
    (167) constExp -> . exp
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 291
    {               shift and go to state 246
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    constInitVal                   shift and go to state 290
    constExp                       shift and go to state 245
    exp                            shift and go to state 94
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 247

    (119) unaryExp -> ID ( funcRParams ) .

    MUL             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    DIV             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    MOD             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    POWER           reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    ADD             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    SUB             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    SLL             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    SRL             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    SRA             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    LT              reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    GT              reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    GE              reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    LE              reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    EQUAL           reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    NEQ             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    LAND            reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    LOR             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    ]               reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    BIT_WIDTH_NUMBER reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    )               reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    ;               reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    ,               reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    COLON           reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    RETURN          reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    CONST           reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    ID              reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    {               reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    MUX             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    WHEN            reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    IF              reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    FOR             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    GENERATE        reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    INT             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    FLOAT           reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    REG             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    WIRE            reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    CLOCK           reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    AND             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    OR              reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    NOT             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    XOR             reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    XNOR            reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    SIGNAL          reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    (               reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    NOTL            reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    INTEGER_CONST   reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    FLOAT_CONST     reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    }               reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    ELIF            reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)
    ELSE            reduce using rule 119 (unaryExp -> ID ( funcRParams ) .)


state 248

    (129) funcRParams -> exp exp_repeat .

    )               reduce using rule 129 (funcRParams -> exp exp_repeat .)


state 249

    (126) exp_repeat -> empty .

    )               reduce using rule 126 (exp_repeat -> empty .)


state 250

    (127) exp_repeat -> , . exp exp_repeat
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 292
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 251

    (110) array_exp_repeat1 -> [ exp ] . array_exp_repeat1
    (109) array_exp_repeat1 -> . empty
    (110) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (1) empty -> .

    [               shift and go to state 293
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    ]               reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    COLON           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ELIF            reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)

    array_exp_repeat1              shift and go to state 294
    empty                          shift and go to state 295

state 252

    (112) array_exp_repeat2 -> [ exp COLON . exp ] array_exp_repeat2
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 296
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 253

    (120) unaryExp -> SIGNAL ( unaryExp ) .

    MUL             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    DIV             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    MOD             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    POWER           reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    ADD             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    SUB             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    SLL             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    SRL             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    SRA             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    LT              reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    GT              reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    GE              reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    LE              reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    EQUAL           reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    NEQ             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    LAND            reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    LOR             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    ]               reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    BIT_WIDTH_NUMBER reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    )               reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    ;               reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    ,               reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    COLON           reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    RETURN          reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    CONST           reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    ID              reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    {               reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    MUX             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    WHEN            reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    IF              reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    FOR             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    GENERATE        reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    INT             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    FLOAT           reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    REG             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    WIRE            reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    CLOCK           reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    AND             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    OR              reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    NOT             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    XOR             reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    XNOR            reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    SIGNAL          reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    (               reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    NOTL            reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    INTEGER_CONST   reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    FLOAT_CONST     reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    }               reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    ELIF            reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)
    ELSE            reduce using rule 120 (unaryExp -> SIGNAL ( unaryExp ) .)


state 254

    (100) lVal -> { ID array_exp_repeat1 lVal_repeat . }

    }               shift and go to state 297


state 255

    (107) lVal_repeat -> empty .

    }               reduce using rule 107 (lVal_repeat -> empty .)


state 256

    (108) lVal_repeat -> , . lVal lVal_repeat
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID

    ID              shift and go to state 299
    {               shift and go to state 82
    MUX             shift and go to state 83

    lVal                           shift and go to state 298

state 257

    (101) lVal -> { ID array_exp_repeat2 lVal_repeat . }

    }               shift and go to state 300


state 258

    (102) lVal -> MUX ( exp , . exp , exp )
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 301
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 259

    (100) lVal -> { . ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> { . ID array_exp_repeat2 lVal_repeat }
    (76) block -> { . block_repeat }
    (74) block_repeat -> . empty
    (75) block_repeat -> . blockItem block_repeat
    (1) empty -> .
    (77) blockItem -> . decl
    (78) blockItem -> . stmt
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (53) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (38) modDecl -> . ID ID ( module_R_params )
    (48) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ID              shift and go to state 302
    }               reduce using rule 1 (empty -> .)
    ;               shift and go to state 267
    RETURN          shift and go to state 272
    CONST           shift and go to state 18
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    block_repeat                   shift and go to state 260
    empty                          shift and go to state 261
    blockItem                      shift and go to state 262
    decl                           shift and go to state 263
    stmt                           shift and go to state 264
    constDecl                      shift and go to state 8
    varDecl                        shift and go to state 9
    cirDecl                        shift and go to state 10
    modDecl                        shift and go to state 11
    bundleDecl                     shift and go to state 12
    lVal                           shift and go to state 265
    exp                            shift and go to state 266
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    val_type                       shift and go to state 273
    cir_type                       shift and go to state 274
    lOrExp                         shift and go to state 58
    cir_basic_type                 shift and go to state 19
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 260

    (76) block -> { block_repeat . }

    }               shift and go to state 303


state 261

    (74) block_repeat -> empty .

    }               reduce using rule 74 (block_repeat -> empty .)


state 262

    (75) block_repeat -> blockItem . block_repeat
    (74) block_repeat -> . empty
    (75) block_repeat -> . blockItem block_repeat
    (1) empty -> .
    (77) blockItem -> . decl
    (78) blockItem -> . stmt
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (53) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (38) modDecl -> . ID ID ( module_R_params )
    (48) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    }               reduce using rule 1 (empty -> .)
    ;               shift and go to state 267
    RETURN          shift and go to state 272
    CONST           shift and go to state 18
    ID              shift and go to state 275
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    blockItem                      shift and go to state 262
    block_repeat                   shift and go to state 304
    empty                          shift and go to state 261
    decl                           shift and go to state 263
    stmt                           shift and go to state 264
    constDecl                      shift and go to state 8
    varDecl                        shift and go to state 9
    cirDecl                        shift and go to state 10
    modDecl                        shift and go to state 11
    bundleDecl                     shift and go to state 12
    lVal                           shift and go to state 265
    exp                            shift and go to state 266
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    val_type                       shift and go to state 273
    cir_type                       shift and go to state 274
    lOrExp                         shift and go to state 58
    cir_basic_type                 shift and go to state 19
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 263

    (77) blockItem -> decl .

    ;               reduce using rule 77 (blockItem -> decl .)
    RETURN          reduce using rule 77 (blockItem -> decl .)
    CONST           reduce using rule 77 (blockItem -> decl .)
    ID              reduce using rule 77 (blockItem -> decl .)
    {               reduce using rule 77 (blockItem -> decl .)
    MUX             reduce using rule 77 (blockItem -> decl .)
    WHEN            reduce using rule 77 (blockItem -> decl .)
    IF              reduce using rule 77 (blockItem -> decl .)
    FOR             reduce using rule 77 (blockItem -> decl .)
    GENERATE        reduce using rule 77 (blockItem -> decl .)
    INT             reduce using rule 77 (blockItem -> decl .)
    FLOAT           reduce using rule 77 (blockItem -> decl .)
    REG             reduce using rule 77 (blockItem -> decl .)
    WIRE            reduce using rule 77 (blockItem -> decl .)
    CLOCK           reduce using rule 77 (blockItem -> decl .)
    AND             reduce using rule 77 (blockItem -> decl .)
    OR              reduce using rule 77 (blockItem -> decl .)
    NOT             reduce using rule 77 (blockItem -> decl .)
    XOR             reduce using rule 77 (blockItem -> decl .)
    XNOR            reduce using rule 77 (blockItem -> decl .)
    SIGNAL          reduce using rule 77 (blockItem -> decl .)
    (               reduce using rule 77 (blockItem -> decl .)
    ADD             reduce using rule 77 (blockItem -> decl .)
    SUB             reduce using rule 77 (blockItem -> decl .)
    NOTL            reduce using rule 77 (blockItem -> decl .)
    INTEGER_CONST   reduce using rule 77 (blockItem -> decl .)
    FLOAT_CONST     reduce using rule 77 (blockItem -> decl .)
    }               reduce using rule 77 (blockItem -> decl .)


state 264

    (78) blockItem -> stmt .

    ;               reduce using rule 78 (blockItem -> stmt .)
    RETURN          reduce using rule 78 (blockItem -> stmt .)
    CONST           reduce using rule 78 (blockItem -> stmt .)
    ID              reduce using rule 78 (blockItem -> stmt .)
    {               reduce using rule 78 (blockItem -> stmt .)
    MUX             reduce using rule 78 (blockItem -> stmt .)
    WHEN            reduce using rule 78 (blockItem -> stmt .)
    IF              reduce using rule 78 (blockItem -> stmt .)
    FOR             reduce using rule 78 (blockItem -> stmt .)
    GENERATE        reduce using rule 78 (blockItem -> stmt .)
    INT             reduce using rule 78 (blockItem -> stmt .)
    FLOAT           reduce using rule 78 (blockItem -> stmt .)
    REG             reduce using rule 78 (blockItem -> stmt .)
    WIRE            reduce using rule 78 (blockItem -> stmt .)
    CLOCK           reduce using rule 78 (blockItem -> stmt .)
    AND             reduce using rule 78 (blockItem -> stmt .)
    OR              reduce using rule 78 (blockItem -> stmt .)
    NOT             reduce using rule 78 (blockItem -> stmt .)
    XOR             reduce using rule 78 (blockItem -> stmt .)
    XNOR            reduce using rule 78 (blockItem -> stmt .)
    SIGNAL          reduce using rule 78 (blockItem -> stmt .)
    (               reduce using rule 78 (blockItem -> stmt .)
    ADD             reduce using rule 78 (blockItem -> stmt .)
    SUB             reduce using rule 78 (blockItem -> stmt .)
    NOTL            reduce using rule 78 (blockItem -> stmt .)
    INTEGER_CONST   reduce using rule 78 (blockItem -> stmt .)
    FLOAT_CONST     reduce using rule 78 (blockItem -> stmt .)
    }               reduce using rule 78 (blockItem -> stmt .)


state 265

    (79) stmt -> lVal . ASSIGN exp ;
    (80) stmt -> lVal . CONNECT exp ;
    (103) lVal -> lVal . . ID
    (105) primaryExp -> lVal .

    ASSIGN          shift and go to state 305
    CONNECT         shift and go to state 306
    .               shift and go to state 159
    MUL             reduce using rule 105 (primaryExp -> lVal .)
    DIV             reduce using rule 105 (primaryExp -> lVal .)
    MOD             reduce using rule 105 (primaryExp -> lVal .)
    POWER           reduce using rule 105 (primaryExp -> lVal .)
    ADD             reduce using rule 105 (primaryExp -> lVal .)
    SUB             reduce using rule 105 (primaryExp -> lVal .)
    SLL             reduce using rule 105 (primaryExp -> lVal .)
    SRL             reduce using rule 105 (primaryExp -> lVal .)
    SRA             reduce using rule 105 (primaryExp -> lVal .)
    LT              reduce using rule 105 (primaryExp -> lVal .)
    GT              reduce using rule 105 (primaryExp -> lVal .)
    GE              reduce using rule 105 (primaryExp -> lVal .)
    LE              reduce using rule 105 (primaryExp -> lVal .)
    EQUAL           reduce using rule 105 (primaryExp -> lVal .)
    NEQ             reduce using rule 105 (primaryExp -> lVal .)
    LAND            reduce using rule 105 (primaryExp -> lVal .)
    LOR             reduce using rule 105 (primaryExp -> lVal .)
    BIT_WIDTH_NUMBER reduce using rule 105 (primaryExp -> lVal .)
    ;               reduce using rule 105 (primaryExp -> lVal .)
    RETURN          reduce using rule 105 (primaryExp -> lVal .)
    CONST           reduce using rule 105 (primaryExp -> lVal .)
    ID              reduce using rule 105 (primaryExp -> lVal .)
    {               reduce using rule 105 (primaryExp -> lVal .)
    MUX             reduce using rule 105 (primaryExp -> lVal .)
    WHEN            reduce using rule 105 (primaryExp -> lVal .)
    IF              reduce using rule 105 (primaryExp -> lVal .)
    FOR             reduce using rule 105 (primaryExp -> lVal .)
    GENERATE        reduce using rule 105 (primaryExp -> lVal .)
    INT             reduce using rule 105 (primaryExp -> lVal .)
    FLOAT           reduce using rule 105 (primaryExp -> lVal .)
    REG             reduce using rule 105 (primaryExp -> lVal .)
    WIRE            reduce using rule 105 (primaryExp -> lVal .)
    CLOCK           reduce using rule 105 (primaryExp -> lVal .)
    AND             reduce using rule 105 (primaryExp -> lVal .)
    OR              reduce using rule 105 (primaryExp -> lVal .)
    NOT             reduce using rule 105 (primaryExp -> lVal .)
    XOR             reduce using rule 105 (primaryExp -> lVal .)
    XNOR            reduce using rule 105 (primaryExp -> lVal .)
    SIGNAL          reduce using rule 105 (primaryExp -> lVal .)
    (               reduce using rule 105 (primaryExp -> lVal .)
    NOTL            reduce using rule 105 (primaryExp -> lVal .)
    INTEGER_CONST   reduce using rule 105 (primaryExp -> lVal .)
    FLOAT_CONST     reduce using rule 105 (primaryExp -> lVal .)
    }               reduce using rule 105 (primaryExp -> lVal .)
    ELIF            reduce using rule 105 (primaryExp -> lVal .)
    ELSE            reduce using rule 105 (primaryExp -> lVal .)


state 266

    (82) stmt -> exp .
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               reduce using rule 82 (stmt -> exp .)
    RETURN          reduce using rule 82 (stmt -> exp .)
    CONST           reduce using rule 82 (stmt -> exp .)
    ID              reduce using rule 82 (stmt -> exp .)
    {               reduce using rule 82 (stmt -> exp .)
    MUX             reduce using rule 82 (stmt -> exp .)
    WHEN            reduce using rule 82 (stmt -> exp .)
    IF              reduce using rule 82 (stmt -> exp .)
    FOR             reduce using rule 82 (stmt -> exp .)
    GENERATE        reduce using rule 82 (stmt -> exp .)
    INT             reduce using rule 82 (stmt -> exp .)
    FLOAT           reduce using rule 82 (stmt -> exp .)
    REG             reduce using rule 82 (stmt -> exp .)
    WIRE            reduce using rule 82 (stmt -> exp .)
    CLOCK           reduce using rule 82 (stmt -> exp .)
    AND             reduce using rule 82 (stmt -> exp .)
    OR              reduce using rule 82 (stmt -> exp .)
    NOT             reduce using rule 82 (stmt -> exp .)
    XOR             reduce using rule 82 (stmt -> exp .)
    XNOR            reduce using rule 82 (stmt -> exp .)
    SIGNAL          reduce using rule 82 (stmt -> exp .)
    (               reduce using rule 82 (stmt -> exp .)
    ADD             reduce using rule 82 (stmt -> exp .)
    SUB             reduce using rule 82 (stmt -> exp .)
    NOTL            reduce using rule 82 (stmt -> exp .)
    INTEGER_CONST   reduce using rule 82 (stmt -> exp .)
    FLOAT_CONST     reduce using rule 82 (stmt -> exp .)
    }               reduce using rule 82 (stmt -> exp .)
    ELIF            reduce using rule 82 (stmt -> exp .)
    ELSE            reduce using rule 82 (stmt -> exp .)
    BIT_WIDTH_NUMBER shift and go to state 122


state 267

    (81) stmt -> ; .

    ;               reduce using rule 81 (stmt -> ; .)
    RETURN          reduce using rule 81 (stmt -> ; .)
    CONST           reduce using rule 81 (stmt -> ; .)
    ID              reduce using rule 81 (stmt -> ; .)
    {               reduce using rule 81 (stmt -> ; .)
    MUX             reduce using rule 81 (stmt -> ; .)
    WHEN            reduce using rule 81 (stmt -> ; .)
    IF              reduce using rule 81 (stmt -> ; .)
    FOR             reduce using rule 81 (stmt -> ; .)
    GENERATE        reduce using rule 81 (stmt -> ; .)
    INT             reduce using rule 81 (stmt -> ; .)
    FLOAT           reduce using rule 81 (stmt -> ; .)
    REG             reduce using rule 81 (stmt -> ; .)
    WIRE            reduce using rule 81 (stmt -> ; .)
    CLOCK           reduce using rule 81 (stmt -> ; .)
    AND             reduce using rule 81 (stmt -> ; .)
    OR              reduce using rule 81 (stmt -> ; .)
    NOT             reduce using rule 81 (stmt -> ; .)
    XOR             reduce using rule 81 (stmt -> ; .)
    XNOR            reduce using rule 81 (stmt -> ; .)
    SIGNAL          reduce using rule 81 (stmt -> ; .)
    (               reduce using rule 81 (stmt -> ; .)
    ADD             reduce using rule 81 (stmt -> ; .)
    SUB             reduce using rule 81 (stmt -> ; .)
    NOTL            reduce using rule 81 (stmt -> ; .)
    INTEGER_CONST   reduce using rule 81 (stmt -> ; .)
    FLOAT_CONST     reduce using rule 81 (stmt -> ; .)
    }               reduce using rule 81 (stmt -> ; .)
    ELIF            reduce using rule 81 (stmt -> ; .)
    ELSE            reduce using rule 81 (stmt -> ; .)


state 268

    (83) stmt -> block .

    ;               reduce using rule 83 (stmt -> block .)
    RETURN          reduce using rule 83 (stmt -> block .)
    CONST           reduce using rule 83 (stmt -> block .)
    ID              reduce using rule 83 (stmt -> block .)
    {               reduce using rule 83 (stmt -> block .)
    MUX             reduce using rule 83 (stmt -> block .)
    WHEN            reduce using rule 83 (stmt -> block .)
    IF              reduce using rule 83 (stmt -> block .)
    FOR             reduce using rule 83 (stmt -> block .)
    GENERATE        reduce using rule 83 (stmt -> block .)
    INT             reduce using rule 83 (stmt -> block .)
    FLOAT           reduce using rule 83 (stmt -> block .)
    REG             reduce using rule 83 (stmt -> block .)
    WIRE            reduce using rule 83 (stmt -> block .)
    CLOCK           reduce using rule 83 (stmt -> block .)
    AND             reduce using rule 83 (stmt -> block .)
    OR              reduce using rule 83 (stmt -> block .)
    NOT             reduce using rule 83 (stmt -> block .)
    XOR             reduce using rule 83 (stmt -> block .)
    XNOR            reduce using rule 83 (stmt -> block .)
    SIGNAL          reduce using rule 83 (stmt -> block .)
    (               reduce using rule 83 (stmt -> block .)
    ADD             reduce using rule 83 (stmt -> block .)
    SUB             reduce using rule 83 (stmt -> block .)
    NOTL            reduce using rule 83 (stmt -> block .)
    INTEGER_CONST   reduce using rule 83 (stmt -> block .)
    FLOAT_CONST     reduce using rule 83 (stmt -> block .)
    }               reduce using rule 83 (stmt -> block .)
    ELIF            reduce using rule 83 (stmt -> block .)
    ELSE            reduce using rule 83 (stmt -> block .)


state 269

    (84) stmt -> seqLogStmt .

    ;               reduce using rule 84 (stmt -> seqLogStmt .)
    RETURN          reduce using rule 84 (stmt -> seqLogStmt .)
    CONST           reduce using rule 84 (stmt -> seqLogStmt .)
    ID              reduce using rule 84 (stmt -> seqLogStmt .)
    {               reduce using rule 84 (stmt -> seqLogStmt .)
    MUX             reduce using rule 84 (stmt -> seqLogStmt .)
    WHEN            reduce using rule 84 (stmt -> seqLogStmt .)
    IF              reduce using rule 84 (stmt -> seqLogStmt .)
    FOR             reduce using rule 84 (stmt -> seqLogStmt .)
    GENERATE        reduce using rule 84 (stmt -> seqLogStmt .)
    INT             reduce using rule 84 (stmt -> seqLogStmt .)
    FLOAT           reduce using rule 84 (stmt -> seqLogStmt .)
    REG             reduce using rule 84 (stmt -> seqLogStmt .)
    WIRE            reduce using rule 84 (stmt -> seqLogStmt .)
    CLOCK           reduce using rule 84 (stmt -> seqLogStmt .)
    AND             reduce using rule 84 (stmt -> seqLogStmt .)
    OR              reduce using rule 84 (stmt -> seqLogStmt .)
    NOT             reduce using rule 84 (stmt -> seqLogStmt .)
    XOR             reduce using rule 84 (stmt -> seqLogStmt .)
    XNOR            reduce using rule 84 (stmt -> seqLogStmt .)
    SIGNAL          reduce using rule 84 (stmt -> seqLogStmt .)
    (               reduce using rule 84 (stmt -> seqLogStmt .)
    ADD             reduce using rule 84 (stmt -> seqLogStmt .)
    SUB             reduce using rule 84 (stmt -> seqLogStmt .)
    NOTL            reduce using rule 84 (stmt -> seqLogStmt .)
    INTEGER_CONST   reduce using rule 84 (stmt -> seqLogStmt .)
    FLOAT_CONST     reduce using rule 84 (stmt -> seqLogStmt .)
    }               reduce using rule 84 (stmt -> seqLogStmt .)
    ELIF            reduce using rule 84 (stmt -> seqLogStmt .)
    ELSE            reduce using rule 84 (stmt -> seqLogStmt .)


state 270

    (85) stmt -> ifStmt .

    ;               reduce using rule 85 (stmt -> ifStmt .)
    RETURN          reduce using rule 85 (stmt -> ifStmt .)
    CONST           reduce using rule 85 (stmt -> ifStmt .)
    ID              reduce using rule 85 (stmt -> ifStmt .)
    {               reduce using rule 85 (stmt -> ifStmt .)
    MUX             reduce using rule 85 (stmt -> ifStmt .)
    WHEN            reduce using rule 85 (stmt -> ifStmt .)
    IF              reduce using rule 85 (stmt -> ifStmt .)
    FOR             reduce using rule 85 (stmt -> ifStmt .)
    GENERATE        reduce using rule 85 (stmt -> ifStmt .)
    INT             reduce using rule 85 (stmt -> ifStmt .)
    FLOAT           reduce using rule 85 (stmt -> ifStmt .)
    REG             reduce using rule 85 (stmt -> ifStmt .)
    WIRE            reduce using rule 85 (stmt -> ifStmt .)
    CLOCK           reduce using rule 85 (stmt -> ifStmt .)
    AND             reduce using rule 85 (stmt -> ifStmt .)
    OR              reduce using rule 85 (stmt -> ifStmt .)
    NOT             reduce using rule 85 (stmt -> ifStmt .)
    XOR             reduce using rule 85 (stmt -> ifStmt .)
    XNOR            reduce using rule 85 (stmt -> ifStmt .)
    SIGNAL          reduce using rule 85 (stmt -> ifStmt .)
    (               reduce using rule 85 (stmt -> ifStmt .)
    ADD             reduce using rule 85 (stmt -> ifStmt .)
    SUB             reduce using rule 85 (stmt -> ifStmt .)
    NOTL            reduce using rule 85 (stmt -> ifStmt .)
    INTEGER_CONST   reduce using rule 85 (stmt -> ifStmt .)
    FLOAT_CONST     reduce using rule 85 (stmt -> ifStmt .)
    }               reduce using rule 85 (stmt -> ifStmt .)
    ELIF            reduce using rule 85 (stmt -> ifStmt .)
    ELSE            reduce using rule 85 (stmt -> ifStmt .)


state 271

    (86) stmt -> forStmt .

    ;               reduce using rule 86 (stmt -> forStmt .)
    RETURN          reduce using rule 86 (stmt -> forStmt .)
    CONST           reduce using rule 86 (stmt -> forStmt .)
    ID              reduce using rule 86 (stmt -> forStmt .)
    {               reduce using rule 86 (stmt -> forStmt .)
    MUX             reduce using rule 86 (stmt -> forStmt .)
    WHEN            reduce using rule 86 (stmt -> forStmt .)
    IF              reduce using rule 86 (stmt -> forStmt .)
    FOR             reduce using rule 86 (stmt -> forStmt .)
    GENERATE        reduce using rule 86 (stmt -> forStmt .)
    INT             reduce using rule 86 (stmt -> forStmt .)
    FLOAT           reduce using rule 86 (stmt -> forStmt .)
    REG             reduce using rule 86 (stmt -> forStmt .)
    WIRE            reduce using rule 86 (stmt -> forStmt .)
    CLOCK           reduce using rule 86 (stmt -> forStmt .)
    AND             reduce using rule 86 (stmt -> forStmt .)
    OR              reduce using rule 86 (stmt -> forStmt .)
    NOT             reduce using rule 86 (stmt -> forStmt .)
    XOR             reduce using rule 86 (stmt -> forStmt .)
    XNOR            reduce using rule 86 (stmt -> forStmt .)
    SIGNAL          reduce using rule 86 (stmt -> forStmt .)
    (               reduce using rule 86 (stmt -> forStmt .)
    ADD             reduce using rule 86 (stmt -> forStmt .)
    SUB             reduce using rule 86 (stmt -> forStmt .)
    NOTL            reduce using rule 86 (stmt -> forStmt .)
    INTEGER_CONST   reduce using rule 86 (stmt -> forStmt .)
    FLOAT_CONST     reduce using rule 86 (stmt -> forStmt .)
    }               reduce using rule 86 (stmt -> forStmt .)
    ELIF            reduce using rule 86 (stmt -> forStmt .)
    ELSE            reduce using rule 86 (stmt -> forStmt .)


state 272

    (87) stmt -> RETURN . exp ;
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 307
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 273

    (35) varDecl -> val_type . varDef varDef_repeat ;
    (36) varDef -> . ID array
    (37) varDef -> . ID array ASSIGN initVal

    ID              shift and go to state 112

    varDef                         shift and go to state 31

state 274

    (53) cirDecl -> cir_type . cirDef cirDecl_repeat ;
    (54) cirDef -> . ID array
    (55) cirDef -> . ID array ASSIGN initVal

    ID              shift and go to state 97

    cirDef                         shift and go to state 27

state 275

    (38) modDecl -> ID . ID ( module_R_params )
    (48) bundleDecl -> ID . bundleDef bundleDecl_repeat
    (98) lVal -> ID . array_exp_repeat1
    (99) lVal -> ID . array_exp_repeat2
    (118) unaryExp -> ID . ( )
    (119) unaryExp -> ID . ( funcRParams )
    (49) bundleDef -> . ID array
    (109) array_exp_repeat1 -> . empty
    (110) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (111) array_exp_repeat2 -> . empty
    (112) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    ID              shift and go to state 28
    (               shift and go to state 151
    [               shift and go to state 155
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! (               [ reduce using rule 1 (empty -> .) ]

    bundleDef                      shift and go to state 29
    array_exp_repeat1              shift and go to state 152
    array_exp_repeat2              shift and go to state 153
    empty                          shift and go to state 154

state 276

    (88) seqLogStmt -> WHEN . ( ID ) stmt
    (89) seqLogStmt -> WHEN . ( ID . RISING ) stmt
    (90) seqLogStmt -> WHEN . ( ID . FALLING ) stmt

    (               shift and go to state 308


state 277

    (94) ifStmt -> IF . ( exp ) stmt elifStmt elseStmt

    (               shift and go to state 309


state 278

    (95) forStmt -> FOR . ( varDecl ; exp ; exp ) stmt

    (               shift and go to state 310


state 279

    (96) forStmt -> GENERATE . FOR ( varDecl ; exp ; exp ) COLON ID stmt

    FOR             shift and go to state 311


state 280

    (59) cir_funcFParams_repeat -> , cir_funcFParam cir_funcFParams_repeat .

    )               reduce using rule 59 (cir_funcFParams_repeat -> , cir_funcFParam cir_funcFParams_repeat .)


state 281

    (44) module_R_params_repeat -> , p_module_R_params_item module_R_params_repeat .

    )               reduce using rule 44 (module_R_params_repeat -> , p_module_R_params_item module_R_params_repeat .)


state 282

    (42) p_module_R_params_item -> R_port_def ID ( ID . )

    )               shift and go to state 312


state 283

    (62) funcFParams_repeat -> , funcFParam funcFParams_repeat .

    )               reduce using rule 62 (funcFParams_repeat -> , funcFParam funcFParams_repeat .)


state 284

    (70) module -> MODULE ID ( module_para_para port_def ID p_module_para_port .

    MODULE          reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)
    BUNDLE          reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)
    CONST           reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)
    ID              reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)
    INT             reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)
    FLOAT           reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)
    REG             reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)
    WIRE            reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)
    CLOCK           reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)
    $end            reduce using rule 70 (module -> MODULE ID ( module_para_para port_def ID p_module_para_port .)


state 285

    (68) p_module_para_port -> empty .

    MODULE          reduce using rule 68 (p_module_para_port -> empty .)
    BUNDLE          reduce using rule 68 (p_module_para_port -> empty .)
    CONST           reduce using rule 68 (p_module_para_port -> empty .)
    ID              reduce using rule 68 (p_module_para_port -> empty .)
    INT             reduce using rule 68 (p_module_para_port -> empty .)
    FLOAT           reduce using rule 68 (p_module_para_port -> empty .)
    REG             reduce using rule 68 (p_module_para_port -> empty .)
    WIRE            reduce using rule 68 (p_module_para_port -> empty .)
    CLOCK           reduce using rule 68 (p_module_para_port -> empty .)
    $end            reduce using rule 68 (p_module_para_port -> empty .)


state 286

    (69) p_module_para_port -> , . port_def ID p_module_para_port
    (164) port_def -> . INPUT
    (165) port_def -> . OUTPUT
    (166) port_def -> . INOUT

    INPUT           shift and go to state 188
    OUTPUT          shift and go to state 189
    INOUT           shift and go to state 190

    port_def                       shift and go to state 313

state 287

    (67) module_para_para -> PARA ID , module_para_para .

    INPUT           reduce using rule 67 (module_para_para -> PARA ID , module_para_para .)
    OUTPUT          reduce using rule 67 (module_para_para -> PARA ID , module_para_para .)
    INOUT           reduce using rule 67 (module_para_para -> PARA ID , module_para_para .)


state 288

    (73) bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .

    MODULE          reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    BUNDLE          reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    CONST           reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    ID              reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    INT             reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    FLOAT           reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    REG             reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    WIRE            reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    CLOCK           reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    $end            reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    ,               reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)
    )               reduce using rule 73 (bundle -> BUNDLE ID ( cir_type ID bundle_repeat ) .)


state 289

    (72) bundle_repeat -> , cir_type . ID bundle bundle_repeat

    ID              shift and go to state 314


state 290

    (32) constInitVal -> { constInitVal . constInitVal_repeat }
    (29) constInitVal_repeat -> . empty
    (30) constInitVal_repeat -> . , constInitVal constInitVal_repeat
    (1) empty -> .

    ,               shift and go to state 317
    }               reduce using rule 1 (empty -> .)

    constInitVal_repeat            shift and go to state 315
    empty                          shift and go to state 316

state 291

    (100) lVal -> { ID . array_exp_repeat1 lVal_repeat }
    (101) lVal -> { ID . array_exp_repeat2 lVal_repeat }
    (118) unaryExp -> ID . ( )
    (119) unaryExp -> ID . ( funcRParams )
    (98) lVal -> ID . array_exp_repeat1
    (99) lVal -> ID . array_exp_repeat2
    (109) array_exp_repeat1 -> . empty
    (110) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (111) array_exp_repeat2 -> . empty
    (112) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

    (               shift and go to state 151
    [               shift and go to state 155
    ,               reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)

    array_exp_repeat1              shift and go to state 318
    array_exp_repeat2              shift and go to state 319
    empty                          shift and go to state 154

state 292

    (127) exp_repeat -> , exp . exp_repeat
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER
    (126) exp_repeat -> . empty
    (127) exp_repeat -> . , exp exp_repeat
    (1) empty -> .

    BIT_WIDTH_NUMBER shift and go to state 122
    ,               shift and go to state 250
    )               reduce using rule 1 (empty -> .)

    exp_repeat                     shift and go to state 320
    empty                          shift and go to state 249

state 293

    (110) array_exp_repeat1 -> [ . exp ] array_exp_repeat1
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 321
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 294

    (110) array_exp_repeat1 -> [ exp ] array_exp_repeat1 .

    .               reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    MUL             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    DIV             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    MOD             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    POWER           reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ADD             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SUB             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SLL             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SRL             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SRA             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    LT              reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    GT              reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    GE              reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    LE              reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    EQUAL           reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    NEQ             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    LAND            reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    LOR             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ]               reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    BIT_WIDTH_NUMBER reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    )               reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ;               reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ,               reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    COLON           reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    RETURN          reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    CONST           reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ID              reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    {               reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    MUX             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    WHEN            reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    IF              reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    FOR             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    GENERATE        reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    INT             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    FLOAT           reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    REG             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    WIRE            reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    CLOCK           reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    AND             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    OR              reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    NOT             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    XOR             reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    XNOR            reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    SIGNAL          reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    (               reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    NOTL            reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    INTEGER_CONST   reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    FLOAT_CONST     reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    }               reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ELIF            reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ELSE            reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    ASSIGN          reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)
    CONNECT         reduce using rule 110 (array_exp_repeat1 -> [ exp ] array_exp_repeat1 .)


state 295

    (109) array_exp_repeat1 -> empty .

    .               reduce using rule 109 (array_exp_repeat1 -> empty .)
    MUL             reduce using rule 109 (array_exp_repeat1 -> empty .)
    DIV             reduce using rule 109 (array_exp_repeat1 -> empty .)
    MOD             reduce using rule 109 (array_exp_repeat1 -> empty .)
    POWER           reduce using rule 109 (array_exp_repeat1 -> empty .)
    ADD             reduce using rule 109 (array_exp_repeat1 -> empty .)
    SUB             reduce using rule 109 (array_exp_repeat1 -> empty .)
    SLL             reduce using rule 109 (array_exp_repeat1 -> empty .)
    SRL             reduce using rule 109 (array_exp_repeat1 -> empty .)
    SRA             reduce using rule 109 (array_exp_repeat1 -> empty .)
    LT              reduce using rule 109 (array_exp_repeat1 -> empty .)
    GT              reduce using rule 109 (array_exp_repeat1 -> empty .)
    GE              reduce using rule 109 (array_exp_repeat1 -> empty .)
    LE              reduce using rule 109 (array_exp_repeat1 -> empty .)
    EQUAL           reduce using rule 109 (array_exp_repeat1 -> empty .)
    NEQ             reduce using rule 109 (array_exp_repeat1 -> empty .)
    LAND            reduce using rule 109 (array_exp_repeat1 -> empty .)
    LOR             reduce using rule 109 (array_exp_repeat1 -> empty .)
    ]               reduce using rule 109 (array_exp_repeat1 -> empty .)
    BIT_WIDTH_NUMBER reduce using rule 109 (array_exp_repeat1 -> empty .)
    )               reduce using rule 109 (array_exp_repeat1 -> empty .)
    ;               reduce using rule 109 (array_exp_repeat1 -> empty .)
    ,               reduce using rule 109 (array_exp_repeat1 -> empty .)
    COLON           reduce using rule 109 (array_exp_repeat1 -> empty .)
    RETURN          reduce using rule 109 (array_exp_repeat1 -> empty .)
    CONST           reduce using rule 109 (array_exp_repeat1 -> empty .)
    ID              reduce using rule 109 (array_exp_repeat1 -> empty .)
    {               reduce using rule 109 (array_exp_repeat1 -> empty .)
    MUX             reduce using rule 109 (array_exp_repeat1 -> empty .)
    WHEN            reduce using rule 109 (array_exp_repeat1 -> empty .)
    IF              reduce using rule 109 (array_exp_repeat1 -> empty .)
    FOR             reduce using rule 109 (array_exp_repeat1 -> empty .)
    GENERATE        reduce using rule 109 (array_exp_repeat1 -> empty .)
    INT             reduce using rule 109 (array_exp_repeat1 -> empty .)
    FLOAT           reduce using rule 109 (array_exp_repeat1 -> empty .)
    REG             reduce using rule 109 (array_exp_repeat1 -> empty .)
    WIRE            reduce using rule 109 (array_exp_repeat1 -> empty .)
    CLOCK           reduce using rule 109 (array_exp_repeat1 -> empty .)
    AND             reduce using rule 109 (array_exp_repeat1 -> empty .)
    OR              reduce using rule 109 (array_exp_repeat1 -> empty .)
    NOT             reduce using rule 109 (array_exp_repeat1 -> empty .)
    XOR             reduce using rule 109 (array_exp_repeat1 -> empty .)
    XNOR            reduce using rule 109 (array_exp_repeat1 -> empty .)
    SIGNAL          reduce using rule 109 (array_exp_repeat1 -> empty .)
    (               reduce using rule 109 (array_exp_repeat1 -> empty .)
    NOTL            reduce using rule 109 (array_exp_repeat1 -> empty .)
    INTEGER_CONST   reduce using rule 109 (array_exp_repeat1 -> empty .)
    FLOAT_CONST     reduce using rule 109 (array_exp_repeat1 -> empty .)
    }               reduce using rule 109 (array_exp_repeat1 -> empty .)
    ELIF            reduce using rule 109 (array_exp_repeat1 -> empty .)
    ELSE            reduce using rule 109 (array_exp_repeat1 -> empty .)
    ASSIGN          reduce using rule 109 (array_exp_repeat1 -> empty .)
    CONNECT         reduce using rule 109 (array_exp_repeat1 -> empty .)


state 296

    (112) array_exp_repeat2 -> [ exp COLON exp . ] array_exp_repeat2
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               shift and go to state 322
    BIT_WIDTH_NUMBER shift and go to state 122


state 297

    (100) lVal -> { ID array_exp_repeat1 lVal_repeat } .

    .               reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    MUL             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    DIV             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    MOD             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    POWER           reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ADD             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SUB             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SLL             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SRL             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SRA             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    LT              reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    GT              reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    GE              reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    LE              reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    EQUAL           reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    NEQ             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    LAND            reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    LOR             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ]               reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    BIT_WIDTH_NUMBER reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    )               reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ;               reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ,               reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    COLON           reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    RETURN          reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    CONST           reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ID              reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    {               reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    MUX             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    WHEN            reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    IF              reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    FOR             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    GENERATE        reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    INT             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    FLOAT           reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    REG             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    WIRE            reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    CLOCK           reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    AND             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    OR              reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    NOT             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    XOR             reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    XNOR            reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    SIGNAL          reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    (               reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    NOTL            reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    INTEGER_CONST   reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    FLOAT_CONST     reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    }               reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ELIF            reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ELSE            reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    ASSIGN          reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)
    CONNECT         reduce using rule 100 (lVal -> { ID array_exp_repeat1 lVal_repeat } .)


state 298

    (108) lVal_repeat -> , lVal . lVal_repeat
    (103) lVal -> lVal . . ID
    (107) lVal_repeat -> . empty
    (108) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

    .               shift and go to state 159
    ,               shift and go to state 256
    }               reduce using rule 1 (empty -> .)

    lVal_repeat                    shift and go to state 323
    empty                          shift and go to state 255

state 299

    (98) lVal -> ID . array_exp_repeat1
    (99) lVal -> ID . array_exp_repeat2
    (109) array_exp_repeat1 -> . empty
    (110) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (111) array_exp_repeat2 -> . empty
    (112) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

    [               shift and go to state 155
    .               reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)

    array_exp_repeat1              shift and go to state 152
    array_exp_repeat2              shift and go to state 153
    empty                          shift and go to state 154

state 300

    (101) lVal -> { ID array_exp_repeat2 lVal_repeat } .

    .               reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    MUL             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    DIV             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    MOD             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    POWER           reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ADD             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SUB             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SLL             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SRL             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SRA             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    LT              reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    GT              reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    GE              reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    LE              reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    EQUAL           reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    NEQ             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    LAND            reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    LOR             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ]               reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    BIT_WIDTH_NUMBER reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    )               reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ;               reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ,               reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    COLON           reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    RETURN          reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    CONST           reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ID              reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    {               reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    MUX             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    WHEN            reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    IF              reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    FOR             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    GENERATE        reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    INT             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    FLOAT           reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    REG             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    WIRE            reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    CLOCK           reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    AND             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    OR              reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    NOT             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    XOR             reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    XNOR            reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    SIGNAL          reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    (               reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    NOTL            reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    INTEGER_CONST   reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    FLOAT_CONST     reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    }               reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ELIF            reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ELSE            reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    ASSIGN          reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)
    CONNECT         reduce using rule 101 (lVal -> { ID array_exp_repeat2 lVal_repeat } .)


state 301

    (102) lVal -> MUX ( exp , exp . , exp )
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ,               shift and go to state 324
    BIT_WIDTH_NUMBER shift and go to state 122


state 302

    (100) lVal -> { ID . array_exp_repeat1 lVal_repeat }
    (101) lVal -> { ID . array_exp_repeat2 lVal_repeat }
    (38) modDecl -> ID . ID ( module_R_params )
    (48) bundleDecl -> ID . bundleDef bundleDecl_repeat
    (98) lVal -> ID . array_exp_repeat1
    (99) lVal -> ID . array_exp_repeat2
    (118) unaryExp -> ID . ( )
    (119) unaryExp -> ID . ( funcRParams )
    (109) array_exp_repeat1 -> . empty
    (110) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (111) array_exp_repeat2 -> . empty
    (112) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (49) bundleDef -> . ID array
    (1) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    ID              shift and go to state 28
    (               shift and go to state 151
    [               shift and go to state 155
    ,               reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)

  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! (               [ reduce using rule 1 (empty -> .) ]

    array_exp_repeat1              shift and go to state 318
    array_exp_repeat2              shift and go to state 319
    bundleDef                      shift and go to state 29
    empty                          shift and go to state 154

state 303

    (76) block -> { block_repeat } .

    MODULE          reduce using rule 76 (block -> { block_repeat } .)
    BUNDLE          reduce using rule 76 (block -> { block_repeat } .)
    CONST           reduce using rule 76 (block -> { block_repeat } .)
    ID              reduce using rule 76 (block -> { block_repeat } .)
    INT             reduce using rule 76 (block -> { block_repeat } .)
    FLOAT           reduce using rule 76 (block -> { block_repeat } .)
    REG             reduce using rule 76 (block -> { block_repeat } .)
    WIRE            reduce using rule 76 (block -> { block_repeat } .)
    CLOCK           reduce using rule 76 (block -> { block_repeat } .)
    $end            reduce using rule 76 (block -> { block_repeat } .)
    ;               reduce using rule 76 (block -> { block_repeat } .)
    RETURN          reduce using rule 76 (block -> { block_repeat } .)
    {               reduce using rule 76 (block -> { block_repeat } .)
    MUX             reduce using rule 76 (block -> { block_repeat } .)
    WHEN            reduce using rule 76 (block -> { block_repeat } .)
    IF              reduce using rule 76 (block -> { block_repeat } .)
    FOR             reduce using rule 76 (block -> { block_repeat } .)
    GENERATE        reduce using rule 76 (block -> { block_repeat } .)
    AND             reduce using rule 76 (block -> { block_repeat } .)
    OR              reduce using rule 76 (block -> { block_repeat } .)
    NOT             reduce using rule 76 (block -> { block_repeat } .)
    XOR             reduce using rule 76 (block -> { block_repeat } .)
    XNOR            reduce using rule 76 (block -> { block_repeat } .)
    SIGNAL          reduce using rule 76 (block -> { block_repeat } .)
    (               reduce using rule 76 (block -> { block_repeat } .)
    ADD             reduce using rule 76 (block -> { block_repeat } .)
    SUB             reduce using rule 76 (block -> { block_repeat } .)
    NOTL            reduce using rule 76 (block -> { block_repeat } .)
    INTEGER_CONST   reduce using rule 76 (block -> { block_repeat } .)
    FLOAT_CONST     reduce using rule 76 (block -> { block_repeat } .)
    }               reduce using rule 76 (block -> { block_repeat } .)
    ELIF            reduce using rule 76 (block -> { block_repeat } .)
    ELSE            reduce using rule 76 (block -> { block_repeat } .)


state 304

    (75) block_repeat -> blockItem block_repeat .

    }               reduce using rule 75 (block_repeat -> blockItem block_repeat .)


state 305

    (79) stmt -> lVal ASSIGN . exp ;
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    lVal                           shift and go to state 79
    exp                            shift and go to state 325
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 306

    (80) stmt -> lVal CONNECT . exp ;
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    lVal                           shift and go to state 79
    exp                            shift and go to state 326
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 307

    (87) stmt -> RETURN exp . ;
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 327
    BIT_WIDTH_NUMBER shift and go to state 122


state 308

    (88) seqLogStmt -> WHEN ( . ID ) stmt
    (89) seqLogStmt -> WHEN ( . ID . RISING ) stmt
    (90) seqLogStmt -> WHEN ( . ID . FALLING ) stmt

    ID              shift and go to state 328


state 309

    (94) ifStmt -> IF ( . exp ) stmt elifStmt elseStmt
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 329
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 310

    (95) forStmt -> FOR ( . varDecl ; exp ; exp ) stmt
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (22) val_type -> . INT
    (23) val_type -> . FLOAT

    INT             shift and go to state 20
    FLOAT           shift and go to state 21

    varDecl                        shift and go to state 330
    val_type                       shift and go to state 273

state 311

    (96) forStmt -> GENERATE FOR . ( varDecl ; exp ; exp ) COLON ID stmt

    (               shift and go to state 331


state 312

    (42) p_module_R_params_item -> R_port_def ID ( ID ) .

    ,               reduce using rule 42 (p_module_R_params_item -> R_port_def ID ( ID ) .)
    )               reduce using rule 42 (p_module_R_params_item -> R_port_def ID ( ID ) .)


state 313

    (69) p_module_para_port -> , port_def . ID p_module_para_port

    ID              shift and go to state 332


state 314

    (72) bundle_repeat -> , cir_type ID . bundle bundle_repeat
    (73) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )

    BUNDLE          shift and go to state 17

    bundle                         shift and go to state 333

state 315

    (32) constInitVal -> { constInitVal constInitVal_repeat . }

    }               shift and go to state 334


state 316

    (29) constInitVal_repeat -> empty .

    }               reduce using rule 29 (constInitVal_repeat -> empty .)


state 317

    (30) constInitVal_repeat -> , . constInitVal constInitVal_repeat
    (31) constInitVal -> . constExp
    (32) constInitVal -> . { constInitVal constInitVal_repeat }
    (167) constExp -> . exp
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    {               shift and go to state 246
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    constInitVal                   shift and go to state 335
    constExp                       shift and go to state 245
    exp                            shift and go to state 94
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 318

    (100) lVal -> { ID array_exp_repeat1 . lVal_repeat }
    (98) lVal -> ID array_exp_repeat1 .
    (107) lVal_repeat -> . empty
    (108) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

  ! shift/reduce conflict for , resolved as shift
  ! reduce/reduce conflict for } resolved using rule 1 (empty -> .)
    .               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    MUL             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    DIV             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    MOD             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    POWER           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ADD             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SUB             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SLL             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SRL             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SRA             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    LT              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    GT              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    GE              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    LE              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    EQUAL           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    NEQ             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    LAND            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    LOR             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    BIT_WIDTH_NUMBER reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ASSIGN          reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    CONNECT         reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ;               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    RETURN          reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    CONST           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ID              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    {               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    MUX             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    WHEN            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    IF              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    FOR             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    GENERATE        reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    INT             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    FLOAT           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    REG             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    WIRE            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    CLOCK           reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    AND             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    OR              reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    NOT             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    XOR             reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    XNOR            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    SIGNAL          reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    (               reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    NOTL            reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    INTEGER_CONST   reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    FLOAT_CONST     reduce using rule 98 (lVal -> ID array_exp_repeat1 .)
    ,               shift and go to state 256
    }               reduce using rule 1 (empty -> .)

  ! ,               [ reduce using rule 98 (lVal -> ID array_exp_repeat1 .) ]
  ! }               [ reduce using rule 98 (lVal -> ID array_exp_repeat1 .) ]

    lVal_repeat                    shift and go to state 254
    empty                          shift and go to state 255

state 319

    (101) lVal -> { ID array_exp_repeat2 . lVal_repeat }
    (99) lVal -> ID array_exp_repeat2 .
    (107) lVal_repeat -> . empty
    (108) lVal_repeat -> . , lVal lVal_repeat
    (1) empty -> .

  ! shift/reduce conflict for , resolved as shift
  ! reduce/reduce conflict for } resolved using rule 1 (empty -> .)
    .               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    MUL             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    DIV             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    MOD             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    POWER           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ADD             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SUB             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SLL             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SRL             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SRA             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    LT              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    GT              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    GE              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    LE              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    EQUAL           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    NEQ             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    LAND            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    LOR             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    BIT_WIDTH_NUMBER reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ASSIGN          reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    CONNECT         reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ;               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    RETURN          reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    CONST           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ID              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    {               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    MUX             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    WHEN            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    IF              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    FOR             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    GENERATE        reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    INT             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    FLOAT           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    REG             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    WIRE            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    CLOCK           reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    AND             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    OR              reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    NOT             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    XOR             reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    XNOR            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    SIGNAL          reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    (               reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    NOTL            reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    INTEGER_CONST   reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    FLOAT_CONST     reduce using rule 99 (lVal -> ID array_exp_repeat2 .)
    ,               shift and go to state 256
    }               reduce using rule 1 (empty -> .)

  ! ,               [ reduce using rule 99 (lVal -> ID array_exp_repeat2 .) ]
  ! }               [ reduce using rule 99 (lVal -> ID array_exp_repeat2 .) ]

    lVal_repeat                    shift and go to state 257
    empty                          shift and go to state 255

state 320

    (127) exp_repeat -> , exp exp_repeat .

    )               reduce using rule 127 (exp_repeat -> , exp exp_repeat .)


state 321

    (110) array_exp_repeat1 -> [ exp . ] array_exp_repeat1
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ]               shift and go to state 251
    BIT_WIDTH_NUMBER shift and go to state 122


state 322

    (112) array_exp_repeat2 -> [ exp COLON exp ] . array_exp_repeat2
    (111) array_exp_repeat2 -> . empty
    (112) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

    [               shift and go to state 336
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    ]               reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    )               reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    ,               reduce using rule 1 (empty -> .)
    COLON           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    (               reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ELIF            reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)

    array_exp_repeat2              shift and go to state 337
    empty                          shift and go to state 338

state 323

    (108) lVal_repeat -> , lVal lVal_repeat .

    }               reduce using rule 108 (lVal_repeat -> , lVal lVal_repeat .)


state 324

    (102) lVal -> MUX ( exp , exp , . exp )
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 339
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 325

    (79) stmt -> lVal ASSIGN exp . ;
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 340
    BIT_WIDTH_NUMBER shift and go to state 122


state 326

    (80) stmt -> lVal CONNECT exp . ;
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 341
    BIT_WIDTH_NUMBER shift and go to state 122


state 327

    (87) stmt -> RETURN exp ; .

    ;               reduce using rule 87 (stmt -> RETURN exp ; .)
    RETURN          reduce using rule 87 (stmt -> RETURN exp ; .)
    CONST           reduce using rule 87 (stmt -> RETURN exp ; .)
    ID              reduce using rule 87 (stmt -> RETURN exp ; .)
    {               reduce using rule 87 (stmt -> RETURN exp ; .)
    MUX             reduce using rule 87 (stmt -> RETURN exp ; .)
    WHEN            reduce using rule 87 (stmt -> RETURN exp ; .)
    IF              reduce using rule 87 (stmt -> RETURN exp ; .)
    FOR             reduce using rule 87 (stmt -> RETURN exp ; .)
    GENERATE        reduce using rule 87 (stmt -> RETURN exp ; .)
    INT             reduce using rule 87 (stmt -> RETURN exp ; .)
    FLOAT           reduce using rule 87 (stmt -> RETURN exp ; .)
    REG             reduce using rule 87 (stmt -> RETURN exp ; .)
    WIRE            reduce using rule 87 (stmt -> RETURN exp ; .)
    CLOCK           reduce using rule 87 (stmt -> RETURN exp ; .)
    AND             reduce using rule 87 (stmt -> RETURN exp ; .)
    OR              reduce using rule 87 (stmt -> RETURN exp ; .)
    NOT             reduce using rule 87 (stmt -> RETURN exp ; .)
    XOR             reduce using rule 87 (stmt -> RETURN exp ; .)
    XNOR            reduce using rule 87 (stmt -> RETURN exp ; .)
    SIGNAL          reduce using rule 87 (stmt -> RETURN exp ; .)
    (               reduce using rule 87 (stmt -> RETURN exp ; .)
    ADD             reduce using rule 87 (stmt -> RETURN exp ; .)
    SUB             reduce using rule 87 (stmt -> RETURN exp ; .)
    NOTL            reduce using rule 87 (stmt -> RETURN exp ; .)
    INTEGER_CONST   reduce using rule 87 (stmt -> RETURN exp ; .)
    FLOAT_CONST     reduce using rule 87 (stmt -> RETURN exp ; .)
    }               reduce using rule 87 (stmt -> RETURN exp ; .)
    ELIF            reduce using rule 87 (stmt -> RETURN exp ; .)
    ELSE            reduce using rule 87 (stmt -> RETURN exp ; .)


state 328

    (88) seqLogStmt -> WHEN ( ID . ) stmt
    (89) seqLogStmt -> WHEN ( ID . . RISING ) stmt
    (90) seqLogStmt -> WHEN ( ID . . FALLING ) stmt

    )               shift and go to state 342
    .               shift and go to state 343


state 329

    (94) ifStmt -> IF ( exp . ) stmt elifStmt elseStmt
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 344
    BIT_WIDTH_NUMBER shift and go to state 122


state 330

    (95) forStmt -> FOR ( varDecl . ; exp ; exp ) stmt

    ;               shift and go to state 345


state 331

    (96) forStmt -> GENERATE FOR ( . varDecl ; exp ; exp ) COLON ID stmt
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (22) val_type -> . INT
    (23) val_type -> . FLOAT

    INT             shift and go to state 20
    FLOAT           shift and go to state 21

    varDecl                        shift and go to state 346
    val_type                       shift and go to state 273

state 332

    (69) p_module_para_port -> , port_def ID . p_module_para_port
    (68) p_module_para_port -> . empty
    (69) p_module_para_port -> . , port_def ID p_module_para_port
    (1) empty -> .

    ,               shift and go to state 286
    MODULE          reduce using rule 1 (empty -> .)
    BUNDLE          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    p_module_para_port             shift and go to state 347
    empty                          shift and go to state 285

state 333

    (72) bundle_repeat -> , cir_type ID bundle . bundle_repeat
    (71) bundle_repeat -> . empty
    (72) bundle_repeat -> . , cir_type ID bundle bundle_repeat
    (1) empty -> .

    ,               shift and go to state 242
    )               reduce using rule 1 (empty -> .)

    bundle_repeat                  shift and go to state 348
    empty                          shift and go to state 241

state 334

    (32) constInitVal -> { constInitVal constInitVal_repeat } .

    ,               reduce using rule 32 (constInitVal -> { constInitVal constInitVal_repeat } .)
    ;               reduce using rule 32 (constInitVal -> { constInitVal constInitVal_repeat } .)
    }               reduce using rule 32 (constInitVal -> { constInitVal constInitVal_repeat } .)


state 335

    (30) constInitVal_repeat -> , constInitVal . constInitVal_repeat
    (29) constInitVal_repeat -> . empty
    (30) constInitVal_repeat -> . , constInitVal constInitVal_repeat
    (1) empty -> .

    ,               shift and go to state 317
    }               reduce using rule 1 (empty -> .)

    constInitVal_repeat            shift and go to state 349
    empty                          shift and go to state 316

state 336

    (112) array_exp_repeat2 -> [ . exp COLON exp ] array_exp_repeat2
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 350
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 337

    (112) array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .

    .               reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    MUL             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    DIV             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    MOD             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    POWER           reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ADD             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SUB             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SLL             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SRL             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SRA             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    LT              reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    GT              reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    GE              reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    LE              reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    EQUAL           reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    NEQ             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    LAND            reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    LOR             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ]               reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    BIT_WIDTH_NUMBER reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    )               reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ;               reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ,               reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    COLON           reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    RETURN          reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    CONST           reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ID              reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    {               reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    MUX             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    WHEN            reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    IF              reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    FOR             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    GENERATE        reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    INT             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    FLOAT           reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    REG             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    WIRE            reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    CLOCK           reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    AND             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    OR              reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    NOT             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    XOR             reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    XNOR            reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    SIGNAL          reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    (               reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    NOTL            reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    INTEGER_CONST   reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    FLOAT_CONST     reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    }               reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ELIF            reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ELSE            reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    ASSIGN          reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)
    CONNECT         reduce using rule 112 (array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2 .)


state 338

    (111) array_exp_repeat2 -> empty .

    .               reduce using rule 111 (array_exp_repeat2 -> empty .)
    MUL             reduce using rule 111 (array_exp_repeat2 -> empty .)
    DIV             reduce using rule 111 (array_exp_repeat2 -> empty .)
    MOD             reduce using rule 111 (array_exp_repeat2 -> empty .)
    POWER           reduce using rule 111 (array_exp_repeat2 -> empty .)
    ADD             reduce using rule 111 (array_exp_repeat2 -> empty .)
    SUB             reduce using rule 111 (array_exp_repeat2 -> empty .)
    SLL             reduce using rule 111 (array_exp_repeat2 -> empty .)
    SRL             reduce using rule 111 (array_exp_repeat2 -> empty .)
    SRA             reduce using rule 111 (array_exp_repeat2 -> empty .)
    LT              reduce using rule 111 (array_exp_repeat2 -> empty .)
    GT              reduce using rule 111 (array_exp_repeat2 -> empty .)
    GE              reduce using rule 111 (array_exp_repeat2 -> empty .)
    LE              reduce using rule 111 (array_exp_repeat2 -> empty .)
    EQUAL           reduce using rule 111 (array_exp_repeat2 -> empty .)
    NEQ             reduce using rule 111 (array_exp_repeat2 -> empty .)
    LAND            reduce using rule 111 (array_exp_repeat2 -> empty .)
    LOR             reduce using rule 111 (array_exp_repeat2 -> empty .)
    ]               reduce using rule 111 (array_exp_repeat2 -> empty .)
    BIT_WIDTH_NUMBER reduce using rule 111 (array_exp_repeat2 -> empty .)
    )               reduce using rule 111 (array_exp_repeat2 -> empty .)
    ;               reduce using rule 111 (array_exp_repeat2 -> empty .)
    ,               reduce using rule 111 (array_exp_repeat2 -> empty .)
    COLON           reduce using rule 111 (array_exp_repeat2 -> empty .)
    RETURN          reduce using rule 111 (array_exp_repeat2 -> empty .)
    CONST           reduce using rule 111 (array_exp_repeat2 -> empty .)
    ID              reduce using rule 111 (array_exp_repeat2 -> empty .)
    {               reduce using rule 111 (array_exp_repeat2 -> empty .)
    MUX             reduce using rule 111 (array_exp_repeat2 -> empty .)
    WHEN            reduce using rule 111 (array_exp_repeat2 -> empty .)
    IF              reduce using rule 111 (array_exp_repeat2 -> empty .)
    FOR             reduce using rule 111 (array_exp_repeat2 -> empty .)
    GENERATE        reduce using rule 111 (array_exp_repeat2 -> empty .)
    INT             reduce using rule 111 (array_exp_repeat2 -> empty .)
    FLOAT           reduce using rule 111 (array_exp_repeat2 -> empty .)
    REG             reduce using rule 111 (array_exp_repeat2 -> empty .)
    WIRE            reduce using rule 111 (array_exp_repeat2 -> empty .)
    CLOCK           reduce using rule 111 (array_exp_repeat2 -> empty .)
    AND             reduce using rule 111 (array_exp_repeat2 -> empty .)
    OR              reduce using rule 111 (array_exp_repeat2 -> empty .)
    NOT             reduce using rule 111 (array_exp_repeat2 -> empty .)
    XOR             reduce using rule 111 (array_exp_repeat2 -> empty .)
    XNOR            reduce using rule 111 (array_exp_repeat2 -> empty .)
    SIGNAL          reduce using rule 111 (array_exp_repeat2 -> empty .)
    (               reduce using rule 111 (array_exp_repeat2 -> empty .)
    NOTL            reduce using rule 111 (array_exp_repeat2 -> empty .)
    INTEGER_CONST   reduce using rule 111 (array_exp_repeat2 -> empty .)
    FLOAT_CONST     reduce using rule 111 (array_exp_repeat2 -> empty .)
    }               reduce using rule 111 (array_exp_repeat2 -> empty .)
    ELIF            reduce using rule 111 (array_exp_repeat2 -> empty .)
    ELSE            reduce using rule 111 (array_exp_repeat2 -> empty .)
    ASSIGN          reduce using rule 111 (array_exp_repeat2 -> empty .)
    CONNECT         reduce using rule 111 (array_exp_repeat2 -> empty .)


state 339

    (102) lVal -> MUX ( exp , exp , exp . )
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 351
    BIT_WIDTH_NUMBER shift and go to state 122


state 340

    (79) stmt -> lVal ASSIGN exp ; .

    ;               reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    RETURN          reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    CONST           reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    ID              reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    {               reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    MUX             reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    WHEN            reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    IF              reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    FOR             reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    GENERATE        reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    INT             reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    FLOAT           reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    REG             reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    WIRE            reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    CLOCK           reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    AND             reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    OR              reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    NOT             reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    XOR             reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    XNOR            reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    SIGNAL          reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    (               reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    ADD             reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    SUB             reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    NOTL            reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    INTEGER_CONST   reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    FLOAT_CONST     reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    }               reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    ELIF            reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)
    ELSE            reduce using rule 79 (stmt -> lVal ASSIGN exp ; .)


state 341

    (80) stmt -> lVal CONNECT exp ; .

    ;               reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    RETURN          reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    CONST           reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    ID              reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    {               reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    MUX             reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    WHEN            reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    IF              reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    FOR             reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    GENERATE        reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    INT             reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    FLOAT           reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    REG             reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    WIRE            reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    CLOCK           reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    AND             reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    OR              reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    NOT             reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    XOR             reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    XNOR            reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    SIGNAL          reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    (               reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    ADD             reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    SUB             reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    NOTL            reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    INTEGER_CONST   reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    FLOAT_CONST     reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    }               reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    ELIF            reduce using rule 80 (stmt -> lVal CONNECT exp ; .)
    ELSE            reduce using rule 80 (stmt -> lVal CONNECT exp ; .)


state 342

    (88) seqLogStmt -> WHEN ( ID ) . stmt
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 267
    RETURN          shift and go to state 272
    ID              shift and go to state 352
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    stmt                           shift and go to state 353
    lVal                           shift and go to state 265
    exp                            shift and go to state 266
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 343

    (89) seqLogStmt -> WHEN ( ID . . RISING ) stmt
    (90) seqLogStmt -> WHEN ( ID . . FALLING ) stmt

    RISING          shift and go to state 354
    FALLING         shift and go to state 355


state 344

    (94) ifStmt -> IF ( exp ) . stmt elifStmt elseStmt
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 267
    RETURN          shift and go to state 272
    ID              shift and go to state 352
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 266
    stmt                           shift and go to state 356
    lVal                           shift and go to state 265
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 345

    (95) forStmt -> FOR ( varDecl ; . exp ; exp ) stmt
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 357
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 346

    (96) forStmt -> GENERATE FOR ( varDecl . ; exp ; exp ) COLON ID stmt

    ;               shift and go to state 358


state 347

    (69) p_module_para_port -> , port_def ID p_module_para_port .

    MODULE          reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)
    BUNDLE          reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)
    CONST           reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)
    ID              reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)
    INT             reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)
    FLOAT           reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)
    REG             reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)
    WIRE            reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)
    CLOCK           reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)
    $end            reduce using rule 69 (p_module_para_port -> , port_def ID p_module_para_port .)


state 348

    (72) bundle_repeat -> , cir_type ID bundle bundle_repeat .

    )               reduce using rule 72 (bundle_repeat -> , cir_type ID bundle bundle_repeat .)


state 349

    (30) constInitVal_repeat -> , constInitVal constInitVal_repeat .

    }               reduce using rule 30 (constInitVal_repeat -> , constInitVal constInitVal_repeat .)


state 350

    (112) array_exp_repeat2 -> [ exp . COLON exp ] array_exp_repeat2
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    COLON           shift and go to state 252
    BIT_WIDTH_NUMBER shift and go to state 122


state 351

    (102) lVal -> MUX ( exp , exp , exp ) .

    .               reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    MUL             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    DIV             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    MOD             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    POWER           reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    ADD             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    SUB             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    SLL             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    SRL             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    SRA             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    LT              reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    GT              reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    GE              reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    LE              reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    EQUAL           reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    NEQ             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    LAND            reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    LOR             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    ]               reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    BIT_WIDTH_NUMBER reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    )               reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    ;               reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    ,               reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    COLON           reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    RETURN          reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    CONST           reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    ID              reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    {               reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    MUX             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    WHEN            reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    IF              reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    FOR             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    GENERATE        reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    INT             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    FLOAT           reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    REG             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    WIRE            reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    CLOCK           reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    AND             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    OR              reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    NOT             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    XOR             reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    XNOR            reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    SIGNAL          reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    (               reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    NOTL            reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    INTEGER_CONST   reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    FLOAT_CONST     reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    }               reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    ELIF            reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    ELSE            reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    ASSIGN          reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)
    CONNECT         reduce using rule 102 (lVal -> MUX ( exp , exp , exp ) .)


state 352

    (98) lVal -> ID . array_exp_repeat1
    (99) lVal -> ID . array_exp_repeat2
    (118) unaryExp -> ID . ( )
    (119) unaryExp -> ID . ( funcRParams )
    (109) array_exp_repeat1 -> . empty
    (110) array_exp_repeat1 -> . [ exp ] array_exp_repeat1
    (111) array_exp_repeat2 -> . empty
    (112) array_exp_repeat2 -> . [ exp COLON exp ] array_exp_repeat2
    (1) empty -> .

  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 151
    [               shift and go to state 155
    ASSIGN          reduce using rule 1 (empty -> .)
    CONNECT         reduce using rule 1 (empty -> .)
    .               reduce using rule 1 (empty -> .)
    MUL             reduce using rule 1 (empty -> .)
    DIV             reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    POWER           reduce using rule 1 (empty -> .)
    ADD             reduce using rule 1 (empty -> .)
    SUB             reduce using rule 1 (empty -> .)
    SLL             reduce using rule 1 (empty -> .)
    SRL             reduce using rule 1 (empty -> .)
    SRA             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    GE              reduce using rule 1 (empty -> .)
    LE              reduce using rule 1 (empty -> .)
    EQUAL           reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LAND            reduce using rule 1 (empty -> .)
    LOR             reduce using rule 1 (empty -> .)
    BIT_WIDTH_NUMBER reduce using rule 1 (empty -> .)
    ;               reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CONST           reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)
    MUX             reduce using rule 1 (empty -> .)
    WHEN            reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    GENERATE        reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    REG             reduce using rule 1 (empty -> .)
    WIRE            reduce using rule 1 (empty -> .)
    CLOCK           reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    NOT             reduce using rule 1 (empty -> .)
    XOR             reduce using rule 1 (empty -> .)
    XNOR            reduce using rule 1 (empty -> .)
    SIGNAL          reduce using rule 1 (empty -> .)
    NOTL            reduce using rule 1 (empty -> .)
    INTEGER_CONST   reduce using rule 1 (empty -> .)
    FLOAT_CONST     reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    ELIF            reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

  ! (               [ reduce using rule 1 (empty -> .) ]

    array_exp_repeat1              shift and go to state 152
    array_exp_repeat2              shift and go to state 153
    empty                          shift and go to state 154

state 353

    (88) seqLogStmt -> WHEN ( ID ) stmt .

    ;               reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    RETURN          reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    CONST           reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    ID              reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    {               reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    MUX             reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    WHEN            reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    IF              reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    FOR             reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    GENERATE        reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    INT             reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    FLOAT           reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    REG             reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    WIRE            reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    CLOCK           reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    AND             reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    OR              reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    NOT             reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    XOR             reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    XNOR            reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    SIGNAL          reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    (               reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    ADD             reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    SUB             reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    NOTL            reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    INTEGER_CONST   reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    FLOAT_CONST     reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    }               reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    ELIF            reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)
    ELSE            reduce using rule 88 (seqLogStmt -> WHEN ( ID ) stmt .)


state 354

    (89) seqLogStmt -> WHEN ( ID . RISING . ) stmt

    )               shift and go to state 359


state 355

    (90) seqLogStmt -> WHEN ( ID . FALLING . ) stmt

    )               shift and go to state 360


state 356

    (94) ifStmt -> IF ( exp ) stmt . elifStmt elseStmt
    (91) elifStmt -> . ELIF ( exp ) stmt elifStmt
    (92) elifStmt -> . empty
    (1) empty -> .

    ELIF            shift and go to state 362
    ELSE            reduce using rule 1 (empty -> .)

    elifStmt                       shift and go to state 361
    empty                          shift and go to state 363

state 357

    (95) forStmt -> FOR ( varDecl ; exp . ; exp ) stmt
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 364
    BIT_WIDTH_NUMBER shift and go to state 122


state 358

    (96) forStmt -> GENERATE FOR ( varDecl ; . exp ; exp ) COLON ID stmt
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 365
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 359

    (89) seqLogStmt -> WHEN ( ID . RISING ) . stmt
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 267
    RETURN          shift and go to state 272
    ID              shift and go to state 352
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    stmt                           shift and go to state 366
    lVal                           shift and go to state 265
    exp                            shift and go to state 266
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 360

    (90) seqLogStmt -> WHEN ( ID . FALLING ) . stmt
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 267
    RETURN          shift and go to state 272
    ID              shift and go to state 352
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    stmt                           shift and go to state 367
    lVal                           shift and go to state 265
    exp                            shift and go to state 266
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 361

    (94) ifStmt -> IF ( exp ) stmt elifStmt . elseStmt
    (93) elseStmt -> . ELSE stmt

    ELSE            shift and go to state 369

    elseStmt                       shift and go to state 368

state 362

    (91) elifStmt -> ELIF . ( exp ) stmt elifStmt

    (               shift and go to state 370


state 363

    (92) elifStmt -> empty .

    ELSE            reduce using rule 92 (elifStmt -> empty .)


state 364

    (95) forStmt -> FOR ( varDecl ; exp ; . exp ) stmt
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 371
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 365

    (96) forStmt -> GENERATE FOR ( varDecl ; exp . ; exp ) COLON ID stmt
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    ;               shift and go to state 372
    BIT_WIDTH_NUMBER shift and go to state 122


state 366

    (89) seqLogStmt -> WHEN ( ID . RISING ) stmt .

    ;               reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    RETURN          reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    CONST           reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    ID              reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    {               reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    MUX             reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    WHEN            reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    IF              reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    FOR             reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    GENERATE        reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    INT             reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    FLOAT           reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    REG             reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    WIRE            reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    CLOCK           reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    AND             reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    OR              reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    NOT             reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    XOR             reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    XNOR            reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    SIGNAL          reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    (               reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    ADD             reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    SUB             reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    NOTL            reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    INTEGER_CONST   reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    FLOAT_CONST     reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    }               reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    ELIF            reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)
    ELSE            reduce using rule 89 (seqLogStmt -> WHEN ( ID . RISING ) stmt .)


state 367

    (90) seqLogStmt -> WHEN ( ID . FALLING ) stmt .

    ;               reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    RETURN          reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    CONST           reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    ID              reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    {               reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    MUX             reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    WHEN            reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    IF              reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    FOR             reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    GENERATE        reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    INT             reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    FLOAT           reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    REG             reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    WIRE            reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    CLOCK           reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    AND             reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    OR              reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    NOT             reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    XOR             reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    XNOR            reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    SIGNAL          reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    (               reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    ADD             reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    SUB             reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    NOTL            reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    INTEGER_CONST   reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    FLOAT_CONST     reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    }               reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    ELIF            reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)
    ELSE            reduce using rule 90 (seqLogStmt -> WHEN ( ID . FALLING ) stmt .)


state 368

    (94) ifStmt -> IF ( exp ) stmt elifStmt elseStmt .

    ;               reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    RETURN          reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    CONST           reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    ID              reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    {               reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    MUX             reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    WHEN            reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    IF              reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    FOR             reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    GENERATE        reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    INT             reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    FLOAT           reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    REG             reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    WIRE            reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    CLOCK           reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    AND             reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    OR              reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    NOT             reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    XOR             reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    XNOR            reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    SIGNAL          reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    (               reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    ADD             reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    SUB             reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    NOTL            reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    INTEGER_CONST   reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    FLOAT_CONST     reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    }               reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    ELIF            reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)
    ELSE            reduce using rule 94 (ifStmt -> IF ( exp ) stmt elifStmt elseStmt .)


state 369

    (93) elseStmt -> ELSE . stmt
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 267
    RETURN          shift and go to state 272
    ID              shift and go to state 352
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    stmt                           shift and go to state 373
    lVal                           shift and go to state 265
    exp                            shift and go to state 266
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 370

    (91) elifStmt -> ELIF ( . exp ) stmt elifStmt
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 374
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 371

    (95) forStmt -> FOR ( varDecl ; exp ; exp . ) stmt
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 375
    BIT_WIDTH_NUMBER shift and go to state 122


state 372

    (96) forStmt -> GENERATE FOR ( varDecl ; exp ; . exp ) COLON ID stmt
    (97) exp -> . lOrExp
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    ID              shift and go to state 75
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    {               shift and go to state 82
    MUX             shift and go to state 83
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 376
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    lVal                           shift and go to state 79
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 373

    (93) elseStmt -> ELSE stmt .

    ;               reduce using rule 93 (elseStmt -> ELSE stmt .)
    RETURN          reduce using rule 93 (elseStmt -> ELSE stmt .)
    CONST           reduce using rule 93 (elseStmt -> ELSE stmt .)
    ID              reduce using rule 93 (elseStmt -> ELSE stmt .)
    {               reduce using rule 93 (elseStmt -> ELSE stmt .)
    MUX             reduce using rule 93 (elseStmt -> ELSE stmt .)
    WHEN            reduce using rule 93 (elseStmt -> ELSE stmt .)
    IF              reduce using rule 93 (elseStmt -> ELSE stmt .)
    FOR             reduce using rule 93 (elseStmt -> ELSE stmt .)
    GENERATE        reduce using rule 93 (elseStmt -> ELSE stmt .)
    INT             reduce using rule 93 (elseStmt -> ELSE stmt .)
    FLOAT           reduce using rule 93 (elseStmt -> ELSE stmt .)
    REG             reduce using rule 93 (elseStmt -> ELSE stmt .)
    WIRE            reduce using rule 93 (elseStmt -> ELSE stmt .)
    CLOCK           reduce using rule 93 (elseStmt -> ELSE stmt .)
    AND             reduce using rule 93 (elseStmt -> ELSE stmt .)
    OR              reduce using rule 93 (elseStmt -> ELSE stmt .)
    NOT             reduce using rule 93 (elseStmt -> ELSE stmt .)
    XOR             reduce using rule 93 (elseStmt -> ELSE stmt .)
    XNOR            reduce using rule 93 (elseStmt -> ELSE stmt .)
    SIGNAL          reduce using rule 93 (elseStmt -> ELSE stmt .)
    (               reduce using rule 93 (elseStmt -> ELSE stmt .)
    ADD             reduce using rule 93 (elseStmt -> ELSE stmt .)
    SUB             reduce using rule 93 (elseStmt -> ELSE stmt .)
    NOTL            reduce using rule 93 (elseStmt -> ELSE stmt .)
    INTEGER_CONST   reduce using rule 93 (elseStmt -> ELSE stmt .)
    FLOAT_CONST     reduce using rule 93 (elseStmt -> ELSE stmt .)
    }               reduce using rule 93 (elseStmt -> ELSE stmt .)
    ELIF            reduce using rule 93 (elseStmt -> ELSE stmt .)
    ELSE            reduce using rule 93 (elseStmt -> ELSE stmt .)


state 374

    (91) elifStmt -> ELIF ( exp . ) stmt elifStmt
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 377
    BIT_WIDTH_NUMBER shift and go to state 122


state 375

    (95) forStmt -> FOR ( varDecl ; exp ; exp ) . stmt
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 267
    RETURN          shift and go to state 272
    ID              shift and go to state 352
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 266
    stmt                           shift and go to state 378
    lVal                           shift and go to state 265
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 376

    (96) forStmt -> GENERATE FOR ( varDecl ; exp ; exp . ) COLON ID stmt
    (116) circuit_const -> exp . BIT_WIDTH_NUMBER

    )               shift and go to state 379
    BIT_WIDTH_NUMBER shift and go to state 122


state 377

    (91) elifStmt -> ELIF ( exp ) . stmt elifStmt
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 267
    RETURN          shift and go to state 272
    ID              shift and go to state 352
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 266
    stmt                           shift and go to state 380
    lVal                           shift and go to state 265
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 378

    (95) forStmt -> FOR ( varDecl ; exp ; exp ) stmt .

    ;               reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    RETURN          reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    CONST           reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    ID              reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    {               reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    MUX             reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    WHEN            reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    IF              reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    FOR             reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    GENERATE        reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    INT             reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    FLOAT           reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    REG             reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    WIRE            reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    CLOCK           reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    AND             reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    OR              reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    NOT             reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    XOR             reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    XNOR            reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    SIGNAL          reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    (               reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    ADD             reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    SUB             reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    NOTL            reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    INTEGER_CONST   reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    FLOAT_CONST     reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    }               reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    ELIF            reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)
    ELSE            reduce using rule 95 (forStmt -> FOR ( varDecl ; exp ; exp ) stmt .)


state 379

    (96) forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) . COLON ID stmt

    COLON           shift and go to state 381


state 380

    (91) elifStmt -> ELIF ( exp ) stmt . elifStmt
    (91) elifStmt -> . ELIF ( exp ) stmt elifStmt
    (92) elifStmt -> . empty
    (1) empty -> .

    ELIF            shift and go to state 362
    ELSE            reduce using rule 1 (empty -> .)

    elifStmt                       shift and go to state 382
    empty                          shift and go to state 363

state 381

    (96) forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON . ID stmt

    ID              shift and go to state 383


state 382

    (91) elifStmt -> ELIF ( exp ) stmt elifStmt .

    ELSE            reduce using rule 91 (elifStmt -> ELIF ( exp ) stmt elifStmt .)


state 383

    (96) forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID . stmt
    (79) stmt -> . lVal ASSIGN exp ;
    (80) stmt -> . lVal CONNECT exp ;
    (81) stmt -> . ;
    (82) stmt -> . exp
    (83) stmt -> . block
    (84) stmt -> . seqLogStmt
    (85) stmt -> . ifStmt
    (86) stmt -> . forStmt
    (87) stmt -> . RETURN exp ;
    (98) lVal -> . ID array_exp_repeat1
    (99) lVal -> . ID array_exp_repeat2
    (100) lVal -> . { ID array_exp_repeat1 lVal_repeat }
    (101) lVal -> . { ID array_exp_repeat2 lVal_repeat }
    (102) lVal -> . MUX ( exp , exp , exp )
    (103) lVal -> . lVal . ID
    (97) exp -> . lOrExp
    (76) block -> . { block_repeat }
    (88) seqLogStmt -> . WHEN ( ID ) stmt
    (89) seqLogStmt -> . WHEN ( ID . RISING ) stmt
    (90) seqLogStmt -> . WHEN ( ID . FALLING ) stmt
    (94) ifStmt -> . IF ( exp ) stmt elifStmt elseStmt
    (95) forStmt -> . FOR ( varDecl ; exp ; exp ) stmt
    (96) forStmt -> . GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
    (162) lOrExp -> . lAndExp
    (163) lOrExp -> . lOrExp LOR lAndExp
    (160) lAndExp -> . redExp
    (161) lAndExp -> . lAndExp LAND redExp
    (154) redExp -> . eqExp
    (155) redExp -> . AND eqExp
    (156) redExp -> . OR eqExp
    (157) redExp -> . NOT eqExp
    (158) redExp -> . XOR eqExp
    (159) redExp -> . XNOR eqExp
    (147) eqExp -> . relExp
    (148) eqExp -> . eqExp LT eqExp
    (149) eqExp -> . eqExp GT eqExp
    (150) eqExp -> . eqExp GE eqExp
    (151) eqExp -> . eqExp LE eqExp
    (152) eqExp -> . eqExp EQUAL eqExp
    (153) eqExp -> . eqExp NEQ eqExp
    (142) relExp -> . shiftExp
    (143) relExp -> . relExp LT addExp
    (144) relExp -> . relExp GT addExp
    (145) relExp -> . relExp GE addExp
    (146) relExp -> . relExp LE addExp
    (138) shiftExp -> . addExp
    (139) shiftExp -> . shiftExp SLL addExp
    (140) shiftExp -> . shiftExp SRL addExp
    (141) shiftExp -> . shiftExp SRA addExp
    (135) addExp -> . mulExp
    (136) addExp -> . addExp ADD mulExp
    (137) addExp -> . addExp SUB mulExp
    (130) mulExp -> . unaryExp
    (131) mulExp -> . mulExp MUL unaryExp
    (132) mulExp -> . mulExp DIV unaryExp
    (133) mulExp -> . mulExp MOD unaryExp
    (134) mulExp -> . mulExp POWER unaryExp
    (117) unaryExp -> . primaryExp
    (118) unaryExp -> . ID ( )
    (119) unaryExp -> . ID ( funcRParams )
    (120) unaryExp -> . SIGNAL ( unaryExp )
    (121) unaryExp -> . unaryOp unaryExp
    (104) primaryExp -> . ( exp )
    (105) primaryExp -> . lVal
    (106) primaryExp -> . number
    (122) unaryOp -> . ADD
    (123) unaryOp -> . SUB
    (124) unaryOp -> . NOT
    (125) unaryOp -> . NOTL
    (113) number -> . INTEGER_CONST
    (114) number -> . FLOAT_CONST
    (115) number -> . circuit_const
    (116) circuit_const -> . exp BIT_WIDTH_NUMBER

    ;               shift and go to state 267
    RETURN          shift and go to state 272
    ID              shift and go to state 352
    {               shift and go to state 259
    MUX             shift and go to state 83
    WHEN            shift and go to state 276
    IF              shift and go to state 277
    FOR             shift and go to state 278
    GENERATE        shift and go to state 279
    AND             shift and go to state 62
    OR              shift and go to state 63
    NOT             shift and go to state 64
    XOR             shift and go to state 65
    XNOR            shift and go to state 66
    SIGNAL          shift and go to state 77
    (               shift and go to state 76
    ADD             shift and go to state 71
    SUB             shift and go to state 72
    NOTL            shift and go to state 81
    INTEGER_CONST   shift and go to state 84
    FLOAT_CONST     shift and go to state 85

    exp                            shift and go to state 266
    stmt                           shift and go to state 384
    lVal                           shift and go to state 265
    block                          shift and go to state 268
    seqLogStmt                     shift and go to state 269
    ifStmt                         shift and go to state 270
    forStmt                        shift and go to state 271
    lOrExp                         shift and go to state 58
    lAndExp                        shift and go to state 59
    redExp                         shift and go to state 60
    eqExp                          shift and go to state 61
    relExp                         shift and go to state 67
    shiftExp                       shift and go to state 68
    addExp                         shift and go to state 69
    mulExp                         shift and go to state 70
    unaryExp                       shift and go to state 73
    primaryExp                     shift and go to state 74
    unaryOp                        shift and go to state 78
    number                         shift and go to state 80
    circuit_const                  shift and go to state 86

state 384

    (96) forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .

    ;               reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    RETURN          reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    CONST           reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    ID              reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    {               reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    MUX             reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    WHEN            reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    IF              reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    FOR             reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    GENERATE        reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    INT             reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    FLOAT           reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    REG             reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    WIRE            reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    CLOCK           reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    AND             reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    OR              reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    NOT             reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    XOR             reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    XNOR            reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    SIGNAL          reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    (               reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    ADD             reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    SUB             reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    NOTL            reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    INTEGER_CONST   reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    FLOAT_CONST     reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    }               reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    ELIF            reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)
    ELSE            reduce using rule 96 (forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MODULE in state 0 resolved as shift
WARNING: shift/reduce conflict for BUNDLE in state 0 resolved as shift
WARNING: shift/reduce conflict for CONST in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for REG in state 0 resolved as shift
WARNING: shift/reduce conflict for WIRE in state 0 resolved as shift
WARNING: shift/reduce conflict for CLOCK in state 0 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 1 resolved as shift
WARNING: shift/reduce conflict for BUNDLE in state 1 resolved as shift
WARNING: shift/reduce conflict for CONST in state 1 resolved as shift
WARNING: shift/reduce conflict for ID in state 1 resolved as shift
WARNING: shift/reduce conflict for INT in state 1 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 1 resolved as shift
WARNING: shift/reduce conflict for REG in state 1 resolved as shift
WARNING: shift/reduce conflict for WIRE in state 1 resolved as shift
WARNING: shift/reduce conflict for CLOCK in state 1 resolved as shift
WARNING: shift/reduce conflict for MODULE in state 25 resolved as shift
WARNING: shift/reduce conflict for BUNDLE in state 25 resolved as shift
WARNING: shift/reduce conflict for CONST in state 25 resolved as shift
WARNING: shift/reduce conflict for ID in state 25 resolved as shift
WARNING: shift/reduce conflict for INT in state 25 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 25 resolved as shift
WARNING: shift/reduce conflict for REG in state 25 resolved as shift
WARNING: shift/reduce conflict for WIRE in state 25 resolved as shift
WARNING: shift/reduce conflict for CLOCK in state 25 resolved as shift
WARNING: shift/reduce conflict for ( in state 28 resolved as shift
WARNING: shift/reduce conflict for ID in state 64 resolved as shift
WARNING: shift/reduce conflict for SIGNAL in state 64 resolved as shift
WARNING: shift/reduce conflict for ( in state 64 resolved as shift
WARNING: shift/reduce conflict for ADD in state 64 resolved as shift
WARNING: shift/reduce conflict for SUB in state 64 resolved as shift
WARNING: shift/reduce conflict for NOT in state 64 resolved as shift
WARNING: shift/reduce conflict for NOTL in state 64 resolved as shift
WARNING: shift/reduce conflict for { in state 64 resolved as shift
WARNING: shift/reduce conflict for MUX in state 64 resolved as shift
WARNING: shift/reduce conflict for INTEGER_CONST in state 64 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 64 resolved as shift
WARNING: shift/reduce conflict for AND in state 64 resolved as shift
WARNING: shift/reduce conflict for OR in state 64 resolved as shift
WARNING: shift/reduce conflict for XOR in state 64 resolved as shift
WARNING: shift/reduce conflict for XNOR in state 64 resolved as shift
WARNING: shift/reduce conflict for LT in state 67 resolved as shift
WARNING: shift/reduce conflict for GT in state 67 resolved as shift
WARNING: shift/reduce conflict for GE in state 67 resolved as shift
WARNING: shift/reduce conflict for LE in state 67 resolved as shift
WARNING: shift/reduce conflict for ADD in state 69 resolved as shift
WARNING: shift/reduce conflict for SUB in state 69 resolved as shift
WARNING: shift/reduce conflict for ( in state 75 resolved as shift
WARNING: shift/reduce conflict for ID in state 133 resolved as shift
WARNING: shift/reduce conflict for SIGNAL in state 133 resolved as shift
WARNING: shift/reduce conflict for ( in state 133 resolved as shift
WARNING: shift/reduce conflict for ADD in state 133 resolved as shift
WARNING: shift/reduce conflict for SUB in state 133 resolved as shift
WARNING: shift/reduce conflict for NOT in state 133 resolved as shift
WARNING: shift/reduce conflict for NOTL in state 133 resolved as shift
WARNING: shift/reduce conflict for { in state 133 resolved as shift
WARNING: shift/reduce conflict for MUX in state 133 resolved as shift
WARNING: shift/reduce conflict for INTEGER_CONST in state 133 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 133 resolved as shift
WARNING: shift/reduce conflict for AND in state 133 resolved as shift
WARNING: shift/reduce conflict for OR in state 133 resolved as shift
WARNING: shift/reduce conflict for XOR in state 133 resolved as shift
WARNING: shift/reduce conflict for XNOR in state 133 resolved as shift
WARNING: shift/reduce conflict for LT in state 198 resolved as shift
WARNING: shift/reduce conflict for GT in state 198 resolved as shift
WARNING: shift/reduce conflict for GE in state 198 resolved as shift
WARNING: shift/reduce conflict for LE in state 198 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 198 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 198 resolved as shift
WARNING: shift/reduce conflict for LT in state 199 resolved as shift
WARNING: shift/reduce conflict for GT in state 199 resolved as shift
WARNING: shift/reduce conflict for GE in state 199 resolved as shift
WARNING: shift/reduce conflict for LE in state 199 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 199 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 199 resolved as shift
WARNING: shift/reduce conflict for LT in state 200 resolved as shift
WARNING: shift/reduce conflict for GT in state 200 resolved as shift
WARNING: shift/reduce conflict for GE in state 200 resolved as shift
WARNING: shift/reduce conflict for LE in state 200 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 200 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 200 resolved as shift
WARNING: shift/reduce conflict for LT in state 201 resolved as shift
WARNING: shift/reduce conflict for GT in state 201 resolved as shift
WARNING: shift/reduce conflict for GE in state 201 resolved as shift
WARNING: shift/reduce conflict for LE in state 201 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 201 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 201 resolved as shift
WARNING: shift/reduce conflict for LT in state 202 resolved as shift
WARNING: shift/reduce conflict for GT in state 202 resolved as shift
WARNING: shift/reduce conflict for GE in state 202 resolved as shift
WARNING: shift/reduce conflict for LE in state 202 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 202 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 202 resolved as shift
WARNING: shift/reduce conflict for LT in state 203 resolved as shift
WARNING: shift/reduce conflict for GT in state 203 resolved as shift
WARNING: shift/reduce conflict for GE in state 203 resolved as shift
WARNING: shift/reduce conflict for LE in state 203 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 203 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 203 resolved as shift
WARNING: shift/reduce conflict for ADD in state 204 resolved as shift
WARNING: shift/reduce conflict for SUB in state 204 resolved as shift
WARNING: shift/reduce conflict for ADD in state 205 resolved as shift
WARNING: shift/reduce conflict for SUB in state 205 resolved as shift
WARNING: shift/reduce conflict for ADD in state 206 resolved as shift
WARNING: shift/reduce conflict for SUB in state 206 resolved as shift
WARNING: shift/reduce conflict for ADD in state 207 resolved as shift
WARNING: shift/reduce conflict for SUB in state 207 resolved as shift
WARNING: shift/reduce conflict for ADD in state 208 resolved as shift
WARNING: shift/reduce conflict for SUB in state 208 resolved as shift
WARNING: shift/reduce conflict for ADD in state 209 resolved as shift
WARNING: shift/reduce conflict for SUB in state 209 resolved as shift
WARNING: shift/reduce conflict for ADD in state 210 resolved as shift
WARNING: shift/reduce conflict for SUB in state 210 resolved as shift
WARNING: shift/reduce conflict for ID in state 275 resolved as shift
WARNING: shift/reduce conflict for ( in state 275 resolved as shift
WARNING: shift/reduce conflict for ID in state 302 resolved as shift
WARNING: shift/reduce conflict for ( in state 302 resolved as shift
WARNING: shift/reduce conflict for , in state 318 resolved as shift
WARNING: shift/reduce conflict for , in state 319 resolved as shift
WARNING: shift/reduce conflict for ( in state 352 resolved as shift
WARNING: reduce/reduce conflict in state 25 resolved using rule (empty -> <empty>)
WARNING: rejected rule (compUnit -> compUnit compUnit) in state 25
WARNING: reduce/reduce conflict in state 131 resolved using rule (redExp -> eqExp)
WARNING: rejected rule (redExp -> AND eqExp) in state 131
WARNING: reduce/reduce conflict in state 134 resolved using rule (redExp -> eqExp)
WARNING: rejected rule (redExp -> OR eqExp) in state 134
WARNING: reduce/reduce conflict in state 135 resolved using rule (redExp -> eqExp)
WARNING: rejected rule (redExp -> NOT eqExp) in state 135
WARNING: reduce/reduce conflict in state 136 resolved using rule (redExp -> eqExp)
WARNING: rejected rule (redExp -> XOR eqExp) in state 136
WARNING: reduce/reduce conflict in state 137 resolved using rule (redExp -> eqExp)
WARNING: rejected rule (redExp -> XNOR eqExp) in state 137
WARNING: reduce/reduce conflict in state 154 resolved using rule (array_exp_repeat1 -> empty)
WARNING: rejected rule (array_exp_repeat2 -> empty) in state 154
WARNING: reduce/reduce conflict in state 158 resolved using rule (unaryExp -> unaryOp unaryExp)
WARNING: rejected rule (mulExp -> unaryExp) in state 158
WARNING: reduce/reduce conflict in state 196 resolved using rule (lOrExp -> lAndExp)
WARNING: rejected rule (lOrExp -> lOrExp LOR lAndExp) in state 196
WARNING: reduce/reduce conflict in state 197 resolved using rule (lAndExp -> redExp)
WARNING: rejected rule (lAndExp -> lAndExp LAND redExp) in state 197
WARNING: reduce/reduce conflict in state 198 resolved using rule (eqExp -> eqExp LT eqExp)
WARNING: rejected rule (redExp -> eqExp) in state 198
WARNING: reduce/reduce conflict in state 199 resolved using rule (eqExp -> eqExp GT eqExp)
WARNING: rejected rule (redExp -> eqExp) in state 199
WARNING: reduce/reduce conflict in state 200 resolved using rule (eqExp -> eqExp GE eqExp)
WARNING: rejected rule (redExp -> eqExp) in state 200
WARNING: reduce/reduce conflict in state 201 resolved using rule (eqExp -> eqExp LE eqExp)
WARNING: rejected rule (redExp -> eqExp) in state 201
WARNING: reduce/reduce conflict in state 202 resolved using rule (eqExp -> eqExp EQUAL eqExp)
WARNING: rejected rule (redExp -> eqExp) in state 202
WARNING: reduce/reduce conflict in state 203 resolved using rule (eqExp -> eqExp NEQ eqExp)
WARNING: rejected rule (redExp -> eqExp) in state 203
WARNING: reduce/reduce conflict in state 204 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (relExp -> relExp LT addExp) in state 204
WARNING: reduce/reduce conflict in state 205 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (relExp -> relExp GT addExp) in state 205
WARNING: reduce/reduce conflict in state 206 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (relExp -> relExp GE addExp) in state 206
WARNING: reduce/reduce conflict in state 207 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (relExp -> relExp LE addExp) in state 207
WARNING: reduce/reduce conflict in state 208 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (shiftExp -> shiftExp SLL addExp) in state 208
WARNING: reduce/reduce conflict in state 209 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (shiftExp -> shiftExp SRL addExp) in state 209
WARNING: reduce/reduce conflict in state 210 resolved using rule (shiftExp -> addExp)
WARNING: rejected rule (shiftExp -> shiftExp SRA addExp) in state 210
WARNING: reduce/reduce conflict in state 211 resolved using rule (addExp -> mulExp)
WARNING: rejected rule (addExp -> addExp ADD mulExp) in state 211
WARNING: reduce/reduce conflict in state 212 resolved using rule (addExp -> mulExp)
WARNING: rejected rule (addExp -> addExp SUB mulExp) in state 212
WARNING: reduce/reduce conflict in state 213 resolved using rule (mulExp -> unaryExp)
WARNING: rejected rule (mulExp -> mulExp MUL unaryExp) in state 213
WARNING: reduce/reduce conflict in state 214 resolved using rule (mulExp -> unaryExp)
WARNING: rejected rule (mulExp -> mulExp DIV unaryExp) in state 214
WARNING: reduce/reduce conflict in state 215 resolved using rule (mulExp -> unaryExp)
WARNING: rejected rule (mulExp -> mulExp MOD unaryExp) in state 215
WARNING: reduce/reduce conflict in state 216 resolved using rule (mulExp -> unaryExp)
WARNING: rejected rule (mulExp -> mulExp POWER unaryExp) in state 216
WARNING: reduce/reduce conflict in state 219 resolved using rule (empty -> <empty>)
WARNING: rejected rule (funcRParams -> exp) in state 219
WARNING: reduce/reduce conflict in state 318 resolved using rule (empty -> <empty>)
WARNING: rejected rule (lVal -> ID array_exp_repeat1) in state 318
WARNING: reduce/reduce conflict in state 319 resolved using rule (empty -> <empty>)
WARNING: rejected rule (lVal -> ID array_exp_repeat2) in state 319
WARNING: Rule (compUnit -> compUnit compUnit) is never reduced
WARNING: Rule (funcRParams -> exp) is never reduced
