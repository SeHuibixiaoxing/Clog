Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> compUnit
Rule 1     empty -> <empty>
Rule 2     compUnit -> empty
Rule 3     compUnit -> compUnit compUnit
Rule 4     compUnit -> decl
Rule 5     compUnit -> cir_function
Rule 6     compUnit -> function
Rule 7     compUnit -> module
Rule 8     compUnit -> bundle
Rule 9     decl -> constDecl
Rule 10    decl -> varDecl
Rule 11    decl -> cirDecl
Rule 12    decl -> modDecl
Rule 13    decl -> bundleDecl
Rule 14    constDecl_repeat -> empty
Rule 15    constDecl_repeat -> , constDef constDecl_repeat
Rule 16    constDecl -> CONST val_type constDef constDecl_repeat ;
Rule 17    cir_basic_type -> REG
Rule 18    cir_basic_type -> WIRE
Rule 19    cir_basic_type -> CLOCK
Rule 20    cir_type -> cir_basic_type
Rule 21    cir_type -> cir_basic_type [ exp ]
Rule 22    val_type -> INT
Rule 23    val_type -> FLOAT
Rule 24    type_def -> val_type
Rule 25    type_def -> cir_type
Rule 26    array -> empty
Rule 27    array -> [ constExp ] array
Rule 28    constDef -> ID array ASSIGN constInitVal
Rule 29    constInitVal_repeat -> empty
Rule 30    constInitVal_repeat -> , constInitVal constInitVal_repeat
Rule 31    constInitVal -> constExp
Rule 32    constInitVal -> { constInitVal constInitVal_repeat }
Rule 33    varDef_repeat -> empty
Rule 34    varDef_repeat -> , varDef varDef_repeat
Rule 35    varDecl -> val_type varDef varDef_repeat ;
Rule 36    varDef -> ID array
Rule 37    varDef -> ID array ASSIGN initVal
Rule 38    modDecl -> ID ID ( module_R_params )
Rule 39    R_port_def -> IN .
Rule 40    R_port_def -> OUT .
Rule 41    R_port_def -> INOUT .
Rule 42    p_module_R_params_item -> R_port_def ID ( ID )
Rule 43    module_R_params_repeat -> empty
Rule 44    module_R_params_repeat -> , p_module_R_params_item module_R_params_repeat
Rule 45    module_R_params -> p_module_R_params_item module_R_params_repeat
Rule 46    bundleDecl_repeat -> empty
Rule 47    bundleDecl_repeat -> , bundleDef bundleDecl_repeat
Rule 48    bundleDecl -> ID bundleDef bundleDecl_repeat
Rule 49    bundleDef -> ID array
Rule 50    initVal -> exp ;
Rule 51    cirDecl_repeat -> empty
Rule 52    cirDecl_repeat -> , cirDef cirDecl_repeat
Rule 53    cirDecl -> cir_type cirDef cirDecl_repeat ;
Rule 54    cirDef -> ID array
Rule 55    cirDef -> ID array ASSIGN initVal
Rule 56    cir_function -> cir_type ID ( cir_funcFParams ) block
Rule 57    function -> val_type ID ( funcFParams ) block
Rule 58    cir_funcFParams_repeat -> empty
Rule 59    cir_funcFParams_repeat -> , cir_funcFParam cir_funcFParams_repeat
Rule 60    cir_funcFParams -> cir_funcFParam cir_funcFParams_repeat
Rule 61    funcFParams_repeat -> empty
Rule 62    funcFParams_repeat -> , funcFParam funcFParams_repeat
Rule 63    funcFParams -> funcFParam funcFParams_repeat
Rule 64    cir_funcFParam -> type_def ID array
Rule 65    funcFParam -> val_type ID array
Rule 66    module_para_para -> empty
Rule 67    module_para_para -> PARA ID , module_para_para
Rule 68    p_module_para_port -> empty
Rule 69    p_module_para_port -> , port_def ID p_module_para_port
Rule 70    module -> MODULE ID ( module_para_para port_def ID p_module_para_port
Rule 71    bundle_repeat -> empty
Rule 72    bundle_repeat -> , cir_type ID bundle bundle_repeat
Rule 73    bundle -> BUNDLE ID ( cir_type ID bundle_repeat )
Rule 74    block_repeat -> empty
Rule 75    block_repeat -> blockItem block_repeat
Rule 76    block -> { block_repeat }
Rule 77    blockItem -> decl
Rule 78    blockItem -> stmt
Rule 79    stmt -> lVal ASSIGN exp ;
Rule 80    stmt -> lVal CONNECT exp ;
Rule 81    stmt -> ;
Rule 82    stmt -> exp
Rule 83    stmt -> block
Rule 84    stmt -> seqLogStmt
Rule 85    stmt -> ifStmt
Rule 86    stmt -> forStmt
Rule 87    stmt -> RETURN exp ;
Rule 88    seqLogStmt -> WHEN ( ID ) stmt
Rule 89    seqLogStmt -> WHEN ( ID . RISING ) stmt
Rule 90    seqLogStmt -> WHEN ( ID . FALLING ) stmt
Rule 91    elifStmt -> ELIF ( exp ) stmt elifStmt
Rule 92    elifStmt -> empty
Rule 93    elseStmt -> ELSE stmt
Rule 94    ifStmt -> IF ( exp ) stmt elifStmt elseStmt
Rule 95    forStmt -> FOR ( varDecl ; exp ; exp ) stmt
Rule 96    forStmt -> GENERATE FOR ( varDecl ; exp ; exp ) COLON ID stmt
Rule 97    exp -> lOrExp
Rule 98    lVal -> ID array_exp_repeat1
Rule 99    lVal -> ID array_exp_repeat2
Rule 100   lVal -> { ID array_exp_repeat1 lVal_repeat }
Rule 101   lVal -> { ID array_exp_repeat2 lVal_repeat }
Rule 102   lVal -> MUX ( exp , exp , exp )
Rule 103   lVal -> lVal . ID
Rule 104   primaryExp -> ( exp )
Rule 105   primaryExp -> lVal
Rule 106   primaryExp -> number
Rule 107   lVal_repeat -> empty
Rule 108   lVal_repeat -> , lVal lVal_repeat
Rule 109   array_exp_repeat1 -> empty
Rule 110   array_exp_repeat1 -> [ exp ] array_exp_repeat1
Rule 111   array_exp_repeat2 -> empty
Rule 112   array_exp_repeat2 -> [ exp COLON exp ] array_exp_repeat2
Rule 113   number -> INTEGER_CONST
Rule 114   number -> FLOAT_CONST
Rule 115   number -> circuit_const
Rule 116   circuit_const -> exp BIT_WIDTH_NUMBER
Rule 117   unaryExp -> primaryExp
Rule 118   unaryExp -> ID ( )
Rule 119   unaryExp -> ID ( funcRParams )
Rule 120   unaryExp -> SIGNAL ( unaryExp )
Rule 121   unaryExp -> unaryOp unaryExp
Rule 122   unaryOp -> ADD
Rule 123   unaryOp -> SUB
Rule 124   unaryOp -> NOT
Rule 125   unaryOp -> NOTL
Rule 126   exp_repeat -> empty
Rule 127   exp_repeat -> , exp exp_repeat
Rule 128   funcRParams -> exp
Rule 129   funcRParams -> exp exp_repeat
Rule 130   mulExp -> unaryExp
Rule 131   mulExp -> mulExp MUL unaryExp
Rule 132   mulExp -> mulExp DIV unaryExp
Rule 133   mulExp -> mulExp MOD unaryExp
Rule 134   mulExp -> mulExp POWER unaryExp
Rule 135   addExp -> mulExp
Rule 136   addExp -> addExp ADD mulExp
Rule 137   addExp -> addExp SUB mulExp
Rule 138   shiftExp -> addExp
Rule 139   shiftExp -> shiftExp SLL addExp
Rule 140   shiftExp -> shiftExp SRL addExp
Rule 141   shiftExp -> shiftExp SRA addExp
Rule 142   relExp -> shiftExp
Rule 143   relExp -> relExp LT addExp
Rule 144   relExp -> relExp GT addExp
Rule 145   relExp -> relExp GE addExp
Rule 146   relExp -> relExp LE addExp
Rule 147   eqExp -> relExp
Rule 148   eqExp -> eqExp LT eqExp
Rule 149   eqExp -> eqExp GT eqExp
Rule 150   eqExp -> eqExp GE eqExp
Rule 151   eqExp -> eqExp LE eqExp
Rule 152   eqExp -> eqExp EQUAL eqExp
Rule 153   eqExp -> eqExp NEQ eqExp
Rule 154   redExp -> eqExp
Rule 155   redExp -> AND eqExp
Rule 156   redExp -> OR eqExp
Rule 157   redExp -> NOT eqExp
Rule 158   redExp -> XOR eqExp
Rule 159   redExp -> XNOR eqExp
Rule 160   lAndExp -> redExp
Rule 161   lAndExp -> lAndExp LAND redExp
Rule 162   lOrExp -> lAndExp
Rule 163   lOrExp -> lOrExp LOR lAndExp
Rule 164   port_def -> INPUT
Rule 165   port_def -> OUTPUT
Rule 166   port_def -> INOUT
Rule 167   constExp -> exp

Terminals, with rules where they appear

(                    : 38 42 56 57 70 73 88 89 90 91 94 95 96 102 104 118 119 120
)                    : 38 42 56 57 73 88 89 90 91 94 95 96 102 104 118 119 120
,                    : 15 30 34 44 47 52 59 62 67 69 72 102 102 108 127
.                    : 39 40 41 89 90 103
;                    : 16 35 50 53 79 80 81 87 95 95 96 96
ADD                  : 122 136
AND                  : 155
ASSIGN               : 28 37 55 79
BIT_WIDTH_NUMBER     : 116
BUNDLE               : 73
CLOCK                : 19
COLON                : 96 112
CONNECT              : 80
CONST                : 16
DIV                  : 132
ELIF                 : 91
ELSE                 : 93
EQUAL                : 152
FALLING              : 90
FLOAT                : 23
FLOAT_CONST          : 114
FOR                  : 95 96
GE                   : 145 150
GENERATE             : 96
GT                   : 144 149
ID                   : 28 36 37 38 38 42 42 48 49 54 55 56 57 64 65 67 69 70 70 72 73 73 88 89 90 96 98 99 100 101 103 118 119
IF                   : 94
IN                   : 39
INOUT                : 41 166
INPUT                : 164
INT                  : 22
INTEGER_CONST        : 113
LAND                 : 161
LE                   : 146 151
LOR                  : 163
LT                   : 143 148
MOD                  : 133
MODULE               : 70
MUL                  : 131
MUX                  : 102
NEQ                  : 153
NOT                  : 124 157
NOTL                 : 125
OR                   : 156
OUT                  : 40
OUTPUT               : 165
PARA                 : 67
POWER                : 134
REG                  : 17
RETURN               : 87
RISING               : 89
SIGNAL               : 120
SLL                  : 139
SRA                  : 141
SRL                  : 140
SUB                  : 123 137
WHEN                 : 88 89 90
WIRE                 : 18
XNOR                 : 159
XOR                  : 158
[                    : 21 27 110 112
]                    : 21 27 110 112
error                : 
{                    : 32 76 100 101
}                    : 32 76 100 101

Nonterminals, with rules where they appear

R_port_def           : 42
addExp               : 136 137 138 139 140 141 143 144 145 146
array                : 27 28 36 37 49 54 55 64 65
array_exp_repeat1    : 98 100 110
array_exp_repeat2    : 99 101 112
block                : 56 57 83
blockItem            : 75
block_repeat         : 75 76
bundle               : 8 72
bundleDecl           : 13
bundleDecl_repeat    : 47 48
bundleDef            : 47 48
bundle_repeat        : 72 73
cirDecl              : 11
cirDecl_repeat       : 52 53
cirDef               : 52 53
cir_basic_type       : 20 21
cir_funcFParam       : 59 60
cir_funcFParams      : 56
cir_funcFParams_repeat : 59 60
cir_function         : 5
cir_type             : 25 53 56 72 73
circuit_const        : 115
compUnit             : 3 3 0
constDecl            : 9
constDecl_repeat     : 15 16
constDef             : 15 16
constExp             : 27 31
constInitVal         : 28 30 32
constInitVal_repeat  : 30 32
decl                 : 4 77
elifStmt             : 91 94
elseStmt             : 94
empty                : 2 14 26 29 33 43 46 51 58 61 66 68 71 74 92 107 109 111 126
eqExp                : 148 148 149 149 150 150 151 151 152 152 153 153 154 155 156 157 158 159
exp                  : 21 50 79 80 82 87 91 94 95 95 96 96 102 102 102 104 110 112 112 116 127 128 129 167
exp_repeat           : 127 129
forStmt              : 86
funcFParam           : 62 63
funcFParams          : 57
funcFParams_repeat   : 62 63
funcRParams          : 119
function             : 6
ifStmt               : 85
initVal              : 37 55
lAndExp              : 161 162 163
lOrExp               : 97 163
lVal                 : 79 80 103 105 108
lVal_repeat          : 100 101 108
modDecl              : 12
module               : 7
module_R_params      : 38
module_R_params_repeat : 44 45
module_para_para     : 67 70
mulExp               : 131 132 133 134 135 136 137
number               : 106
p_module_R_params_item : 44 45
p_module_para_port   : 69 70
port_def             : 69 70
primaryExp           : 117
redExp               : 160 161
relExp               : 143 144 145 146 147
seqLogStmt           : 84
shiftExp             : 139 140 141 142
stmt                 : 78 88 89 90 91 93 94 95 96
type_def             : 64
unaryExp             : 120 121 130 131 132 133 134
unaryOp              : 121
val_type             : 16 24 35 57 65
varDecl              : 10 95 96
varDef               : 34 35
varDef_repeat        : 34 35

Parsing method: LALR

state 0

    (0) S' -> . compUnit
    (2) compUnit -> . empty
    (3) compUnit -> . compUnit compUnit
    (4) compUnit -> . decl
    (5) compUnit -> . cir_function
    (6) compUnit -> . function
    (7) compUnit -> . module
    (8) compUnit -> . bundle
    (1) empty -> .
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (56) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (57) function -> . val_type ID ( funcFParams ) block
    (70) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port
    (73) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (53) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (38) modDecl -> . ID ID ( module_R_params )
    (48) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK

  ! shift/reduce conflict for MODULE resolved as shift
  ! shift/reduce conflict for BUNDLE resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for REG resolved as shift
  ! shift/reduce conflict for WIRE resolved as shift
  ! shift/reduce conflict for CLOCK resolved as shift
    $end            reduce using rule 1 (empty -> .)
    MODULE          shift and go to state 16
    BUNDLE          shift and go to state 17
    CONST           shift and go to state 18
    ID              shift and go to state 14
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    REG             shift and go to state 22
    WIRE            shift and go to state 23
    CLOCK           shift and go to state 24

  ! MODULE          [ reduce using rule 1 (empty -> .) ]
  ! BUNDLE          [ reduce using rule 1 (empty -> .) ]
  ! CONST           [ reduce using rule 1 (empty -> .) ]
  ! ID              [ reduce using rule 1 (empty -> .) ]
  ! INT             [ reduce using rule 1 (empty -> .) ]
  ! FLOAT           [ reduce using rule 1 (empty -> .) ]
  ! REG             [ reduce using rule 1 (empty -> .) ]
  ! WIRE            [ reduce using rule 1 (empty -> .) ]
  ! CLOCK           [ reduce using rule 1 (empty -> .) ]

    compUnit                       shift and go to state 1
    empty                          shift and go to state 2
    decl                           shift and go to state 3
    cir_function                   shift and go to state 4
    function                       shift and go to state 5
    module                         shift and go to state 6
    bundle                         shift and go to state 7
    constDecl                      shift and go to state 8
    varDecl                        shift and go to state 9
    cirDecl                        shift and go to state 10
    modDecl                        shift and go to state 11
    bundleDecl                     shift and go to state 12
    cir_type                       shift and go to state 13
    val_type                       shift and go to state 15
    cir_basic_type                 shift and go to state 19

state 1

    (0) S' -> compUnit .
    (3) compUnit -> compUnit . compUnit
    (2) compUnit -> . empty
    (3) compUnit -> . compUnit compUnit
    (4) compUnit -> . decl
    (5) compUnit -> . cir_function
    (6) compUnit -> . function
    (7) compUnit -> . module
    (8) compUnit -> . bundle
    (1) empty -> .
    (9) decl -> . constDecl
    (10) decl -> . varDecl
    (11) decl -> . cirDecl
    (12) decl -> . modDecl
    (13) decl -> . bundleDecl
    (56) cir_function -> . cir_type ID ( cir_funcFParams ) block
    (57) function -> . val_type ID ( funcFParams ) block
    (70) module -> . MODULE ID ( module_para_para port_def ID p_module_para_port
    (73) bundle -> . BUNDLE ID ( cir_type ID bundle_repeat )
    (16) constDecl -> . CONST val_type constDef constDecl_repeat ;
    (35) varDecl -> . val_type varDef varDef_repeat ;
    (53) cirDecl -> . cir_type cirDef cirDecl_repeat ;
    (38) modDecl -> . ID ID ( module_R_params )
    (48) bundleDecl -> . ID bundleDef bundleDecl_repeat
    (20) cir_type -> . cir_basic_type
    (21) cir_type -> . cir_basic_type [ exp ]
    (22) val_type -> . INT
    (23) val_type -> . FLOAT
    (17) cir_basic_type -> . REG
    (18) cir_basic_type -> . WIRE
    (19) cir_basic_type -> . CLOCK

